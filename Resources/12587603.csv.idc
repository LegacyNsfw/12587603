static main() {
auto nameFlags = 0;
MakeNameEx(0x00008000, "ENG_CALIBRATIONS_HEADER", nameFlags);
MakeRptCmt(0x00008000, "Use this cal to identify the engine calibration\nCal_ID_Record");
MakeNameEx(0x0000801C, "FLASH_PROM_ID", nameFlags);
MakeNameEx(0x00008020, "FLASH_KE_SERVICE_CALIBRATION", nameFlags);
MakeNameEx(0x00008021, "CIC_KE_CIC_MEDIUM_RES_REF_FILTER", nameFlags);
MakeNameEx(0x00008022, "ETAS_KE_ETAS_PRESENCE_PATTERN", nameFlags);
MakeRptCmt(0x00008022, "Special calibration location written to by ETAS when ETAS instrumentation is hooked up.\nCARDINAL");
MakeNameEx(0x00008024, "ETAS_KE_ETAS_PAD_BYTE_1", nameFlags);
MakeRptCmt(0x00008024, "ETAS Pad Byte is used to place slew cals on the proper byte boundry. Changing it's value does nothing.\nByte");
MakeNameEx(0x00008025, "ETAS_KE_ETAS_PAD_BYTE_2", nameFlags);
MakeRptCmt(0x00008025, "ETAS Pad Byte is used to place slew cals on the proper byte boundry. Changing it's value does nothing.\nByte");
MakeNameEx(0x00008026, "ETAS_KE_ETAS_PAD_BYTE_3", nameFlags);
MakeRptCmt(0x00008026, "ETAS Pad Byte is used to place slew cals on the proper byte boundry. Changing it's value does nothing.\nByte");
MakeNameEx(0x00008027, "ETAS_KE_ETAS_DATA_ACQUIRE_RATE_GROUP", nameFlags);
MakeNameEx(0x00008028, "ETAS_KE_ETAS_SLEW_CCP_MODE", nameFlags);
MakeRptCmt(0x00008028, "Use this cal when slewing with ETAS to select thedesired mode.\nSlew_Modes");
MakeNameEx(0x0000802A, "ETAS_KE_ETAS_SLEW_CCP_ABS", nameFlags);
MakeNameEx(0x0000802C, "ETAS_KE_ETAS_SLEW_CCP_MOD", nameFlags);
MakeRptCmt(0x0000802C, "This cal is modifiable at runtime when using ETAS instrumentation and is added to a variables contents when in Modify mode.\nPercent");
MakeNameEx(0x0000802E, "ETAS_KE_ETAS_SLEW_EQVR_MODE", nameFlags);
MakeRptCmt(0x0000802E, "Use this cal when slewing with ETAS to select thedesired mode.\nSlew_Modes");
MakeNameEx(0x00008030, "ETAS_KE_ETAS_SLEW_EQVR_ABS", nameFlags);
MakeNameEx(0x00008032, "ETAS_KE_ETAS_SLEW_EQVR_MOD", nameFlags);
MakeRptCmt(0x00008032, "This cal is modifiable at runtime when using ETAS instrumentation and is added to a variables contents when in Modify mode.\nEquiv_Ratio");
MakeNameEx(0x00008034, "ETAS_KE_ETAS_SLEW_EGR_MODE", nameFlags);
MakeRptCmt(0x00008034, "Use this cal when slewing with ETAS to select thedesired mode.\nSlew_Modes");
MakeNameEx(0x00008036, "ETAS_KE_ETAS_SLEW_EGR_ABS", nameFlags);
MakeNameEx(0x00008038, "ETAS_KE_ETAS_SLEW_EGR_MOD", nameFlags);
MakeRptCmt(0x00008038, "This cal is modifiable at runtime when using ETAS instrumentation and is added to a variables contents when in Modify mode.\nPercent");
MakeNameEx(0x0000803A, "ETAS_KE_ETAS_SLEW_FANHZ_MODE", nameFlags);
MakeRptCmt(0x0000803A, "Use this cal when slewing with ETAS to select thedesired mode.\nSlew_Modes");
MakeNameEx(0x0000803C, "ETAS_KE_ETAS_SLEW_FANHZ_ABS", nameFlags);
MakeNameEx(0x0000803E, "ETAS_KE_ETAS_SLEW_FANHZ_MOD", nameFlags);
MakeRptCmt(0x0000803E, "This cal is modifiable at runtime when using ETAS instrumentation and is added to a variables contents when in Modify mode.\nHertz");
MakeNameEx(0x00008040, "ETAS_KE_ETAS_SLEW_FFS_HZ_MODE", nameFlags);
MakeRptCmt(0x00008040, "Use this cal when slewing with ETAS to select thedesired mode.\nSlew_Modes");
MakeNameEx(0x00008042, "ETAS_KE_ETAS_SLEW_FFS_HZ_ABS", nameFlags);
MakeNameEx(0x00008044, "ETAS_KE_ETAS_SLEW_FFS_HZ_MOD", nameFlags);
MakeRptCmt(0x00008044, "This cal is modifiable at runtime when using ETAS instrumentation and is added to a variables contents when in Modify mode.\nHertz");
MakeNameEx(0x00008046, "ETAS_KE_ETAS_SLEW_FFS_LOW_TIME_MODE", nameFlags);
MakeRptCmt(0x00008046, "Use this cal when slewing with ETAS to select thedesired mode.\nSlew_Modes");
MakeNameEx(0x00008048, "ETAS_KE_ETAS_SLEW_FFS_LOW_TIME_ABS", nameFlags);
MakeNameEx(0x0000804A, "ETAS_KE_ETAS_SLEW_FFS_LOW_TIME_MOD", nameFlags);
MakeRptCmt(0x0000804A, "This cal is modifiable at runtime when using ETAS instrumentation and is added to a variables contents when in Modify mode.\nMilliseconds");
MakeNameEx(0x0000804C, "ETAS_KE_ETAS_SLEW_FUEL_ECON_MODE", nameFlags);
MakeRptCmt(0x0000804C, "Use this cal when slewing with ETAS to select thedesired mode.\nSlew_Modes");
MakeNameEx(0x0000804D, "ETAS_KE_ETAS_SLEW_FUEL_ECON_SIGN", nameFlags);
MakeNameEx(0x0000804E, "ETAS_KE_ETAS_SLEW_NVMEM_MODE", nameFlags);
MakeRptCmt(0x0000804E, "Use this cal when slewing with ETAS to select thedesired mode.\nSlew_Modes");
MakeNameEx(0x0000804F, "ETAS_KE_ETAS_SLEW_NVMEM_ABS", nameFlags);
MakeNameEx(0x00008050, "ETAS_KE_ETAS_SLEW_NVMEM_MOD", nameFlags);
MakeNameEx(0x00008051, "ETAS_KE_ETAS_SLEW_TCS_DISCRETE_MODE", nameFlags);
MakeRptCmt(0x00008051, "Use this cal when slewing with ETAS to select thedesired mode.\nSlew_Modes");
MakeNameEx(0x00008052, "ETAS_KE_ETAS_SLEW_TCS_DISCRETE_ABS", nameFlags);
MakeNameEx(0x00008053, "ETAS_KE_ETAS_SLEW_TCS_DISCRETE_MOD", nameFlags);
MakeRptCmt(0x00008053, "This cal is modifiable at runtime when using ETAS instrumentation and is added to a variables contents when in Modify mode.\nBOOLEAN");
MakeNameEx(0x00008054, "ETAS_KE_ETAS_SLEW_TCS_DC_MODE", nameFlags);
MakeRptCmt(0x00008054, "Use this cal when slewing with ETAS to select thedesired mode.\nSlew_Modes");
MakeNameEx(0x00008056, "ETAS_KE_ETAS_SLEW_TCS_DC_ABS", nameFlags);
MakeNameEx(0x00008058, "ETAS_KE_ETAS_SLEW_TCS_DC_MOD", nameFlags);
MakeRptCmt(0x00008058, "This cal is modifiable at runtime when using ETAS instrumentation and is added to a variables contents when in Modify mode.\nPercent");
MakeNameEx(0x0000805A, "ETAS_KE_ETAS_SLEW_SPARK_CRANK_MODE", nameFlags);
MakeRptCmt(0x0000805A, "Use this cal when slewing with ETAS to select thedesired mode.\nSlew_Modes");
MakeNameEx(0x0000805C, "ETAS_KE_ETAS_SLEW_SPARK_CRANK_ABS", nameFlags);
MakeNameEx(0x0000805E, "ETAS_KE_ETAS_SLEW_SPARK_CRANK_MOD", nameFlags);
MakeRptCmt(0x0000805E, "This cal is modifiable at runtime when using ETAS instrumentation and is added to a variables contents when in Modify mode.\nDegrees");
MakeNameEx(0x00008060, "ETAS_KE_ETAS_SLEW_SPARK_RUN_MODE", nameFlags);
MakeRptCmt(0x00008060, "Use this cal when slewing with ETAS to select thedesired mode.\nSlew_Modes");
MakeNameEx(0x00008062, "ETAS_KE_ETAS_SLEW_SPARK_RUN_ABS", nameFlags);
MakeNameEx(0x00008064, "ETAS_KE_ETAS_SLEW_SPARK_RUN_MOD", nameFlags);
MakeRptCmt(0x00008064, "This cal is modifiable at runtime when using ETAS instrumentation and is added to a variables contents when in Modify mode.\nDegrees");
MakeNameEx(0x00008066, "ETAS_KE_ETAS_SLEW_IAC_AIRFLOW_MODE", nameFlags);
MakeRptCmt(0x00008066, "Use this cal when slewing with ETAS to select thedesired mode.\nSlew_Modes");
MakeNameEx(0x00008068, "ETAS_KE_ETAS_SLEW_IAC_AIRFLOW_ABS", nameFlags);
MakeNameEx(0x0000806A, "ETAS_KE_ETAS_SLEW_IAC_AIRFLOW_MOD", nameFlags);
MakeRptCmt(0x0000806A, "This cal is modifiable at runtime when using ETAS instrumentation and is added to a variables contents when in Modify mode.\nGrams/Second");
MakeNameEx(0x0000806C, "ETAS_KE_ETAS_SLEW_IAC_RPM_MODE", nameFlags);
MakeRptCmt(0x0000806C, "Use this cal when slewing with ETAS to select thedesired mode.\nSlew_Modes");
MakeNameEx(0x0000806E, "ETAS_KE_ETAS_SLEW_IAC_RPM_ABS", nameFlags);
MakeNameEx(0x00008070, "ETAS_KE_ETAS_SLEW_IAC_RPM_MOD", nameFlags);
MakeRptCmt(0x00008070, "This cal is modifiable at runtime when using ETAS instrumentation and is added to a variables contents when in Modify mode.\nRPM");
MakeNameEx(0x00008072, "ETAS_KE_ETAS_SLEW_IAC_POSITION_MODE", nameFlags);
MakeRptCmt(0x00008072, "Use this cal when slewing with ETAS to select thedesired mode.\nSlew_Modes");
MakeNameEx(0x00008074, "ETAS_KE_ETAS_SLEW_IAC_POSITION_ABS", nameFlags);
MakeNameEx(0x00008076, "ETAS_KE_ETAS_SLEW_IAC_POSITION_MOD", nameFlags);
MakeRptCmt(0x00008076, "This cal is modifiable at runtime when using ETAS instrumentation and is added to a variables contents when in Modify mode.\nSteps");
MakeNameEx(0x00008078, "ETAS_KE_ETAS_SLEW_OIL_LEVEL_MODE", nameFlags);
MakeRptCmt(0x00008078, "Use this cal when slewing with ETAS to select thedesired mode.\nSlew_Modes");
MakeNameEx(0x00008079, "ETAS_KE_ETAS_SLEW_OIL_LEVEL_ABS", nameFlags);
MakeNameEx(0x0000807A, "ETAS_KE_ETAS_SLEW_OIL_LEVEL_MOD", nameFlags);
MakeRptCmt(0x0000807A, "This cal is modifiable at runtime when using ETAS instrumentation and is added to a variables contents when in Modify mode.\nBOOLEAN");
MakeNameEx(0x0000807B, "ETAS_KE_ETAS_SLEW_TCC_CONTROL_MODE", nameFlags);
MakeRptCmt(0x0000807B, "Use this cal when slewing with ETAS to select the desired mode.\nSlew_Modes");
MakeNameEx(0x0000807C, "ETAS_KE_ETAS_SLEW_TCC_CONTROL_ABS", nameFlags);
MakeNameEx(0x0000807D, "ETAS_KE_ETAS_SLEW_DES_TORQ_REDUC_MODE", nameFlags);
MakeRptCmt(0x0000807D, "Use this cal when slewing with ETAS to select thedesired mode.\nSlew_Modes");
MakeNameEx(0x0000807E, "ETAS_KE_ETAS_SLEW_DES_TORQ_REDUC_ABS", nameFlags);
MakeNameEx(0x00008080, "ETAS_KE_ETAS_SLEW_FREEZE_ADAPT_MODE", nameFlags);
MakeRptCmt(0x00008080, "Use this cal when slewing with ETAS to select thedesired mode.\nSlew_Modes");
MakeNameEx(0x00008081, "ETAS_KE_ETAS_SLEW_FREEZE_ADAPT_ABS", nameFlags);
MakeNameEx(0x00008082, "ETAS_KE_ETAS_SLEW_PRESSURE_MAN_MODE", nameFlags);
MakeRptCmt(0x00008082, "Use this cal when slewing with ETAS to select thedesired mode.\nSlew_Modes");
MakeNameEx(0x00008084, "ETAS_KE_ETAS_SLEW_PRESSURE_MAN_ABS", nameFlags);
MakeNameEx(0x00008086, "ETAS_KE_ETAS_SLEW_PRESSURE_MAN_MOD", nameFlags);
MakeRptCmt(0x00008086, "This cal is modifiable at runtime when using ETAS instrumentation and is added to a variables contents when in Modify mode.\nPSI");
MakeNameEx(0x00008088, "ETAS_KE_ETAS_SLEW_BASE_PRESSURE_MODE", nameFlags);
MakeRptCmt(0x00008088, "Use this cal when slewing with ETAS to select thedesired mode.\nSlew_Modes");
MakeNameEx(0x0000808A, "ETAS_KE_ETAS_SLEW_BASE_PRESSURE_ABS", nameFlags);
MakeNameEx(0x0000808C, "ETAS_KE_ETAS_SLEW_BASE_PRESSURE_MOD", nameFlags);
MakeRptCmt(0x0000808C, "This cal is modifiable at runtime when using ETAS instrumentation and is added to a variables contents when in Modify mode.\nPSI");
MakeNameEx(0x0000808E, "ETAS_KE_ETAS_SLEW_SHIFT_PRESSURE_MODE", nameFlags);
MakeRptCmt(0x0000808E, "Use this cal when slewing with ETAS to select thedesired mode.\nSlew_Modes");
MakeNameEx(0x00008090, "ETAS_KE_ETAS_SLEW_SHIFT_PRESSURE_ABS", nameFlags);
MakeNameEx(0x00008092, "ETAS_KE_ETAS_SLEW_SHIFT_PRESSURE_MOD", nameFlags);
MakeRptCmt(0x00008092, "This cal is modifiable at runtime when using ETAS instrumentation and is added to a variables contents when in Modify mode.\nPSI");
MakeNameEx(0x00008094, "ETAS_KE_ETAS_SLEW_TCC_APP_2_SLEW_MODE", nameFlags);
MakeRptCmt(0x00008094, "Use this cal when slewing with ETAS to select thedesired mode.\nSlew_Modes");
MakeNameEx(0x00008096, "ETAS_KE_ETAS_SLEW_TCC_APP_2_SLEW_ABS", nameFlags);
MakeNameEx(0x00008098, "ETAS_KE_ETAS_SLEW_TCC_APP_3_SLEW_MODE", nameFlags);
MakeRptCmt(0x00008098, "Use this cal when slewing with ETAS to select thedesired mode.\nSlew_Modes");
MakeNameEx(0x0000809A, "ETAS_KE_ETAS_SLEW_TCC_APP_3_SLEW_ABS", nameFlags);
MakeNameEx(0x0000809C, "ETAS_KE_ETAS_SLEW_TCC_APP_4_SLEW_MODE", nameFlags);
MakeRptCmt(0x0000809C, "Use this cal when slewing with ETAS to select thedesired mode.\nSlew_Modes");
MakeNameEx(0x0000809E, "ETAS_KE_ETAS_SLEW_TCC_APP_4_SLEW_ABS", nameFlags);
MakeNameEx(0x000080A0, "ETAS_KE_ETAS_SLEW_TCC_REL_2_SLEW_MODE", nameFlags);
MakeRptCmt(0x000080A0, "Use this cal when slewing with ETAS to select thedesired mode.\nSlew_Modes");
MakeNameEx(0x000080A2, "ETAS_KE_ETAS_SLEW_TCC_REL_2_SLEW_ABS", nameFlags);
MakeNameEx(0x000080A4, "ETAS_KE_ETAS_SLEW_TCC_REL_3_SLEW_MODE", nameFlags);
MakeRptCmt(0x000080A4, "Use this cal when slewing with ETAS to select thedesired mode.\nSlew_Modes");
MakeNameEx(0x000080A6, "ETAS_KE_ETAS_SLEW_TCC_REL_3_SLEW_ABS", nameFlags);
MakeNameEx(0x000080A8, "ETAS_KE_ETAS_SLEW_TCC_REL_4_SLEW_MODE", nameFlags);
MakeRptCmt(0x000080A8, "Use this cal when slewing with ETAS to select thedesired mode.\nSlew_Modes");
MakeNameEx(0x000080AA, "ETAS_KE_ETAS_SLEW_TCC_REL_4_SLEW_ABS", nameFlags);
MakeNameEx(0x000080AC, "ETAS_KE_ETAS_SLEW_TCC_REL_4_SLEW_MOD", nameFlags);
MakeRptCmt(0x000080AC, "This cal is modifiable at runtime when using ETAS instrumentation and is added to a variables contents when in Modify mode.\nMPH");
MakeNameEx(0x000080AE, "ETAS_KE_ETAS_SLEW_TCC_APP_OP_PT_MODE", nameFlags);
MakeRptCmt(0x000080AE, "Use this cal when slewing with ETAS to select thedesired mode.\nSlew_Modes");
MakeNameEx(0x000080B0, "ETAS_KE_ETAS_SLEW_TCC_APP_OP_PT_ABS", nameFlags);
MakeNameEx(0x000080B2, "ETAS_KE_ETAS_SLEW_TCC_APP_OP_PT_MOD", nameFlags);
MakeRptCmt(0x000080B2, "This cal is modifiable at runtime when using ETAS instrumentation and is added to a variables contents when in Modify mode.\nPSI");
MakeNameEx(0x000080B4, "ETAS_KE_ETAS_SLEW_TCC_APPLY_RATE_MODE", nameFlags);
MakeRptCmt(0x000080B4, "Use this cal when slewing with ETAS to select thedesired mode.\nSlew_Modes");
MakeNameEx(0x000080B6, "ETAS_KE_ETAS_SLEW_TCC_APPLY_RATE_ABS", nameFlags);
MakeNameEx(0x000080B8, "ETAS_KE_ETAS_SLEW_TCC_APPLY_RATE_MOD", nameFlags);
MakeRptCmt(0x000080B8, "This cal is modifiable at runtime when using ETAS instrumentation and is added to a variables contents when in Modify mode.\nPSI/Sec");
MakeNameEx(0x000080BA, "ETAS_KE_ETAS_SLEW_TCC_ON_REF_SLP_MODE", nameFlags);
MakeRptCmt(0x000080BA, "Use this cal when slewing with ETAS to select thedesired mode.\nSlew_Modes");
MakeNameEx(0x000080BC, "ETAS_KE_ETAS_SLEW_TCC_ON_REF_SLP_ABS", nameFlags);
MakeNameEx(0x000080BE, "ETAS_KE_ETAS_SLEW_TCC_ON_REF_SLP_MOD", nameFlags);
MakeRptCmt(0x000080BE, "This cal is modifiable at runtime when using ETAS instrumentation and is added to a variables contents when in Modify mode.\nRPM");
MakeNameEx(0x000080C0, "ETAS_KE_ETAS_SLEW_TCC_REL_TIME_MODE", nameFlags);
MakeRptCmt(0x000080C0, "Use this cal when slewing with ETAS to select thedesired mode.\nSlew_Modes");
MakeNameEx(0x000080C2, "ETAS_KE_ETAS_SLEW_TCC_REL_TIME_ABS", nameFlags);
MakeNameEx(0x000080C4, "ETAS_KE_ETAS_SLEW_TCC_REL_TIME_MOD", nameFlags);
MakeRptCmt(0x000080C4, "This cal is modifiable at runtime when using ETAS instrumentation and is added to a variables contents when in Modify mode.\nSeconds");
MakeNameEx(0x000080C6, "ETAS_KE_ETAS_SLEW_TCC_CAPACITY_MODE", nameFlags);
MakeRptCmt(0x000080C6, "Use this cal when slewing with ETAS to select thedesired mode.\nSlew_Modes");
MakeNameEx(0x000080C8, "ETAS_KE_ETAS_SLEW_TCC_CAPACITY_ABS", nameFlags);
MakeNameEx(0x000080CA, "ETAS_KE_ETAS_SLEW_TCC_CAPACITY_MOD", nameFlags);
MakeRptCmt(0x000080CA, "This cal is modifiable at runtime when using ETAS instrumentation and is added to a variables contents when in Modify mode.\nPercent");
MakeNameEx(0x000080CC, "ETAS_KE_ETAS_SLEW_THR_REL_OP_PT_MODE", nameFlags);
MakeRptCmt(0x000080CC, "Use this cal when slewing with ETAS to select thedesired mode.\nSlew_Modes");
MakeNameEx(0x000080CE, "ETAS_KE_ETAS_SLEW_THR_REL_OP_PT_ABS", nameFlags);
MakeNameEx(0x000080D0, "ETAS_KE_ETAS_SLEW_THR_REL_OP_PT_MOD", nameFlags);
MakeRptCmt(0x000080D0, "This cal is modifiable at runtime when using ETAS instrumentation and is added to a variables contents when in Modify mode.\nCapacity");
MakeNameEx(0x000080D2, "ETAS_KE_ETAS_SLEW_THR_REL_RATE_MODE", nameFlags);
MakeRptCmt(0x000080D2, "Use this cal when slewing with ETAS to select thedesired mode.\nSlew_Modes");
MakeNameEx(0x000080D4, "ETAS_KE_ETAS_SLEW_THR_REL_RATE_ABS", nameFlags);
MakeNameEx(0x000080D6, "ETAS_KE_ETAS_SLEW_THR_REL_RATE_MOD", nameFlags);
MakeRptCmt(0x000080D6, "This cal is modifiable at runtime when using ETAS instrumentation and is added to a variables contents when in Modify mode.\nCapacity/Sec");
MakeNameEx(0x000080D8, "ETAS_KE_ETAS_SLEW_1_2_NORM_LINE_MODE", nameFlags);
MakeRptCmt(0x000080D8, "Use this cal when slewing with ETAS to select thedesired mode.\nSlew_Modes");
MakeNameEx(0x000080DA, "ETAS_KE_ETAS_SLEW_1_2_NORM_LINE_ABS", nameFlags);
MakeNameEx(0x000080DC, "ETAS_KE_ETAS_SLEW_2_3_NORM_LINE_MODE", nameFlags);
MakeRptCmt(0x000080DC, "Use this cal when slewing with ETAS to select thedesired mode.\nSlew_Modes");
MakeNameEx(0x000080DE, "ETAS_KE_ETAS_SLEW_2_3_NORM_LINE_ABS", nameFlags);
MakeNameEx(0x000080E0, "ETAS_KE_ETAS_SLEW_3_4_NORM_LINE_MODE", nameFlags);
MakeRptCmt(0x000080E0, "Use this cal when slewing with ETAS to select thedesired mode.\nSlew_Modes");
MakeNameEx(0x000080E2, "ETAS_KE_ETAS_SLEW_3_4_NORM_LINE_ABS", nameFlags);
MakeNameEx(0x000080E4, "ETAS_KE_ETAS_SLEW_2_1_NORM_LINE_MODE", nameFlags);
MakeRptCmt(0x000080E4, "Use this cal when slewing with ETAS to select thedesired mode.\nSlew_Modes");
MakeNameEx(0x000080E6, "ETAS_KE_ETAS_SLEW_2_1_NORM_LINE_ABS", nameFlags);
MakeNameEx(0x000080E8, "ETAS_KE_ETAS_SLEW_3_2_NORM_LINE_MODE", nameFlags);
MakeRptCmt(0x000080E8, "Use this cal when slewing with ETAS to select thedesired mode.\nSlew_Modes");
MakeNameEx(0x000080EA, "ETAS_KE_ETAS_SLEW_3_2_NORM_LINE_ABS", nameFlags);
MakeNameEx(0x000080EC, "ETAS_KE_ETAS_SLEW_4_3_NORM_LINE_MODE", nameFlags);
MakeRptCmt(0x000080EC, "Use this cal when slewing with ETAS to select thedesired mode.\nSlew_Modes");
MakeNameEx(0x000080EE, "ETAS_KE_ETAS_SLEW_4_3_NORM_LINE_ABS", nameFlags);
MakeNameEx(0x000080F0, "ETAS_KE_ETAS_SLEW_ADAPT_K_FACTOR_MODE", nameFlags);
MakeRptCmt(0x000080F0, "Use this cal when slewing with ETAS to select thedesired mode.\nSlew_Modes");
MakeNameEx(0x000080F2, "ETAS_KE_ETAS_SLEW_ADAPT_K_FACTOR_ABS", nameFlags);
MakeNameEx(0x000080F4, "ETAS_KE_ETAS_SLEW_TCC_ADAP_CELLS_MODE", nameFlags);
MakeRptCmt(0x000080F4, "Use this cal when slewing with ETAS to select thedesired mode.\nSlew_Modes");
MakeNameEx(0x000080F5, "ETAS_KE_ETAS_SLEW_TCC_ADAP_CELLS_ABS", nameFlags);
MakeNameEx(0x000080F6, "ETAS_KE_ETAS_SLEW_ETC_S_S_STAB_MODE", nameFlags);
MakeRptCmt(0x000080F6, "Use this cal when slewing with ETAS to select thedesired mode.\nSlew_Modes");
MakeNameEx(0x000080F7, "ETAS_KE_ETAS_SLEW_ETC_S_S_STAB_ABS", nameFlags);
MakeNameEx(0x000080F8, "ETAS_KE_ETAS_SLEW_TCC_AD_CNF_FCT_MODE", nameFlags);
MakeRptCmt(0x000080F8, "Use this cal when slewing with ETAS to select thedesired mode.\nSlew_Modes");
MakeNameEx(0x000080F9, "ETAS_KE_ETAS_SLEW_TCC_AD_CNF_FCT_ABS", nameFlags);
MakeNameEx(0x000080FA, "ETAS_KE_ETAS_SLEW_ALT_PATTERN_SW_MODE", nameFlags);
MakeRptCmt(0x000080FA, "Use this cal when slewing with ETAS to select thedesired mode.\nSlew_Modes");
MakeNameEx(0x000080FB, "ETAS_KE_ETAS_SLEW_ALT_PATTERN_SW_ABS", nameFlags);
MakeNameEx(0x000080FC, "ETAS_KE_ETAS_SLEW_GEAR_OVERRIDE_MODE", nameFlags);
MakeRptCmt(0x000080FC, "Use this cal when slewing with ETAS to select thedesired mode.\nSlew_Modes");
MakeNameEx(0x000080FD, "ETAS_KE_ETAS_SLEW_GEAR_OVERRIDE_ABS", nameFlags);
MakeNameEx(0x000080FE, "ETAS_KE_ETAS_SLEW_PRELD_ADP_CEL_MODE", nameFlags);
MakeRptCmt(0x000080FE, "Use this cal when slewing with ETAS to select thedesired mode.\nSlew_Modes");
MakeNameEx(0x000080FF, "ETAS_KE_ETAS_SLEW_PRELD_ADP_CEL_ABS", nameFlags);
MakeNameEx(0x00008100, "ETAS_KE_ETAS_SLEW_DUMMY_ABS", nameFlags);
MakeNameEx(0x00008101, "ETAS_KE_ETAS_SLEW_DUMMY_MOD", nameFlags);
MakeNameEx(0x00008102, "ETAS_KE_ETAS_PAD_BYTE_4", nameFlags);
MakeRptCmt(0x00008102, "ETAS Pad Byte is used to place slew cals on the proper byte boundry. Changing it's value does nothing.\nByte");
MakeNameEx(0x00008103, "ETAS_KE_ETAS_PAD_BYTE_5", nameFlags);
MakeRptCmt(0x00008103, "ETAS Pad Byte is used to place slew cals on the proper byte boundry. Changing it's value does nothing.\nByte");
MakeNameEx(0x00008104, "ENG_CONSTANTS_KE_ENGINE_SCHEDULE_RPM_HI", nameFlags);
MakeRptCmt(0x00008104, "The engine speed above which some of the sync. code activation rate is changed.\nRPM");
MakeNameEx(0x00008106, "ENG_CONSTANTS_KE_ENGINE_SCHEDULE_RPM_LO", nameFlags);
MakeRptCmt(0x00008106, "The engine speed below which some of the sync. code activation rate is changed.\nRPM");
MakeNameEx(0x00008108, "ENG_CONSTANTS_KE_ENGINE_IDENTIFIER", nameFlags);
MakeRptCmt(0x00008108, "Describes the type of engine associated with the vehicle including the engine displacement and valve train geometry.\nEngine_Identifier_Type");
MakeNameEx(0x00008109, "ENG_CONSTANTS_KE_NUMBER_CYLINDERS", nameFlags);
MakeRptCmt(0x00008109, "Number of cylinders for this engine application.\nSHORTCARD");
MakeNameEx(0x0000810A, "ENG_CONSTANTS_KE_LOW_RESOLUTION_REFERENCE_ANGL", nameFlags);
MakeRptCmt(0x0000810A, "Identifies the number of degrees from a low resolution pulse to Top Dead Center of the cylinder.\nDegrees");
MakeNameEx(0x0000810C, "ENG_CONSTANTS_KE_TYPE_OF_KNOCK_SENSORS", nameFlags);
MakeRptCmt(0x0000810C, "Identifies whether the engine is equipped with resonant( 0 ) or flat response( 1 ) knock sensors.\nKnock_Sensor_Type");
MakeNameEx(0x0000810D, "ENG_CONSTANTS_KE_AMBIGUOUS_CAM_TRANSITION_LOW", nameFlags);
MakeRptCmt(0x0000810D, "Cam sensor transition low limit based on 24X regions.\n24X Region");
MakeNameEx(0x0000810E, "ENG_CONSTANTS_KE_AMBIGUOUS_CAM_TRANSITION_HIGH", nameFlags);
MakeRptCmt(0x0000810E, "Cam sensor transition high limit based on 24X regions.\n24X Region");
MakeNameEx(0x0000810F, "CRUISE_KE_PERFORM_CRUISE_SEQUENCING", nameFlags);
MakeNameEx(0x00008110, "AIRFLOW_KA_EGR_AIR_FLOW", nameFlags);
MakeRptCmt(0x00008110, "EGR air flow through the EGR valve.\nGrams Per Second");
MakeNameEx(0x000081D6, "AIRFLOW_KE_EGR_AIR_FLOW_FILT_COEF", nameFlags);
MakeRptCmt(0x000081D6, "The calculated EGRflow for Dyna-Air will be filtered using this coefficient.\nNONE 0-1");
MakeNameEx(0x000081D8, "AIRFLOW_KE_EGR_DUTY_CYCLE_DYNAAIR", nameFlags);
MakeRptCmt(0x000081D8, "The commanded EGR duty cycle must be at least this value to enable calculation of EGR air mass.\nPercent");
MakeNameEx(0x000081DA, "AIRFLOW_KE_VE_TEMPERATURE", nameFlags);
MakeNameEx(0x000081DC, "AIRFLOW_KV_VOLUMETRIC_EFFICIENCY_BARO_CO", nameFlags);
MakeNameEx(0x000081F0, "AIRFLOW_KA_VOLUMETRIC_EFFICIENCY_CRANK", nameFlags);
MakeRptCmt(0x000081F0, "Volumetric efficiency at cranking speeds.\nPercent");
MakeNameEx(0x00008442, "AIRFLOW_K_MAIN_VOLUMETRIC_EFFICIENCY", nameFlags);
MakeRptCmt(0x00008442, "The volumetric efficiency term used for modeling the air per cylinder for Dyna-Air calculations.\ngm*K/kPa");
MakeNameEx(0x0000873A, "AIRFLOW_KV_GAMMA_INIT_COOLANT_BREAKPOINT", nameFlags);
MakeRptCmt(0x0000873A, "Breakpoints for selection coolant zone for initializing Filtered_VE_Correction_Factor.\nDeg C");
MakeNameEx(0x0000873E, "AIRFLOW_KA_GAMMA_INIT_TABLE", nameFlags);
MakeRptCmt(0x0000873E, "Initialize Filtered_VE_Correction_Factor to this value.\nNONE 0-2");
MakeNameEx(0x0000875C, "AIRFLOW_K_CYLINDER_VOLUME", nameFlags);
MakeRptCmt(0x0000875C, "Volume of each cylinder in the engine.\nLiter");
MakeNameEx(0x0000875E, "AIRFLOW_KE_BACKUP_AIR_FLOW_FILTER_COEF", nameFlags);
MakeRptCmt(0x0000875E, "Use this to filter air flow sensor reading to generate air flow 'prediction' in response to MAP OR TPS failure.\nNONE 0-1");
MakeNameEx(0x00008760, "AIRFLOW_KE_HI_SPEED_DYNA_AIR_THRESH", nameFlags);
MakeRptCmt(0x00008760, "Engine speed above which a filtered value OF Sensed_Air_Per_Cylinder is used instead of the Dyna-Air prediction.\nRPM");
MakeNameEx(0x00008762, "AIRFLOW_KE_HI_SPEED_DYNA_AIR_HYSTERESIS", nameFlags);
MakeRptCmt(0x00008762, "Amount by which engine speed must drop below KE_Hi_Speed_Dyna_Air_Thresh before the Dyna_Air prediction is used again.\nRPM");
MakeNameEx(0x00008764, "AIRFLOW_KE_USE_CHARGE_TEMPERATURE", nameFlags);
MakeNameEx(0x00008766, "AIRFLOW_K_DYNA_AIR_COEFFICIENT", nameFlags);
MakeRptCmt(0x00008766, "Array of corrective factors used to adjust the predicted volume of air that will get into the cylinder.\nVarious");
MakeNameEx(0x000088CE, "AIRFLOW_K_INITIAL_OPERATING_ZONE", nameFlags);
MakeRptCmt(0x000088CE, "Initial engine operating zone.\nOp. Zone #");
MakeNameEx(0x000088D0, "AIRFLOW_K_WIDE_OPEN_THROTTLE_LO", nameFlags);
MakeRptCmt(0x000088D0, "Minumum throttle percentage that is still considered wide open throttle.\nPercent");
MakeNameEx(0x000088D2, "AIRFLOW_K_IDLE_VEHICLE_SPEED_HI", nameFlags);
MakeRptCmt(0x000088D2, "Maximum vehicle speed that is still considered idle conditions.\nMPH");
MakeNameEx(0x000088D4, "AIRFLOW_K_IDLE_THROTTLE_HI", nameFlags);
MakeRptCmt(0x000088D4, "Maximum throttle percentage that is still considered idle conditions.\nPercent");
MakeNameEx(0x000088D6, "AIRFLOW_K_ENGINE_SPEED_UPPER_BOUND", nameFlags);
MakeRptCmt(0x000088D6, "RPM boundaries between engine speed zones in the operating zones grid.\nRPM");
MakeNameEx(0x000088DC, "AIRFLOW_KE_ENGINE_SPEED_HYSTERESIS", nameFlags);
MakeRptCmt(0x000088DC, "RPM boundary hysteresis for changing engine speed zones.\nRPM");
MakeNameEx(0x000088DE, "AIRFLOW_K_MANIFOLD_PRESSURE_UPPER_BOUND", nameFlags);
MakeRptCmt(0x000088DE, "Pressure boundaries between manifold pressure zones in the operating zones grid.\nkPa");
MakeNameEx(0x000088F6, "AIRFLOW_KE_MANIFOLD_PRESSURE_HYSTERESIS", nameFlags);
MakeRptCmt(0x000088F6, "Pressure boundary hysteresis for changing manifold pressure zones.\nkPa");
MakeNameEx(0x000088F8, "AIRFLOW_K_MAXFLOW_SAFETY_FACTOR", nameFlags);
MakeRptCmt(0x000088F8, "A safety factor multiplied by the calculated maximum air flow limit used on the air flow variables used by the fuel logic.\nNONE 0-2");
MakeNameEx(0x000088FA, "AIRFLOW_K_DEEP_DECEL_MAP_THRESHOLD", nameFlags);
MakeRptCmt(0x000088FA, "MAP threshold below which the engine is considered to be in deep deceleration.\nkPa");
MakeNameEx(0x000088FC, "AIRFLOW_K_MODEL_OF_AIR_FILTER_COEF", nameFlags);
MakeRptCmt(0x000088FC, "Filter coefficient for the Model_Of_Air_Per_Cylinder term.\nNONE 0-1");
MakeNameEx(0x000088FE, "AIRFLOW_K_STEADY_STATE_RPM_THRESHOLD", nameFlags);
MakeRptCmt(0x000088FE, "Steady state enable/disable threshold.  Used to determine if high MAP or low MAP conditions will be used.\nkPa");
MakeNameEx(0x00008900, "AIRFLOW_K_STEADY_STATE_MAP_THRESHOLD", nameFlags);
MakeRptCmt(0x00008900, "Steady state enable/disable threshold.  Used to determine if high MAP or low MAP conditions will be used.\nkPa");
MakeNameEx(0x00008902, "AIRFLOW_K_STEADY_STATE_LOW_MAP_DELTA", nameFlags);
MakeRptCmt(0x00008902, "If low MAP conditions, delta MAP must equal this to enter steady state.\nkPa");
MakeNameEx(0x00008904, "AIRFLOW_K_STEADY_STATE_HIGH_MAP_DELTA", nameFlags);
MakeRptCmt(0x00008904, "Delta MAP criteria for enable/disable of steady state if high MAP conditions.\nkPa");
MakeNameEx(0x00008906, "AIRFLOW_K_STEADY_STATE_LOW_TPS_DELTA", nameFlags);
MakeRptCmt(0x00008906, "Delta TPS for disable of steady state if low MAP conditions.\nPercent");
MakeNameEx(0x00008908, "AIRFLOW_K_STEADY_STATE_HIGH_TPS_DELTA", nameFlags);
MakeRptCmt(0x00008908, "Delta TPS for disable of steady state if high MAP conditions.\nPercent");
MakeNameEx(0x0000890A, "AIRFLOW_KE_IDLE_SS_COUNTER_THRESH", nameFlags);
MakeNameEx(0x0000890C, "AIRFLOW_KE_IDLE_SS_INT_THRESH", nameFlags);
MakeRptCmt(0x0000890C, "Change in MAP integrator required to disable steady state IF engine is currently in the steady state condition.\nkPa");
MakeNameEx(0x0000890E, "AIRFLOW_KE_IDLE_SS_MPH_THRESH", nameFlags);
MakeRptCmt(0x0000890E, "Vehicle must be < this to enable the idle steady STATE detection algorithm.\nMPH");
MakeNameEx(0x00008910, "AIRFLOW_KE_IDLE_SS_TPS_THRESH", nameFlags);
MakeRptCmt(0x00008910, "Throttle position must be < this to enable the idle steady STATE detection algorithm.\nPercent");
MakeNameEx(0x00008912, "AIRFLOW_KE_IDLE_TRANS_COUNTER_THRESH", nameFlags);
MakeNameEx(0x00008914, "AIRFLOW_KE_IDLE_TRANS_INT_THRESH", nameFlags);
MakeRptCmt(0x00008914, "Change in MAP integrator required to disable steady state IF engine is currently NOT in the steady state condition.\nkPa");
MakeNameEx(0x00008916, "AIRFLOW_K_VE_CORR_FACTOR_FILTER_COEF", nameFlags);
MakeRptCmt(0x00008916, "Filter coefficient for Filtered_VE_Correction_Factor.\nFilt Coef");
MakeNameEx(0x00008918, "AIRFLOW_K_VE_CORR_FACTOR_LOW_LIMIT", nameFlags);
MakeRptCmt(0x00008918, "Lower limit of the Filtered_VE_Correction_Factor term.\nNONE 0-2");
MakeNameEx(0x0000891A, "AIRFLOW_K_VE_CORR_FACTOR_HIGH_LIMIT", nameFlags);
MakeRptCmt(0x0000891A, "Upper limit of the Filtered_VE_Correction_Factor term.\nNONE 0-2");
MakeNameEx(0x0000891C, "AIRFLOW_K_USE_MAX_AIR_FIRST_TIME_IN_1", nameFlags);
MakeRptCmt(0x0000891C, "TRUE if Air_Per_Cylinder 1 and 2 ahead are to be set to Maximum_Air_Per_Cylinder when zone 1 is entered.\nBOOLEAN");
MakeNameEx(0x0000891E, "AIRFLOW_K_VE_CORR_FACTOR_RESET_THRESH", nameFlags);
MakeRptCmt(0x0000891E, "Reset Filtered_VE_Correction_Factor to 1.0 if it is less than this calibration when exiting deep deceleration.\nNONE 0-2");
MakeNameEx(0x00008920, "AIRFLOW_KE_EGR_DIAG_FINISHED_TIME", nameFlags);
MakeRptCmt(0x00008920, "Dyna-Air learn is disabled during an intrusive EGR test and for this long after the intrusive EGR test has finished.\nSeconds");
MakeNameEx(0x00008922, "AIRFLOW_KE_CRANK_TO_RUN_RATIO", nameFlags);
MakeNameEx(0x00008924, "AIR_PUMP_KE_AIR_HOT_RESTART_TIME_ON", nameFlags);
MakeNameEx(0x00008926, "AIR_PUMP_KE_MAX_TOTAL_PUMP_TIME_ON", nameFlags);
MakeRptCmt(0x00008926, "AIR system is forced off for the rest of this ignition cycle after being on for a total of this long in this ignition cycle.\nSeconds");
MakeNameEx(0x00008928, "AIR_PUMP_KE_AIR_DELAY_AFTER_START", nameFlags);
MakeRptCmt(0x00008928, "AIR system is not allowed on until engine has run for this long.\nSeconds");
MakeNameEx(0x0000892A, "AIR_PUMP_KE_AIR_ECT_DISABLE", nameFlags);
MakeRptCmt(0x0000892A, "AIR system is not allowed on at this time if coolant temperature is below this.\nDeg C");
MakeNameEx(0x0000892C, "AIR_PUMP_KE_AIR_OVERRUN_DISABLE_THRESHOLD", nameFlags);
MakeRptCmt(0x0000892C, "AIR system is disabled when Manifold Pressure is < this AND remains diabled for KE_AIR_Extended_Overrun_Time thereafter.\nkPa");
MakeNameEx(0x0000892E, "AIR_PUMP_KE_AIR_EXTENDED_OVERRUN_TIME", nameFlags);
MakeNameEx(0x00008930, "AIR_PUMP_KE_AIR_HIGH_RPM_DISABLE_THRESHOL", nameFlags);
MakeRptCmt(0x00008930, "AIR system is disabled when Engine Speed is > this FOR KE_AIR_High_RPM_Time and remains diabled until Engine Speed is <= this.\nRPM");
MakeNameEx(0x00008932, "AIR_PUMP_KE_AIR_HIGH_RPM_TIME", nameFlags);
MakeNameEx(0x00008934, "AIR_PUMP_KE_AIR_HIGH_VSS_DISABLE_THRESHOL", nameFlags);
MakeNameEx(0x00008936, "AIR_PUMP_KE_AIR_HIGH_MAP_DISABLE_THRESHOL", nameFlags);
MakeRptCmt(0x00008936, "\nkPa");
MakeNameEx(0x00008938, "AIR_PUMP_KE_AIR_PUMP_TURN_ON_DELAY", nameFlags);
MakeRptCmt(0x00008938, "Delay turning on AIR pump for this long after turning on AIR solenoid.\nSeconds");
MakeNameEx(0x0000893A, "AIR_PUMP_KE_AIR_PUMP_TURN_OFF_DELAY", nameFlags);
MakeRptCmt(0x0000893A, "Delay turning off AIR pump for this long after turning off AIR solenoid.\nSeconds");
MakeNameEx(0x0000893C, "BAROMETER_KE_BARO_DEFAULT_MAP_FAILED", nameFlags);
MakeRptCmt(0x0000893C, "Default barometric pressure used if MAP sensor fails.\nkPa");
MakeNameEx(0x0000893E, "BAROMETER_KE_BARO_TPS_LIMIT", nameFlags);
MakeRptCmt(0x0000893E, "Minimum throttle position to allow a part throttle barometer update.\nPercent");
MakeNameEx(0x00008940, "BAROMETER_KE_BARO_TPS_DELTA_LIMIT", nameFlags);
MakeRptCmt(0x00008940, "Minimum change in throttle position during last 100 mS to allow a part throttle barometer update.\nPercent");
MakeNameEx(0x00008942, "BAROMETER_KE_BARO_MAP_DELTA_LIMIT", nameFlags);
MakeRptCmt(0x00008942, "Maximum change in manifold pressure during last 100 mS to allow a part throttle barometer update.\nkPa");
MakeNameEx(0x00008944, "BAROMETER_KE_BARO_STABILITY_TIME", nameFlags);
MakeRptCmt(0x00008944, "Minimum time MAP and throttle must be stable to allow a part throttle barometer update.\nSeconds");
MakeNameEx(0x00008946, "BAROMETER_KE_MIN_RPM_FOR_BARO_UPDATE", nameFlags);
MakeRptCmt(0x00008946, "Minimum RPM at which to allow a barometric pressure update.\nRPM");
MakeNameEx(0x00008948, "BAROMETER_KE_MAX_RPM_FOR_BARO_UPDATE", nameFlags);
MakeRptCmt(0x00008948, "Maximum RPM at which to allow a barometric pressure update.\nRPM");
MakeNameEx(0x0000894A, "BAROMETER_KE_MAX_BARO_OFFSET_FOR_UPDATE", nameFlags);
MakeRptCmt(0x0000894A, "Maximum calculated barometric pressure offset to allow baro update.\nkPa");
MakeNameEx(0x0000894C, "BAROMETER_KE_BARO_FILTER_COEFFICIENT", nameFlags);
MakeRptCmt(0x0000894C, "Barometer value update rate lag filter time constant.\nCoefficient");
MakeNameEx(0x0000894E, "BAROMETER_KV_BARO_OFFSET_FACTOR", nameFlags);
MakeRptCmt(0x0000894E, "Scaling factor used to correct the barometer offset value for altitude changes.\nFactor");
MakeNameEx(0x00008960, "BAROMETER_KA_BARO_OFFSET", nameFlags);
MakeRptCmt(0x00008960, "Sea level pressure offset to be added to the part throttle manifold pressure to correct the barometric pressure.\nkPA");
MakeNameEx(0x00008AEC, "BRAKE_TORQUE_CONTROL_KE_TRANSFER_CASE_RATIO", nameFlags);
MakeRptCmt(0x00008AEC, "Transfer case gear ratio in 4WDLO for calibration application.\nScaler_8");
MakeNameEx(0x00008AEE, "BRAKE_TORQUE_CONTROL_KE_DRIVELINE_EFFICIENCY", nameFlags);
MakeRptCmt(0x00008AEE, "Efficiency of transmission and axle gear multiplication for torque transfer.\nScaler_1");
MakeNameEx(0x00008AF0, "BRAKE_TORQUE_CONTROL_KE_TCS_FAIL_TRQ_ALLOWED_FACTOR", nameFlags);
MakeRptCmt(0x00008AF0, "Scale factor applied to the Engine_Torque_Allowed parameterwhen traction control is known to be inactive.\nScaler 0-1");
MakeNameEx(0x00008AF2, "BRAKE_TORQUE_CONTROL_KE_BTM_RPM_OVERSPEED_ENABLE_LO", nameFlags);
MakeRptCmt(0x00008AF2, "Once Brake Torque Management is enabled, engine speed must be at least this amount above desired idle speed to maintain BTM.\nRPM");
MakeNameEx(0x00008AF4, "BRAKE_TORQUE_CONTROL_KE_BTM_RPM_OVERSPEED_ENABLE_HI", nameFlags);
MakeRptCmt(0x00008AF4, "Current engine speed must be at least this amount above desired idle speed to initially enable brake torque management.\nRPM");
MakeNameEx(0x00008AF6, "BRAKE_TORQUE_CONTROL_KE_BTM_TORQUE_HYSTERESIS", nameFlags);
MakeRptCmt(0x00008AF6, "Hysteresis on the torque limit applied to prevent cycling in and out of limiting.\nFoot Pounds");
MakeNameEx(0x00008AF8, "BRAKE_TORQUE_CONTROL_KE_LOOPS_BETWEEN_RAMP_STEPS", nameFlags);
MakeRptCmt(0x00008AF8, "Number of loops to wait between increases in the ramp out.\nCounts");
MakeNameEx(0x00008AFA, "BRAKE_TORQUE_CONTROL_KE_TORQUE_ALLOW_OFFSET", nameFlags);
MakeRptCmt(0x00008AFA, "Torque offset below the maximum that will set the control target.\nFoot Pounds");
MakeNameEx(0x00008AFC, "BRAKE_TORQUE_CONTROL_KE_TORQUE_RAMP", nameFlags);
MakeRptCmt(0x00008AFC, "Step size of torque when ramping out of brake torque management.\nFoot Pounds");
MakeNameEx(0x00008AFE, "BRAKE_TORQUE_CONTROL_KE_BTM_THROTTLE_OPEN", nameFlags);
MakeNameEx(0x00008B00, "BRAKE_TORQUE_CONTROL_KE_BTM_THROTTLE_CLOSED", nameFlags);
MakeNameEx(0x00008B02, "BRAKE_TORQUE_CONTROL_KV_BRAKE_CAPACITY_VACUUM", nameFlags);
MakeRptCmt(0x00008B02, "This defines the maximum torque the vehicle brakes can absorb. It should be entered as an average torque for a single wheel.\nFt_lbs_vs_kPa");
MakeNameEx(0x00008B14, "BRAKE_TORQUE_CONTROL_KV_EFFECTIVE_GEAR_RATIO", nameFlags);
MakeNameEx(0x00008B22, "CONVERTER_KV_COT_INC_TEMPERATURE_FILTER_CO", nameFlags);
MakeRptCmt(0x00008B22, "Filter used to predict current catalytic converter bed temperature when the predicted converter temperature is increasing.\nMultiplier 0-1");
MakeNameEx(0x00008B4C, "CONVERTER_KV_COT_DEC_TEMPERATURE_FILTER_CO", nameFlags);
MakeRptCmt(0x00008B4C, "Filter used to predict current catalytic converter bed temperature when the predicted converter temperature is decreasing.\nMultiplier 0-1");
MakeNameEx(0x00008B76, "CONVERTER_KV_COT_DFCO_TEMPERATURE_OFFSET", nameFlags);
MakeNameEx(0x00008B88, "CONVERTER_KV_COT_EQ_RATIO_TEMP_OFFSET", nameFlags);
MakeNameEx(0x00008BAA, "CONVERTER_KV_COT_FFS_MULTIPLIER", nameFlags);
MakeRptCmt(0x00008BAA, "Multiplier to compensate the stabilized temperature for any fuel composition effects on exhaust temperatures\nScaler 1");
MakeNameEx(0x00008BB4, "CONVERTER_KV_COT_INITIAL_TEMP_SOAK_MULT", nameFlags);
MakeRptCmt(0x00008BB4, "soak timer modifier for Converter temperature prediction\nScaler_2");
MakeNameEx(0x00008BC2, "CONVERTER_KV_COT_RETARDED_SPARK_OFFSET", nameFlags);
MakeNameEx(0x00008BD8, "CONVERTER_KV_COT_VEH_SPEED_TEMP_OFFSET", nameFlags);
MakeRptCmt(0x00008BD8, "A prediction of the difference in stabilized catalytic converterbed temperature relative to the speed of the vehicle.\nDegrees_C");
MakeNameEx(0x00008BEA, "CONVERTER_KE_COT_TEMPERATURE_COOL_THRESHOL", nameFlags);
MakeNameEx(0x00008BEC, "CONVERTER_KE_COT_TEMPERATURE_INITIAL", nameFlags);
MakeRptCmt(0x00008BEC, "If the coolant temperature is larger than this calibration, thenthe converter temperature is initialized to this calibration.\nDegrees_C_S");
MakeNameEx(0x00008BEE, "CONVERTER_KA_COT_TEMPERATURE_STOICH_STABLE", nameFlags);
MakeRptCmt(0x00008BEE, "A prediction of the stabilized catalytic converter bed .temperature based on air-fuel ratio.\nDegrees_C");
MakeNameEx(0x00008E64, "CONVERTER_KE_COT_THROTTLE_OPENED", nameFlags);
MakeRptCmt(0x00008E64, "Throttle position >= this allows immediate update OF catalytic converter temperature.\nPercent");
MakeNameEx(0x00008E66, "CONVERTER_KE_COT_THROTTLE_CLOSED", nameFlags);
MakeRptCmt(0x00008E66, "Throttle position <= this causes airflow to determine timing of catalytic converter temperature update.\nPercent");
MakeNameEx(0x00008E68, "CONVERTER_KE_COT_AIRFLOW_DELTA", nameFlags);
MakeRptCmt(0x00008E68, "Airflow dropping >= this IN one seconds causes delay OF catalytic converter temperature update.\ngm/S");
MakeNameEx(0x00008E6A, "CONVERTER_KE_COT_TEMPERATURE_DELAY_TIME", nameFlags);
MakeRptCmt(0x00008E6A, "Overrun causes delay of this length in catalytic converter temperature update.\nSeconds");
MakeNameEx(0x00008E6C, "CONVERTER_KE_COT_EQ_RATIO_DEC_FILTER_LIMIT", nameFlags);
MakeNameEx(0x00008E6E, "CONVERTER_KE_COT_DEC_TEMP_FILTER_RICH_RATE", nameFlags);
MakeNameEx(0x00008E70, "CONVERTER_KE_COT_HOT_DETERMINATION_ENABLE", nameFlags);
MakeRptCmt(0x00008E70, "COT hot determination is activated IFF this is TRUE.\nBOOLEAN");
MakeNameEx(0x00008E72, "CONVERTER_KE_COT_HOT_TIME_THRESHOLD", nameFlags);
MakeRptCmt(0x00008E72, "If the catalytic converter temperature is above KE_COT_Temperature_High for this time, then the converter is too high.\nSeconds");
MakeNameEx(0x00008E74, "CONVERTER_KE_COT_1PERCENT_TIME_THRESHOLD", nameFlags);
MakeNameEx(0x00008E76, "CONVERTER_KE_COT_1PERCENT_CYCLE_TIME", nameFlags);
MakeNameEx(0x00008E7A, "CONVERTER_KE_COT_TEMPERATURE_LOW", nameFlags);
MakeRptCmt(0x00008E7A, "The lowest catalytic converter temperature protection threshold.\nDegrees_C_S");
MakeNameEx(0x00008E7C, "CONVERTER_KE_COT_TEMPERATURE_MEDIUM", nameFlags);
MakeRptCmt(0x00008E7C, "The second catalytic converter temperature protection threshold.\nDegrees_C_S");
MakeNameEx(0x00008E7E, "CONVERTER_KE_COT_TEMPERATURE_HIGH", nameFlags);
MakeRptCmt(0x00008E7E, "The third catalytic converter temperature protection threshold.\nDegrees_C_S");
MakeNameEx(0x00008E80, "CONVERTER_KE_COT_TEMPERATURE_EXTREME", nameFlags);
MakeRptCmt(0x00008E80, "The Highest catalytic converter temperature protection threshold.\nDegrees_C_S");
MakeNameEx(0x00008E82, "CONVERTER_KE_COT_MIN_EQ_ALLOWED", nameFlags);
MakeRptCmt(0x00008E82, "Minimum amount of fueling that COT will try to deliver. Have this minimum help to get back to closed loop fuel sooner.\nEquiv_Ratio_Type");
MakeNameEx(0x00008E84, "CONVERTER_KE_COT_MAX_EQ_ALLOWED", nameFlags);
MakeRptCmt(0x00008E84, "Maximum amount of authority the COT EQ offset can have.\nEquiv_Ratio_Type");
MakeNameEx(0x00008E86, "CONVERTER_KV_COT_BARO_MULTIPLIER", nameFlags);
MakeNameEx(0x00008E90, "CONVERTER_KV_COT_INC_COEF_TEMP_DELTA_MULT", nameFlags);
MakeRptCmt(0x00008E90, "Multiplier on the COT increasing filter coeff based on delta between COT stabilized and 1 second old converter temperature.\nMult_0_to_1");
MakeNameEx(0x00008E9C, "CONVERTER_KV_COT_EQ_RATIO_OFFSET", nameFlags);
MakeRptCmt(0x00008E9C, "???.\nEquiv_Ratio_Type");
MakeNameEx(0x00008EBC, "CCP_KE_CCP_COOLANT_TEMPERATURE", nameFlags);
MakeRptCmt(0x00008EBC, "Coolant Temperature threshold above which purge may beenabled\nDegrees_C");
MakeNameEx(0x00008EBE, "CCP_KE_CCP_VEHICLE_SPEED_FILTERED", nameFlags);
MakeRptCmt(0x00008EBE, "Vehicle Speed threshold above which purge may be enabled\nMPH");
MakeNameEx(0x00008EC0, "CCP_KE_CCP_MASS_AIRFLOW", nameFlags);
MakeRptCmt(0x00008EC0, "Mass Airflow threshold above which purge may be enabled\nGrams Per Second");
MakeNameEx(0x00008EC2, "CCP_KE_CCP_ENGINE_RUN_TIME", nameFlags);
MakeRptCmt(0x00008EC2, "Continuous Engine Run Time threshold above whichPurge may be enabled\nSeconds");
MakeNameEx(0x00008EC6, "CCP_KE_COOLANT_TEMPERATURE_STARTRUN", nameFlags);
MakeRptCmt(0x00008EC6, "Coolant Threshold for determining purge enable delay startfrom closed loop entry.\nDegrees_C");
MakeNameEx(0x00008EC8, "CCP_KE_COLD_START_CLOSED_LOOP_TIME", nameFlags);
MakeRptCmt(0x00008EC8, "Purge Enable Delay after going closed loop if a coldstart occurred.\nSeconds");
MakeNameEx(0x00008ECA, "CCP_KE_WARM_START_CLOSED_LOOP_TIME", nameFlags);
MakeRptCmt(0x00008ECA, "Purge Enable Delay after closed loop if a warm start occurred.\nSeconds");
MakeNameEx(0x00008ECC, "CCP_KE_CCP_COOLANT_STARTRUN", nameFlags);
MakeRptCmt(0x00008ECC, "Coolant Threshold for determining purge enable delay from closed loop or open loop fuel control if selected.\nDegrees_C");
MakeNameEx(0x00008ECE, "CCP_KE_CCP_COLD_OPEN_LOOP_TIME", nameFlags);
MakeRptCmt(0x00008ECE, "Purge Enable Delay after engine run if a cold startoccurred.\nSeconds");
MakeNameEx(0x00008ED0, "CCP_KE_CCP_WARM_OPEN_LOOP_TIME", nameFlags);
MakeRptCmt(0x00008ED0, "Purge Enable Delay after engine run if a warm startoccurred.\nSeconds");
MakeNameEx(0x00008ED2, "CCP_KE_CCP_OPEN_LOOP_PURGE_ENABLE", nameFlags);
MakeRptCmt(0x00008ED2, "Bit selectable flag for purging when fuel control is in openloop. To be used primarily for exports without oxygensensors.\nBOOLEAN");
MakeNameEx(0x00008ED3, "CCP_KE_CYLINDERS_ENABLED_ALLOW_CCP", nameFlags);
MakeRptCmt(0x00008ED3, "Number of cylinders that must be enabled to allowCanister Purge.\n");
MakeNameEx(0x00008ED4, "CCP_KE_CANISTER_PURGE_OXYGEN_INITIAL", nameFlags);
MakeRptCmt(0x00008ED4, "Initial Value of Oxygen Multiplier\nUnitless");
MakeNameEx(0x00008ED6, "CCP_KV_CANISTER_OXYGEN_VOLTAGE_HIGH", nameFlags);
MakeRptCmt(0x00008ED6, "High Oxygen Sensor Voltage threshold used to set the direction of Oxygen Purge Adjustment to decrease and the rate of learning.\nMilliVolts");
MakeNameEx(0x00008EDA, "CCP_KE_CCP_MIN_OXYGEN_ADJUST", nameFlags);
MakeRptCmt(0x00008EDA, "Minimum allowable value of the Canister_Purge_Oxygen_Adjustmultiplier.\nUnitless");
MakeNameEx(0x00008EDC, "CCP_KE_CCP_OPEN_LOOP_OXYGEN_ADJUST", nameFlags);
MakeRptCmt(0x00008EDC, "Default value of the Canister_Purge_Oxygen_Adjust factor whenpurge is being performed in open loop fuel control.\nUnitless 0-2");
MakeNameEx(0x00008EDE, "CCP_KE_CCP_SHORT_DELAY_RATE", nameFlags);
MakeRptCmt(0x00008EDE, "Short delay time between multiplier learns if oxygen voltage is high for a calibrated amount of time.\nSeconds");
MakeNameEx(0x00008EE0, "CCP_KE_CCP_LEARN_RATE_NORMAL", nameFlags);
MakeRptCmt(0x00008EE0, "Time delay between oxygen multiplier learns if the multiplier is increasing.\nSeconds");
MakeNameEx(0x00008EE2, "CCP_KE_CCP_LEARN_RATE_MULTIPLIER", nameFlags);
MakeNameEx(0x00008EE4, "CCP_KV_CANISTER_OXYGEN_VOLTAGE_LOW", nameFlags);
MakeRptCmt(0x00008EE4, "Low Oxygen voltage threshold that is used to determinethe direction of the oxygen multiplier.\nMillivolts");
MakeNameEx(0x00008EE8, "CCP_KA_CCP_OXYGEN_ADJUST_SIZE", nameFlags);
MakeRptCmt(0x00008EE8, "Step size for oxygen multiplier when the oxygen voltagehas not been high for a calibrated amount of time.\nUnitless");
MakeNameEx(0x00008EF0, "CCP_KV_CCP_OXYGEN_ADJUST_TIMED_SIZE", nameFlags);
MakeRptCmt(0x00008EF0, "Step size for oxygen multiplier when the oxygen voltagehas been high for a calibrated amount of time.\nUnitless");
MakeNameEx(0x00008EF4, "CCP_KE_CCP_CHOOSE_OXYGEN_DATA", nameFlags);
MakeRptCmt(0x00008EF4, "Choose what oxygen data to be used if no oxygen faultsare present.\nUnitless");
MakeNameEx(0x00008EF6, "CCP_KE_CCP_MAX_FLOW", nameFlags);
MakeRptCmt(0x00008EF6, "Largest value in the KV_CCP_Max_Allowed_Purge_Flow table i.e. the maximum allowed purge flow at any manifold vacuum\nGPS");
MakeNameEx(0x00008EF8, "CCP_KE_CCP_PRESSURE_HIGH", nameFlags);
MakeRptCmt(0x00008EF8, "Manifold pressure upper threshold for enabling purge onceit has been disabled.\nkPa");
MakeNameEx(0x00008EFA, "CCP_KE_CCP_PRESSURE_LOW", nameFlags);
MakeRptCmt(0x00008EFA, "Manifold pressure lower threshold for disabling purge onceit has been enabled.\nkPa");
MakeNameEx(0x00008EFC, "CCP_KE_CCP_VACUUM_HIGH", nameFlags);
MakeRptCmt(0x00008EFC, "Manifold vacuum upper threshold for enabling purge onceit has been disabled.\nkPa");
MakeNameEx(0x00008EFE, "CCP_KE_CCP_VACUUM_LOW", nameFlags);
MakeRptCmt(0x00008EFE, "Manifold vacuum lower threshold for disabling purge onceit has been enabled.\nkPa");
MakeNameEx(0x00008F00, "CCP_KV_CCP_OXYGEN_VOLTAGE_HIGH_TIME", nameFlags);
MakeRptCmt(0x00008F00, "Time of which the oxygen voltage must remain high to use a short delay rate for multiplier learning\nSeconds");
MakeNameEx(0x00008F22, "CCP_KV_CCP_MAX_ALLOWED_PURGE_FLOW", nameFlags);
MakeRptCmt(0x00008F22, "Maximum allowed purge flow value as a function ofmanifold vacuum.\nGPS");
MakeNameEx(0x00008F44, "CCP_KV_CCP_BASE_DESIRED_PURGE_FLOW", nameFlags);
MakeRptCmt(0x00008F44, "Determines the canister purge desired base flow\nGPS");
MakeNameEx(0x00008F86, "CCP_KA_CCP_MAX_OXYGEN_ADJUST", nameFlags);
MakeRptCmt(0x00008F86, "Maximum allowed value for oxygen multiplier\nUnitless");
MakeNameEx(0x00008FD2, "CCP_KE_CCP_OPEN_LOOP_BLM_ADJUST", nameFlags);
MakeRptCmt(0x00008FD2, "Default value of the BLM adjust factor whenpurge is being performed in open loop fuel control.\nUnitless 0-2");
MakeNameEx(0x00008FD4, "CCP_KE_CCP_MAX_BLM_SENSOR_ADJUST", nameFlags);
MakeRptCmt(0x00008FD4, "Minimum allowed BLM multiplier for canister purge.\nUnitless");
MakeNameEx(0x00008FD6, "CCP_KE_CCP_MIN_BLM_SENSOR_ADJUST", nameFlags);
MakeRptCmt(0x00008FD6, "\nUnitless");
MakeNameEx(0x00008FD8, "CCP_KV_CANISTER_BLM_HIGH_THRESHOLD", nameFlags);
MakeRptCmt(0x00008FD8, "BLM Threshold that must be exceeded to have BLMMultiplier to increase.\nUnitless");
MakeNameEx(0x00008FDC, "CCP_KE_CCP_INITIAL_BLM_ADJUST", nameFlags);
MakeRptCmt(0x00008FDC, "BLM purge learn multiplier initial value at powerup andstartrun.\nUnitless");
MakeNameEx(0x00008FDE, "CCP_KV_CANISTER_BLM_LOW_THRESHOLD", nameFlags);
MakeRptCmt(0x00008FDE, "BLM must be below this threshold to have BLMMultiplier to decrease.\nUnitless");
MakeNameEx(0x00008FE2, "CCP_KV_CCP_BLM_ADJUST_SIZE", nameFlags);
MakeRptCmt(0x00008FE2, "BLM Purge Learn Multiplier step size\nUnitless");
MakeNameEx(0x00008FE6, "CCP_KE_CANISTER_PURGE_CHOOSE_BLM", nameFlags);
MakeRptCmt(0x00008FE6, "Choose what BLM data is to be used if no closed loopresets are present.\nUnitless");
MakeNameEx(0x00008FE8, "CCP_KE_BLM_INITIAL_VALUE", nameFlags);
MakeRptCmt(0x00008FE8, "Value the BLM data will assume when Closed Loopreset for both banks occur\nScaler_2");
MakeNameEx(0x00008FEA, "CCP_KE_CCP_PE_MULTIPLIER", nameFlags);
MakeRptCmt(0x00008FEA, "Power enrichment multiplier for CCP total adjust.\nUnitless 0-1");
MakeNameEx(0x00008FEC, "CCP_KE_CCP_COT_MULTIPLIER", nameFlags);
MakeRptCmt(0x00008FEC, "Converter Too Hot multiplier for CCP total adjust.\nUnitless 0-1");
MakeNameEx(0x00008FEE, "CCP_KE_HRP_HOLD_ACTIVE_TIME", nameFlags);
MakeRptCmt(0x00008FEE, "Amount of time HRP is held active before decay to zero.\nSeconds");
MakeNameEx(0x00008FF0, "CCP_KE_HRP_EXIT_DECAY_TIME", nameFlags);
MakeRptCmt(0x00008FF0, "HRP is decayed to zero in this amount of time.\nSeconds");
MakeNameEx(0x00008FF2, "CCP_KV_CCP_BASE_FLOW_OFF_IDLE_MAF", nameFlags);
MakeRptCmt(0x00008FF2, "This is the calibrated Base Flow Off Idle based on Mass Airflow\nGPS");
MakeNameEx(0x00009034, "CCP_KV_CCP_BASE_FLOW_IDLE_MAF", nameFlags);
MakeRptCmt(0x00009034, "Calibrated Base Flow Idle based on Mass Airflow\nGPS");
MakeNameEx(0x0000904A, "CCP_KV_CANISTER_PURGE_DUTY_CYCLE", nameFlags);
MakeRptCmt(0x0000904A, "Establishes the nonignition voltage limited canister purge duty cycle.\nPercent");
MakeNameEx(0x00009146, "CCP_KE_CCP_DUTY_CYCLE_CHANGE_LIMIT", nameFlags);
MakeRptCmt(0x00009146, "Maximum delta the purge solenoid duty cycle can change eachloop by. If change exceeds this limit, the new value isfiltered in.\nPercent");
MakeNameEx(0x00009148, "CCP_KE_CCP_VEHICLE_SPEED_THRESHOLD", nameFlags);
MakeRptCmt(0x00009148, "Speed at which the CCP filter coefficient decides to use thehigh speed coefficient table or the low speed coefficienttable.\nMPH");
MakeNameEx(0x0000914A, "CCP_KV_CCP_LOW_SPEED_CCP_CLOSING_COE", nameFlags);
MakeRptCmt(0x0000914A, "Filter coefficient based on a low vehicle speed and massairflow Calibration.\nCoeff.");
MakeNameEx(0x0000915C, "CCP_KV_CCP_HIGH_SPEED_CCP_CLOSING_CO", nameFlags);
MakeRptCmt(0x0000915C, "Filter coefficient based on a high vehicle speed and massairflow Calibration.\nCoeff.");
MakeNameEx(0x0000916E, "CCP_KV_CCP_LOW_SPEED_CCP_OPENING_COE", nameFlags);
MakeRptCmt(0x0000916E, "Filter coefficient based on a low vehicle speed and massairflow Calibration.\nCoeff.");
MakeNameEx(0x00009180, "CCP_KV_CCP_HIGH_SPEED_CCP_OPENING_CO", nameFlags);
MakeRptCmt(0x00009180, "Filter coefficient based on a high vehicle speed and massairflow Calibration.\nCoeff.");
MakeNameEx(0x00009192, "CCP_KV_CCP_DUTY_CYCLE_MINIMUM", nameFlags);
MakeRptCmt(0x00009192, "Minimum allowed canister purge duty cycle.\nPercent");
MakeNameEx(0x000091B0, "CCP_KV_CCP_VACUUM_MULTIPLIER", nameFlags);
MakeRptCmt(0x000091B0, "Canister Purge compensation for Manifold Vacuum.\nUnitless");
MakeNameEx(0x000091DC, "CCP_KE_VENT_VALVE_STRIKE_CYCLE_PERIO", nameFlags);
MakeRptCmt(0x000091DC, "Period for each extra close-open cycle of vent valve on open-to-closed transitions.\nSeconds");
MakeNameEx(0x000091DE, "CCP_KE_VENT_VALVE_STRIKE_CYCLE_LIMIT", nameFlags);
MakeRptCmt(0x000091DE, "Number of extra close-open cycles of vent valve on open-to-closed transitions.\nUnitless");
MakeNameEx(0x000091E0, "CCP_KE_CCP_TPS_LOW_FOR_IDLE", nameFlags);
MakeRptCmt(0x000091E0, "Lower threshold of throttle position to disable purge.\nPercent");
MakeNameEx(0x000091E2, "CCP_KE_CCP_TPS_HIGH_FOR_IDLE", nameFlags);
MakeRptCmt(0x000091E2, "Upper threshold of throttle position to re-enable purge.\nPercent");
MakeNameEx(0x000091E4, "CCP_KV_PURGE_VEHICLE_SPEED_HYST_HIGH", nameFlags);
MakeRptCmt(0x000091E4, "Upper threshold of vehicle speed which will re-enable purge.\nMPH");
MakeNameEx(0x000091E8, "CCP_KV_PURGE_VEHICLE_SPEED_HYST_LOW", nameFlags);
MakeRptCmt(0x000091E8, "Lower threshold of vehicle speed which will disable purge.\nMPH");
MakeNameEx(0x000091EC, "CCP_KE_IDLE_PURGE_PWRUP_IAT_THRESH", nameFlags);
MakeRptCmt(0x000091EC, "Induction air temperature threshold above which is deemed warm enough to not delay idle purge at all.\nDegrees_C");
MakeNameEx(0x000091EE, "CCP_KE_IDLE_PURGE_PWRUP_COOL_THRESH", nameFlags);
MakeNameEx(0x000091F0, "CCP_KE_IDLE_PURGE_WARM_DELAY_TIME", nameFlags);
MakeRptCmt(0x000091F0, "Calibration time to delay purging if delay is desired and conditions are relatively warm.\nSeconds_L");
MakeNameEx(0x000091F4, "CCP_KV_IDLE_PURGE_COLD_DELAY_TIME", nameFlags);
MakeRptCmt(0x000091F4, "Calibration time to delay purging if delay is desiredand conditions are relatively cold.\nSeconds_L");
MakeNameEx(0x00009234, "CCP_KE_HRP_MIN_SOAK_TIMER_TO_ENABLE", nameFlags);
MakeRptCmt(0x00009234, "Disable hot restart purge mode if engine has not soaked for atleast this amount of time.\nSeconds_L");
MakeNameEx(0x00009238, "CCP_KE_HRP_MAX_SOAK_TIMER_TO_DISABLE", nameFlags);
MakeRptCmt(0x00009238, "Disable hot restart purge mode if engine has soaked for more than this time.\nSeconds_L");
MakeNameEx(0x0000923C, "CCP_KE_HRP_MIN_PERCENTAGE_ETHANOL", nameFlags);
MakeNameEx(0x0000923E, "CCP_KE_HRP_ENGINE_OIL_TEMPERATURE", nameFlags);
MakeRptCmt(0x0000923E, "Enable hot restart purge mode if estimated oil temperature is greater than this value + other conditions must be satisfied.\nDegrees_C");
MakeNameEx(0x00009240, "CCP_KE_HRP_COOLANT_TEMPERATURE", nameFlags);
MakeRptCmt(0x00009240, "Enable hot restart purge mode if coolant temperature is greater than this value + other conditions must be satisfied.\nDegrees_C");
MakeNameEx(0x00009242, "CCP_KE_HRP_INDUCTION_AIR_TEMPERATURE", nameFlags);
MakeRptCmt(0x00009242, "Enable hot restart purge mode if induction air temperature is greater than this value + other conditions must be satisfied.\nDegrees_C");
MakeNameEx(0x00009244, "CCP_KE_HRP_BLM_ADJUST_LIMIT", nameFlags);
MakeRptCmt(0x00009244, "Enable hot restart purge mode if canister purge BLM adjust is <= this value + other conditions must be satisfied.\nScaler 0-2");
MakeNameEx(0x00009246, "CCP_KE_HRP_PLM_LIMIT", nameFlags);
MakeRptCmt(0x00009246, "Enable hot restart purge mode if either Purge Learn Multiplier (Bank1/2) is <= this value + other conditions must be satisfied.\nScaler 0-2");
MakeNameEx(0x00009248, "CCP_KE_HRP_IDLE_BLM_LIMIT", nameFlags);
MakeNameEx(0x0000924A, "CCP_KA_HRP_PURGE_FLOW", nameFlags);
MakeRptCmt(0x0000924A, "IMPORTANT: Remember to ramp out. Purge flow based on engine run time and vacuum when hot restart purge mode is active.\nGram_Per_Second");
MakeNameEx(0x00009292, "CCP_KE_CCP_MODE_TPS_LOW", nameFlags);
MakeRptCmt(0x00009292, "Lower threshold of throttle position hysteresis for CCP Mode.\nPercent");
MakeNameEx(0x00009294, "CCP_KE_CCP_MODE_TPS_HIGH", nameFlags);
MakeRptCmt(0x00009294, "Upper threshold of throttle position hysteresis for CCP Mode.\nPercent");
MakeNameEx(0x00009296, "CCP_KE_CCP_MODE_VSS_LOW", nameFlags);
MakeRptCmt(0x00009296, "Lower threshold of vehicle speed hysteresis for CCP Mode.\nMPH");
MakeNameEx(0x00009298, "CCP_KE_CCP_MODE_VSS_HIGH", nameFlags);
MakeRptCmt(0x00009298, "Upper threshold of vehicle speed hysteresis for CCP Mode.\nMPH");
MakeNameEx(0x0000929A, "CCP_KE_CCP_REDUCTION_INTEGRAL", nameFlags);
MakeRptCmt(0x0000929A, "Volume of purge flow which must accumulate before flow reduction can start\nGrams");
MakeNameEx(0x0000929E, "CCP_KE_CCP_BLM_REDUCTION_DELTA", nameFlags);
MakeRptCmt(0x0000929E, "Delta limit allowed between purge and non-purge fuel control cells.\nScaler_2");
MakeNameEx(0x000092A0, "CCP_KE_CCP_FLOW_REDUCTION_HYST_TIME", nameFlags);
MakeRptCmt(0x000092A0, "Hysteresis time for flow reduction mode.\nSeconds");
MakeNameEx(0x000092A2, "CCP_KE_CCP_REDUCTION_LIMIT", nameFlags);
MakeRptCmt(0x000092A2, "Maximum allowed canister purge duty cycle during purge reduction.\nPercent");
MakeNameEx(0x000092A4, "CRUIS_CONTROL_KE_LOW_SPEED_INHIBIT", nameFlags);
MakeRptCmt(0x000092A4, "Filtered vehicle speed below which transitional cruisemodes can not be established\nMPH");
MakeNameEx(0x000092A6, "CRUIS_CONTROL_KE_HIGH_SPEED_INHIBIT", nameFlags);
MakeRptCmt(0x000092A6, "Filtered vehicle speed above which transitional cruisemodes can not be established\nMPH");
MakeNameEx(0x000092A8, "CRUIS_CONTROL_KE_CRUISE_INTEGRATOR_HIGH", nameFlags);
MakeRptCmt(0x000092A8, "Integrator maximum value while cruise is engaged\nMPH");
MakeNameEx(0x000092AA, "CRUIS_CONTROL_KE_CRUISE_INTEGRATOR_LOW", nameFlags);
MakeRptCmt(0x000092AA, "Integrator minimum value while cruise is engaged\nMPH");
MakeNameEx(0x000092AC, "CRUIS_CONTROL_KE_CRUISE_POWER_LIMIT", nameFlags);
MakeRptCmt(0x000092AC, "Maximum desired power that cruise can request\nPercent");
MakeNameEx(0x000092AE, "CRUIS_CONTROL_KE_HYSTERESIS", nameFlags);
MakeRptCmt(0x000092AE, "Hysteresis constant\nMPH");
MakeNameEx(0x000092B0, "CRUIS_CONTROL_KE_CRUISE_INTEGRATOR_GAIN", nameFlags);
MakeRptCmt(0x000092B0, "Integrator gain when not in Resume or Accel modes.\nScaler 0-1");
MakeNameEx(0x000092B2, "CRUIS_CONTROL_KE_SCHEDULED_ACCEL_GAIN_OVER", nameFlags);
MakeRptCmt(0x000092B2, "Overspeed scheduled acceleration rate gain\nMPH_PER_SECOND");
MakeNameEx(0x000092B4, "CRUIS_CONTROL_KE_SCHEDULED_ACCEL_GAIN_UNDER", nameFlags);
MakeRptCmt(0x000092B4, "Underspeed scheduled acceleration rate gain\nMPH_PER_SECOND");
MakeNameEx(0x000092B6, "CRUIS_CONTROL_KE_LOCKUP_CLAMP_HIGH", nameFlags);
MakeRptCmt(0x000092B6, "The high limit that the Lockup_Integrator is clamped to\nMPH");
MakeNameEx(0x000092B8, "CRUIS_CONTROL_KE_LOCKUP_CLAMP_LOW", nameFlags);
MakeRptCmt(0x000092B8, "The low limit that the Lockup_Integrator is clamped to\nMPH");
MakeNameEx(0x000092BA, "CRUIS_CONTROL_KE_LOCKUP_INT_FILTER", nameFlags);
MakeRptCmt(0x000092BA, "Filter coefficient for the lockup integrator for the cruisecontrol algorithm\nSeconds");
MakeNameEx(0x000092BC, "CRUIS_CONTROL_KE_LOCKUP_POWER_LIMIT", nameFlags);
MakeRptCmt(0x000092BC, "The percentage of desired power above which theLockup_Integrator should not be updated.\nPercent");
MakeNameEx(0x000092BE, "CRUIS_CONTROL_KE_CRUISE_VEH_SPEED_DELTA_HIGH", nameFlags);
MakeRptCmt(0x000092BE, "Acceleration error minimum value and maximum integratordecrement per 100ms\nMPH per 100ms");
MakeNameEx(0x000092C0, "CRUIS_CONTROL_KE_CRUISE_VEH_SPEED_DELTA_LOW", nameFlags);
MakeRptCmt(0x000092C0, "Acceleration error maximum value and maximum integratorincrement per 100ms\nMPH per 100ms");
MakeNameEx(0x000092C2, "CRUIS_CONTROL_KE_CRUISE_GEAR_COMP_OFFSET", nameFlags);
MakeRptCmt(0x000092C2, "DC offset to gear compensation term for cruise control\nMPH");
MakeNameEx(0x000092C4, "CRUIS_CONTROL_KE_CRUISE_GEAR_RAMP_IN", nameFlags);
MakeRptCmt(0x000092C4, "Length of time over which the gear compensation termfor cruise control will be ramped in.\nSeconds");
MakeNameEx(0x000092C6, "CRUIS_CONTROL_KE_CRUISE_GEAR_RAMP_OUT", nameFlags);
MakeNameEx(0x000092C8, "CRUIS_CONTROL_KE_CRUISE_GEAR_COMPENSATION", nameFlags);
MakeRptCmt(0x000092C8, "Gear to be compensated for, in the cruise control algorithm- normally highest gear in a manual vehicle.\nGear 1st to 6th");
MakeNameEx(0x000092CA, "CRUIS_CONTROL_KV_CRUISE_BARO_COMPENSATION", nameFlags);
MakeRptCmt(0x000092CA, "Adjusts the cruise desired power to compensate for ambientpressure.\nScaler");
MakeNameEx(0x000092D4, "CRUIS_CONTROL_KV_GAIN_TABLE", nameFlags);
MakeRptCmt(0x000092D4, "Effective Speed Error vs Cruise Desired Power, Gain Table 0\nPercent");
MakeNameEx(0x000092FC, "CRUIS_CONTROL_KV_HIGH_DECEL_RATE", nameFlags);
MakeRptCmt(0x000092FC, "The deceleration rate below which a cruise disengagewill be performed\nMPH_PER_SECOND_S");
MakeNameEx(0x00009314, "CRUIS_CONTROL_KV_HIGH_ACCEL_RATE", nameFlags);
MakeRptCmt(0x00009314, "The accel rate above which a cruise disengagewill be performed\nMPH_PER_SECOND");
MakeNameEx(0x0000932C, "CRUIS_CONTROL_KV_UNDER_SCHEDULE_DISENGAGE", nameFlags);
MakeRptCmt(0x0000932C, "Speed error as a function of vehicle speed below whichcruise will be disengaged\nMPH_S");
MakeNameEx(0x00009344, "CRUIS_CONTROL_KV_VARIABLE_GAIN_WITH_SPEED", nameFlags);
MakeNameEx(0x0000935C, "CRUIS_CONTROL_KV_CRUISE_GEAR_COMP_GAIN", nameFlags);
MakeRptCmt(0x0000935C, "Integrator multiplier used for gear compensation for cruisecontrol.\nScaler");
MakeNameEx(0x00009374, "CRUIS_CONTROL_KV_VELOCITY_COMPENSATION", nameFlags);
MakeRptCmt(0x00009374, "\nMPH");
MakeNameEx(0x0000938C, "CRUIS_CONTROL_KE_CRUISE_VEH_ACCEL_FILTER", nameFlags);
MakeRptCmt(0x0000938C, "Filter coefficient for vehicle acceleration for the cruisecontrol algorithm\nSeconds");
MakeNameEx(0x0000938E, "CRUIS_CONTROL_KE_CRUISE_VEH_SPEED_FILTER", nameFlags);
MakeRptCmt(0x0000938E, "Filter coefficient for vehicle speed for the cruise controlalgorithm\nSeconds");
MakeNameEx(0x00009390, "CRUIS_CONTROL_KE_HIGH_SPEED_DISENGAGE", nameFlags);
MakeRptCmt(0x00009390, "Maximum allowed cruise speed cruise disengage\nMPH");
MakeNameEx(0x00009392, "CRUIS_CONTROL_KE_LOW_SPEED_DISENGAGE", nameFlags);
MakeRptCmt(0x00009392, "Minimum allowed cruise speed cruise disengage\nMPH");
MakeNameEx(0x00009394, "CRUIS_CONTROL_KE_OVERSPEED_DISENGAGE", nameFlags);
MakeRptCmt(0x00009394, "Maximum overspeed value allowed without a cruise disengage\nMPH");
MakeNameEx(0x00009396, "CRUIS_CONTROL_KE_PERFORM_BRK_OR_CLUTCH_TEST", nameFlags);
MakeRptCmt(0x00009396, "Brake before cruise security option. If TRUE, the brakeinput must be asserted before cruise can be enabled\nBOOLEAN");
MakeNameEx(0x00009398, "CRUIS_CONTROL_KE_CRUISE_EFF_SPD_ERROR_MAX", nameFlags);
MakeRptCmt(0x00009398, "Maximum value effective speed error can be.\nMPH");
MakeNameEx(0x0000939A, "CRUIS_MANAGE_KE_TAP_UP_VS_ACCEL_TIME", nameFlags);
MakeNameEx(0x0000939C, "CRUIS_MANAGE_KE_ACCEL_TERMINATION_OVERSHOOT", nameFlags);
MakeNameEx(0x0000939E, "CRUIS_MANAGE_KE_ACCEL_COMP_R_A", nameFlags);
MakeRptCmt(0x0000939E, "Calibration used to scale vehicle acceleration into Demand Register during a resume.\nScaler");
MakeNameEx(0x000093A0, "CRUIS_MANAGE_KE_RESUME_IGNORE_RA_TIME", nameFlags);
MakeNameEx(0x000093A2, "CRUIS_MANAGE_KE_RESUME_VS_ACCEL_TIME", nameFlags);
MakeNameEx(0x000093A4, "CRUIS_MANAGE_KE_CRUISE_SET_TIME", nameFlags);
MakeRptCmt(0x000093A4, "The minimum amount of time the S/C switch must be depressedin order to move to engaged upon the release of the switch.\nSeconds");
MakeNameEx(0x000093A6, "CRUIS_MANAGE_KE_CRUISE_SWITCH_FAIL_TIME", nameFlags);
MakeRptCmt(0x000093A6, "If S/C or R/A switch is continuously depressed for greaterthan this amount of time, diagnostic P0567/P0568 will befailed.\nSeconds");
MakeNameEx(0x000093A8, "CRUIS_MANAGE_KE_CRUISE_SWITCH_PASS_TIME", nameFlags);
MakeNameEx(0x000093AA, "CRUIS_MANAGE_KE_ACCEL_COMP_S_C", nameFlags);
MakeRptCmt(0x000093AA, "Calibration used to scale vehicle acceleration into Demand Register during a set.\nScaler");
MakeNameEx(0x000093AC, "CRUIS_MANAGE_KE_TAP_DOWN_TIMEOUT", nameFlags);
MakeNameEx(0x000093AE, "CRUIS_MANAGE_KE_TAP_DOWN_SPEED_HIGH", nameFlags);
MakeNameEx(0x000093B0, "CRUIS_MANAGE_KE_TAP_DOWN_VS_COAST_TIME", nameFlags);
MakeNameEx(0x000093B2, "CRUIS_MANAGE_KE_TAP_DOWN_WINS", nameFlags);
MakeNameEx(0x000093B4, "CRUIS_MANAGE_KE_TAP_INCREMENT", nameFlags);
MakeRptCmt(0x000093B4, "The tap up/down increment to memory speed and demand register.\nMPH");
MakeNameEx(0x000093B6, "CRUIS_MANAGE_KE_TAP_UP_SPEED_HIGH", nameFlags);
MakeNameEx(0x000093B8, "CRUIS_MANAGE_KE_TAP_UP_SPEED_LOW", nameFlags);
MakeNameEx(0x000093BA, "CRUIS_MANAGE_KE_TAP_UP_WINS", nameFlags);
MakeNameEx(0x000093BC, "CRUIS_MANAGE_KV_ACCEL_STEP_FROM_SBE", nameFlags);
MakeRptCmt(0x000093BC, "An additional term added to the Demand Register at the initiation of an Accel in order to obtain more Desired Power.\nMPH");
MakeNameEx(0x000093D4, "CRUIS_MANAGE_KV_ACCEL_STEP_FROM_ENG", nameFlags);
MakeRptCmt(0x000093D4, "An additional term added to the Demand Register at the initiation of an Accel in order to obtain more Desired Power.\nMPH");
MakeNameEx(0x000093EC, "CRUIS_MANAGE_KV_RESUME_RATE", nameFlags);
MakeRptCmt(0x000093EC, "The resume rate increment per 100 ms.\nMPH");
MakeNameEx(0x00009404, "CRUIS_MANAGE_KV_ACCEL_RATE", nameFlags);
MakeRptCmt(0x00009404, "The accel rate increment per 100 ms.\nMPH");
MakeNameEx(0x0000941C, "CRUIS_MANAGE_KE_COAST_RATE", nameFlags);
MakeRptCmt(0x0000941C, "The coast rate increment per 100 ms.\nMPH");
MakeNameEx(0x0000941E, "CRUIS_MANAGE_KE_TAP_RATE", nameFlags);
MakeRptCmt(0x0000941E, "The tap up/down rate increment per 100 ms.\nMPH");
MakeNameEx(0x00009420, "CRUIS_MANAGE_KE_HYSTERESIS_RATE", nameFlags);
MakeRptCmt(0x00009420, "The hysteresis rate increment per 100 ms.\nMPH");
MakeNameEx(0x00009422, "CRUIS_MANAGE_KE_ACCEL_STEP_FROM_SBE_SCALER", nameFlags);
MakeRptCmt(0x00009422, "Maximum cruise speed error for which a full accel stepfrom SBE will be applied.\nMPH_S");
MakeNameEx(0x00009424, "CRUIS_MANAGE_KE_MAX_ACCEL_FROM_SBE_ERROR", nameFlags);
MakeRptCmt(0x00009424, "Maximum cruise speed error for which accel from SBE modewill be entered when the R/A switch is applied.\nMPH_S");
MakeNameEx(0x00009426, "DT_ABUSE_MGMT_KE_ABUSE_DRIVE_RPM_HIGH", nameFlags);
MakeNameEx(0x00009428, "DT_ABUSE_MGMT_KE_ABUSE_DRIVE_RPM_LOW", nameFlags);
MakeNameEx(0x0000942A, "DT_ABUSE_MGMT_KE_ABUSE_PN_RPM_HIGH", nameFlags);
MakeNameEx(0x0000942C, "DT_ABUSE_MGMT_KE_ABUSE_PN_RPM_LOW", nameFlags);
MakeNameEx(0x0000942E, "DT_ABUSE_MGMT_KE_ABUSE_THROTTLE_HIGH", nameFlags);
MakeRptCmt(0x0000942E, "If the throttle position is greater than this hysteresis limit,drivetrain abuse can be enabled.\nPercent");
MakeNameEx(0x00009430, "DT_ABUSE_MGMT_KE_ABUSE_THROTTLE_LOW", nameFlags);
MakeRptCmt(0x00009430, "If the throttle position is greater than this hysteresis limit,drivetrain abuse can be enabled.\nPercent");
MakeNameEx(0x00009432, "DT_ABUSE_MGMT_KE_ABUSE_VEHICLE_SPEED_THRESH", nameFlags);
MakeRptCmt(0x00009432, "If the vehicle speed is greater than or equal to this value,drivetrain abuse can not be enabled.\nMPH");
MakeNameEx(0x00009434, "DT_ABUSE_MGMT_KE_ABUSE_EQUIVALENCE_RATIO", nameFlags);
MakeRptCmt(0x00009434, "If drivetrain abuse is active, the fuel equivalence ratiois commanded to this value.\nEquiv_Ratio_Type");
MakeNameEx(0x00009436, "DT_ABUSE_MGMT_KV_ABUSE_CYLINDER_DISABLE_PN", nameFlags);
MakeRptCmt(0x00009436, "Vector specifying which cylinders to disable in abuse managementwhen PSM indicates Park or Neutral. FALSE = DISABLED\nBOOLEAN");
MakeNameEx(0x00009437, "DT_ABUSE_MGMT_KV_ABUSE_CYLINDER_DISABLE_NOT_PN", nameFlags);
MakeRptCmt(0x00009437, "Vector specifying which cylinders to disable in abuse managementwhen PSM does not indicate Park or Neutral. FALSE = DISABLED\nBOOLEAN");
MakeNameEx(0x00009438, "DT_ABUSE_MGMT_KV_ABUSE_TIME", nameFlags);
MakeNameEx(0x00009458, "EGR_KE_EGR_ENABLED", nameFlags);
MakeRptCmt(0x00009458, "controls execution of EGR logic\nBOOLEAN");
MakeNameEx(0x0000945A, "EGR_KE_EGR_FULL_SCALE_GAIN", nameFlags);
MakeRptCmt(0x0000945A, "EGR position sensor scaling factor.\n% / Count");
MakeNameEx(0x0000945C, "EGR_KE_EGR_OFFSET_FILTER_COEFF", nameFlags);
MakeRptCmt(0x0000945C, "First order filter coefficient used to reduce zero linear EGR position offset.\nSeconds");
MakeNameEx(0x0000945E, "EGR_KE_EGR_POSITION_CLOSED_MIN", nameFlags);
MakeRptCmt(0x0000945E, "Minimum allowable value of learned EGR closed position.\nA/D Counts");
MakeNameEx(0x00009460, "EGR_KE_EGR_POSITION_CLOSED_MAX", nameFlags);
MakeRptCmt(0x00009460, "Maximum allowable value of learned EGR closed position.\nA/D Counts");
MakeNameEx(0x00009462, "EGR_KE_EGR_POSITION_FILTER_COEF", nameFlags);
MakeRptCmt(0x00009462, "First order lag filter coefficient for percent pintle opening.\nSeconds");
MakeNameEx(0x00009464, "EGR_KE_DESIRED_EGR_POSITION_MINIMUM", nameFlags);
MakeRptCmt(0x00009464, "If desired EGR position is less than this calibration, desired EGR position is set to 0.0.\nPercent");
MakeNameEx(0x00009466, "EGR_KE_EGR_OFF_VACUUM_HYST_THRES", nameFlags);
MakeRptCmt(0x00009466, "Hysteresis value which enables EGR from off state.\nkPa");
MakeNameEx(0x00009468, "EGR_KE_EGR_OFF_VACUUM_THRESHOLD", nameFlags);
MakeRptCmt(0x00009468, "Disables EGR below this calibration and linearly interpolates from KE_EGR_Full_Vacuum_Threshold.\nkPa");
MakeNameEx(0x0000946A, "EGR_KE_EGR_FULL_VACUUM_THRESHOLD", nameFlags);
MakeRptCmt(0x0000946A, "Enables full EGR above this calibration.\nkPa");
MakeNameEx(0x0000946C, "EGR_KE_EGR_TCC_RPM_HIGH_HYST", nameFlags);
MakeRptCmt(0x0000946C, "If Engine Speed is above this threshold, disable the TCC multiplier (Torque Converter Multiplier <- 1.0 ).\nRPM");
MakeNameEx(0x0000946E, "EGR_KE_EGR_TCC_RPM_LOW_HYST", nameFlags);
MakeRptCmt(0x0000946E, "If Engine Speed is below this threshold, enable the TCC multiplier using KV_Torque_Converter_Multiplier.\nRPM");
MakeNameEx(0x00009470, "EGR_KE_EGR_LEARN_ENABLE_TIME", nameFlags);
MakeRptCmt(0x00009470, "Defines the time required to allow the start of offset learning.\nSeconds");
MakeNameEx(0x00009472, "EGR_KE_EGR_INIT_LEARN_CMPT_TIME", nameFlags);
MakeNameEx(0x00009474, "EGR_KE_EGR_INIT_LOW_POSITION", nameFlags);
MakeRptCmt(0x00009474, "Minimum allowable value of the initial learned low EGR closed offset.\nA/D Counts");
MakeNameEx(0x00009476, "EGR_KE_EGR_INIT_HIGH_POSITION", nameFlags);
MakeRptCmt(0x00009476, "Maximum allowable value of the initial learned low EGR closed offset.\nA/D Counts");
MakeNameEx(0x00009478, "EGR_KE_EGR_OFFSET_IGN_COUNT_MAX", nameFlags);
MakeRptCmt(0x00009478, "Initial EGR initial offset is relearned when this ignition cycle counter expires.\nCount");
MakeNameEx(0x0000947A, "EGR_KE_EGR_PINTLE_GROWTH_MAX", nameFlags);
MakeRptCmt(0x0000947A, "Max allowable +/- change in the EGR offset relative to the initial learn position.\nA/D Counts");
MakeNameEx(0x0000947C, "EGR_KE_EGR_MIN_NOISE_POSITION", nameFlags);
MakeRptCmt(0x0000947C, "Below this percent pintle position opening, the EGR valve is considered closed.\nPercent");
MakeNameEx(0x0000947E, "EGR_KV_COOLANT_TEMPERATURE_MULTIPLIE", nameFlags);
MakeRptCmt(0x0000947E, "Coolant terperature multiplier modifying desired EGR position.\nMultiplier");
MakeNameEx(0x000094AA, "EGR_KV_EQUIVALENCE_RATIO_MULTIPLIER", nameFlags);
MakeRptCmt(0x000094AA, "Equivalence ratio multiplier modifying desired EGR position.\nMultiplier");
MakeNameEx(0x000094CC, "EGR_KV_THROTTLE_POSITION_MULTIPLIER", nameFlags);
MakeRptCmt(0x000094CC, "Decreasing delta throttle position multiplier modifying desired EGR position.\nMultiplier");
MakeNameEx(0x000094E6, "EGR_KV_TORQUE_CONVERTER_MULTIPLIER", nameFlags);
MakeRptCmt(0x000094E6, "Torque converter clutch multiplier modifying desired EGR position.\nMultiplier");
MakeNameEx(0x00009506, "EGR_KV_BAROMETER_MULTIPLIER", nameFlags);
MakeRptCmt(0x00009506, "Barometer multiplier modifying desired EGR position.\nMultiplier");
MakeNameEx(0x00009518, "EGR_KA_EGR_DESIRED_POSITION", nameFlags);
MakeRptCmt(0x00009518, "EGR desired pintle position based on engine speed and Grams Air Per Cylinder.\nPercent");
MakeNameEx(0x0000980A, "EGR_KE_EGR_VEHICLE_SPEED_THRESHOLD", nameFlags);
MakeRptCmt(0x0000980A, "Increasing desired EGR position filter coefficient MPH threshold.\nMPH");
MakeNameEx(0x0000980C, "EGR_KV_HIGH_VEHICLE_SPEED_COEFFICIEN", nameFlags);
MakeRptCmt(0x0000980C, "Lag filter coefficient used only on increasing desired EGR position above KE_Vehicle_Speed_Threshold.\nCoeff.");
MakeNameEx(0x00009816, "EGR_KV_LOW_VEHICLE_SPEED_COEFFICIENT", nameFlags);
MakeRptCmt(0x00009816, "Lag filter coefficient used only on increasing desired EGR position below KE_Vehicle_Speed_Threshold.\nCoeff.");
MakeNameEx(0x00009820, "EGR_KV_EGR_VEHICLE_SPEED_COEFFICIENT", nameFlags);
MakeRptCmt(0x00009820, "Lag filter coefficient used only on decreasing desired EGR position.\nCoeff.");
MakeNameEx(0x0000982A, "EGR_KV_INITIAL_DUTY_CYCLE", nameFlags);
MakeRptCmt(0x0000982A, "The nominal duty cycle required to move the EGR valve from the closed position to the desired position.\nPercent");
MakeNameEx(0x00009834, "EGR_KV_INITIAL_INTEGRAL_VACUUM_CORRE", nameFlags);
MakeRptCmt(0x00009834, "Multiplies initial EGR integrator term to correct for engine vacuum.\nMultiplier");
MakeNameEx(0x00009854, "EGR_KV_POSITION_INTEGRAL_GAIN", nameFlags);
MakeRptCmt(0x00009854, "Gain applied to the position error term to calculate the integral correction.\nMultiplier");
MakeNameEx(0x0000986A, "EGR_KV_INTEGRAL_VACUUM_CORRECTION", nameFlags);
MakeRptCmt(0x0000986A, "Multiplies EGR integral term to correct for engine vacuum.\nMultiplier");
MakeNameEx(0x0000988A, "EGR_KV_POSITION_PROPORTIONAL_GAIN", nameFlags);
MakeRptCmt(0x0000988A, "Gain applied to the position error term to calculate the proportional correction.\nMultiplier");
MakeNameEx(0x000098A0, "EGR_KV_PROPORTIONAL_VACUUM_CORRECTIO", nameFlags);
MakeRptCmt(0x000098A0, "Multiplies EGR proportional term to correct for engine vacuum.\nMultiplier");
MakeNameEx(0x000098C0, "EGR_KE_VEHICLE_SPEED_DISABLE_THRESHO", nameFlags);
MakeRptCmt(0x000098C0, "MPH threshold below which EGR is disabled when enabled.\nMPH");
MakeNameEx(0x000098C2, "EGR_KE_VEHICLE_SPEED_ENABLE_THRESHOL", nameFlags);
MakeRptCmt(0x000098C2, "MPH threshold above which EGR is enabled when disabled.\nMPH");
MakeNameEx(0x000098C4, "EGR_KE_THROTTLE_POSITION_DISABLE_THR", nameFlags);
MakeRptCmt(0x000098C4, "TPS threshold below which EGR is disabled when enabled.\nPercent");
MakeNameEx(0x000098C6, "EGR_KE_THROTTLE_POSITION_ENABLE_THRE", nameFlags);
MakeRptCmt(0x000098C6, "TPS threshold above which EGR is enabled when disabled.\nPercent");
MakeNameEx(0x000098C8, "EGR_KE_LOWER_IAT_ENABLE_THRESHOLD", nameFlags);
MakeRptCmt(0x000098C8, "Lower IAT threshold above which EGR is enabled when disabled.\nDegrees C");
MakeNameEx(0x000098CA, "EGR_KE_LOWER_IAT_DISABLE_THRESHOLD", nameFlags);
MakeRptCmt(0x000098CA, "Lower IAT threshold below which EGR is disabled when enabled.\nDegrees C");
MakeNameEx(0x000098CC, "EGR_KE_EGR_HIGH_AIRFLOW_THRESHOLD", nameFlags);
MakeRptCmt(0x000098CC, "High Mass Airflow threshold which EGR is disabled.\nGrams/Sec.");
MakeNameEx(0x000098CE, "EGR_KE_EGR_LOW_AIRFLOW_THRESHOLD", nameFlags);
MakeRptCmt(0x000098CE, "Low Mass Airflow threshold which EGR is disabled.\nGrams/Sec.");
MakeNameEx(0x000098D0, "EGR_KE_LOWER_MAP_ENABLE_THRESHOLD", nameFlags);
MakeRptCmt(0x000098D0, "Lower MAP threshold above which EGR is enabled when disabled.\nkPa");
MakeNameEx(0x000098D2, "EGR_KE_LOWER_MAP_DISABLE_THRESHOLD", nameFlags);
MakeRptCmt(0x000098D2, "Lower MAP threshold below which EGR is disabled when enabled.\nkPa");
MakeNameEx(0x000098D4, "EGR_KE_CLUTCH_TRANSITION_TIMER_THRES", nameFlags);
MakeRptCmt(0x000098D4, "EGR disable time after air conditioner clutch engagement.\nSeconds");
MakeNameEx(0x000098D6, "EGR_KE_EGR_PWRUP_COOLANT_DELAY_THRES", nameFlags);
MakeNameEx(0x000098D8, "EGR_KE_EGR_COOLANT_ENABLE_THRESHOLD", nameFlags);
MakeNameEx(0x000098DA, "EGR_KE_EGR_ENABLE_COOLANT_TIME", nameFlags);
MakeRptCmt(0x000098DA, "Time after coolant temperatures requirements have been met before enabling EGR.\nSeconds");
MakeNameEx(0x000098DC, "EGR_KE_UPPER_TPS_ENABLE_THRESHOLD", nameFlags);
MakeRptCmt(0x000098DC, "Upper TPS threshold below which EGR is enabled when disabled.\nPercent");
MakeNameEx(0x000098DE, "EGR_KE_UPPER_TPS_DISABLE_THRESHOLD", nameFlags);
MakeRptCmt(0x000098DE, "Upper TPS threshold above which EGR is disabled when enabled.\nPercent");
MakeNameEx(0x000098E0, "EGR_KE_EGR_MULTI_STROKE_ENABLED", nameFlags);
MakeRptCmt(0x000098E0, "Set this calibration TRUE to enable EGR Multi Stroke.\nTRUE/FALSE");
MakeNameEx(0x000098E2, "EGR_KE_EGR_STRK_LOW_COOLANT_TEMP", nameFlags);
MakeRptCmt(0x000098E2, "Disable EGR Multi Stroke when coolant is colder than this.\nDegrees C");
MakeNameEx(0x000098E4, "EGR_KE_EGR_STRK_HIGH_COOLANT_TEMP", nameFlags);
MakeRptCmt(0x000098E4, "Disable EGR Multi Stroke when coolant is warmer than this.\nDegrees C");
MakeNameEx(0x000098E6, "EGR_KE_EGR_STRK_LOW_EGR_POSITION", nameFlags);
MakeRptCmt(0x000098E6, "Disable EGR Multi Stroke when Desired EGR is less than this.\nPercent");
MakeNameEx(0x000098E8, "EGR_KE_EGR_STROKE_COUNTER_LMT", nameFlags);
MakeRptCmt(0x000098E8, "Disable EGR Multi Stroke after this many strokes in normallentgh ignition cycle.\nStrokes");
MakeNameEx(0x000098EA, "EGR_KE_EGR_STROKE_TIME_DELAY", nameFlags);
MakeRptCmt(0x000098EA, "Minimum amount of time the EGR valve is commanded opento max position to be considered an EGR stroke event.\nSeconds");
MakeNameEx(0x000098EC, "EGR_KE_EGR_STROKE_STABILIZATION", nameFlags);
MakeRptCmt(0x000098EC, "Minimum time enabling conditions must hold before each stroke for EGR Multi Stroke.\nSeconds");
MakeNameEx(0x000098EE, "EGR_KE_EGR_STROKE_RESET_TIME_PERIOD", nameFlags);
MakeRptCmt(0x000098EE, "EGR Multi Stroke is re-enabled this often.\nSeconds");
MakeNameEx(0x000098F2, "EGR_KE_EGR_STRK_MAX_OPEN_TIME", nameFlags);
MakeRptCmt(0x000098F2, "Time EGR valve is commanded on for each stroke for EGR Multi Stroke.\nSeconds");
MakeNameEx(0x000098F4, "ENG_OIL_KE_ENGINE_OIL_PRESSURE_COEFF", nameFlags);
MakeRptCmt(0x000098F4, "Filter coefficient used to filter engine oil pressure.\nSeconds");
MakeNameEx(0x000098F6, "ENG_OIL_KE_OIL_PRESSURE_GAGE_PWM_MIN", nameFlags);
MakeRptCmt(0x000098F6, "The minimum allowed PWM signal to be sent to the oilpressure gage.\nPercent");
MakeNameEx(0x000098F8, "ENG_OIL_KE_OIL_PRESSURE_GAGE_PWM_MAX", nameFlags);
MakeRptCmt(0x000098F8, "The maximum allowed PWM signal to be sent to the oilpressure gage.\nPercent");
MakeNameEx(0x000098FA, "ENG_OIL_KV_OIL_PRESSURE_TO_PWM_FOR_GAGE", nameFlags);
MakeRptCmt(0x000098FA, "The PWM signal to be sent to the oil pressure gage.\nPercent");
MakeNameEx(0x0000994C, "ENG_OIL_KE_EFFECTIVE_REVOLUTION_LIMIT", nameFlags);
MakeRptCmt(0x0000994C, "Decrement Oil Life interval when effective_engine_revolutions exceeds this.\nRevolutions");
MakeNameEx(0x0000994E, "ENG_OIL_KE_ENG_OIL_PRES_SCALE_FACTOR", nameFlags);
MakeRptCmt(0x0000994E, "Engine oil pressure sensor scaling factor.\nFactor");
MakeNameEx(0x00009950, "ENG_OIL_KE_ENG_OIL_SENSOR_OFFSET", nameFlags);
MakeRptCmt(0x00009950, "Engine oil pressure sensor offset value.\nkPa");
MakeNameEx(0x00009954, "ENG_OIL_KE_ENGINE_OIL_PRESSURE_DEFAULT", nameFlags);
MakeRptCmt(0x00009954, "Default value for engine oil pressure, if sensor has failed.\nkPa");
MakeNameEx(0x00009958, "ENG_OIL_KE_ENGINE_OIL_PRES_LOWER_FAULTS", nameFlags);
MakeRptCmt(0x00009958, "If the number of consecutive faults is greater than or equal to this value, it is considereded a fault.\ncounts");
MakeNameEx(0x00009959, "ENG_OIL_KE_ENGINE_OIL_PRES_UPPER_FAULTS", nameFlags);
MakeRptCmt(0x00009959, "If the number of consecutive faults is greater than or equal to this value, it is considereded a fault.\ncounts");
MakeNameEx(0x0000995A, "ENG_OIL_KE_ENGINE_OIL_PRES_MAX_LIMIT", nameFlags);
MakeRptCmt(0x0000995A, "If the oil pressure reading is equal to or greater than this value, it is considered out of limits.\nA/D counts");
MakeNameEx(0x0000995C, "ENG_OIL_KE_ENGINE_OIL_PRES_MIN_LIMIT", nameFlags);
MakeRptCmt(0x0000995C, "If the oil pressure reading is equal to or less than this value, it is considered out of limits.\nA/D counts");
MakeNameEx(0x0000995E, "ENG_OIL_KV_OIL_EQUILIBRIUM_FILTER_COEF", nameFlags);
MakeRptCmt(0x0000995E, "First order lag filter coefficient for estimated oil temperature in equilibrium mode.\nMultiplier");
MakeNameEx(0x00009986, "ENG_OIL_KE_OIL_LEVEL_LIGHT_ON_FOR_RUN", nameFlags);
MakeRptCmt(0x00009986, "If TRUE and Oil Level is low turn on Oil Low Light.\nBOOLEAN");
MakeNameEx(0x00009987, "ENG_OIL_KE_OIL_LEVEL_LOW_SAMPLES", nameFlags);
MakeRptCmt(0x00009987, "Number of Oil level samples reporting low needed to determine low oil level.\nCounts");
MakeNameEx(0x00009988, "ENG_OIL_KE_OIL_LEVEL_SAMPLE_QUANTITY", nameFlags);
MakeRptCmt(0x00009988, "Amount of oil level samples to be taken for a given period.\nCounts");
MakeNameEx(0x0000998A, "ENG_OIL_KV_OIL_LEVEL_DELTA", nameFlags);
MakeRptCmt(0x0000998A, "Value to be compared to Coolant_Stoprun - Coolant_Powerup.This value has Range 0 to 180, since it is a delta.\nDegrees C");
MakeNameEx(0x000099AA, "ENG_OIL_KE_OIL_LIFE_BULB_TIME", nameFlags);
MakeRptCmt(0x000099AA, "Length of time Bulb check should last.\nSeconds");
MakeNameEx(0x000099AC, "ENG_OIL_KE_OIL_LIFE_CHANGE_NOW", nameFlags);
MakeRptCmt(0x000099AC, "Determines when to turn on the Change Oil Now.\nPercent");
MakeNameEx(0x000099AE, "ENG_OIL_KE_OIL_LIFE_CHANGE_SOON", nameFlags);
MakeRptCmt(0x000099AE, "Determines when the Change Oil Soon lamp will be requested.\nPercent");
MakeNameEx(0x000099B0, "ENG_OIL_KE_OIL_LIFE_FLASH_LIGHT_TIME", nameFlags);
MakeRptCmt(0x000099B0, "Determine how long to flash the NOW light during a reset.\nSeconds");
MakeNameEx(0x000099B2, "ENG_OIL_KE_OIL_LIFE_HOT_ENABLE", nameFlags);
MakeRptCmt(0x000099B2, "Enables the option to kill oil life upon overheating.\nBOOLEAN");
MakeNameEx(0x000099B3, "ENG_OIL_KE_OIL_LIFE_NOW_BULB_CHECK_REQ", nameFlags);
MakeRptCmt(0x000099B3, "If TRUE, Oil Life Now Bulb check will be run.\nBOOLEAN");
MakeNameEx(0x000099B4, "ENG_OIL_KE_OIL_LIFE_NOW_ENABLED", nameFlags);
MakeRptCmt(0x000099B4, "Determine if the NOW lamp is used.\nBOOLEAN");
MakeNameEx(0x000099B6, "ENG_OIL_KE_OIL_LIFE_OVERTEMP", nameFlags);
MakeRptCmt(0x000099B6, "Determine when the engine oil is to be changed upon overheating.\nDegrees_C");
MakeNameEx(0x000099B8, "ENG_OIL_KV_OIL_LIFE_PENALTY_FACTOR", nameFlags);
MakeRptCmt(0x000099B8, "Engine revolution correction factor, based on estimated engine oil temperature.\nScale Factor");
MakeNameEx(0x000099CC, "ENG_OIL_KE_OIL_LIFE_SOON_BULB_CHECK_REQ", nameFlags);
MakeRptCmt(0x000099CC, "If TRUE, Oil Life Soon Bulb check will be run.\nBOOLEAN");
MakeNameEx(0x000099CD, "ENG_OIL_KE_OIL_LIFE_SOON_ENABLED", nameFlags);
MakeRptCmt(0x000099CD, "Determine if SOON lamp is used.\nBOOLEAN");
MakeNameEx(0x000099CE, "ENG_OIL_KE_OIL_PRESSURE_HYSTERESIS", nameFlags);
MakeRptCmt(0x000099CE, "Hysteresis on low oil pressure.\nkPa");
MakeNameEx(0x000099D2, "ENG_OIL_KE_OIL_PRESSURE_LOW_TIME", nameFlags);
MakeRptCmt(0x000099D2, "Time oil pressure must be low to turn on the warning.\nSeconds");
MakeNameEx(0x000099D4, "ENG_OIL_KV_OIL_PRESSURE_MINIMUM", nameFlags);
MakeRptCmt(0x000099D4, "Minimum allowed oil pressure for normal operation.\nkPa per RPM");
MakeNameEx(0x00009A18, "ENG_OIL_KE_OIL_TEMPERATURE_EQUILIBRIUM", nameFlags);
MakeNameEx(0x00009A1A, "ENG_OIL_KV_OIL_TEMPERATURE_REV_DELAY", nameFlags);
MakeRptCmt(0x00009A1A, "Oil temperature warm-up delay as a function of initial coolant temperature.\nRevs per Deg C");
MakeNameEx(0x00009A3A, "ENG_OIL_KE_OL_AIR_TEMP_COEFFICIENT", nameFlags);
MakeRptCmt(0x00009A3A, "Factor to adjust the effect of induction air temperature on oil temperature.\nMultiplier");
MakeNameEx(0x00009A3C, "ENG_OIL_KE_OL_COOLANT_COEFFICIENT", nameFlags);
MakeRptCmt(0x00009A3C, "Factor to adjust the effect of coolant temperature on oil temperature.\nMultiplier");
MakeNameEx(0x00009A3E, "ENG_OIL_KE_OL_ENGINE_SPEED_COEFFICIENT", nameFlags);
MakeRptCmt(0x00009A3E, "Factor to adjust the effect of engine speed on oil temperature.\nMultiplier");
MakeNameEx(0x00009A40, "ENG_OIL_KE_OL_VEHICLE_SPEED_COEFFICIENT", nameFlags);
MakeRptCmt(0x00009A40, "Factor to adjust the effect of vehicle speed on oil temperature.\nMultiplier");
MakeNameEx(0x00009A44, "ENG_OIL_KE_RECOMMENDED_MILEAGE", nameFlags);
MakeRptCmt(0x00009A44, "Maximum allowed distance between oil changes.  Immediate oil change will be requested if this value is exceeded.\nMiles");
MakeNameEx(0x00009A48, "ENG_OIL_KE_REVOLUTION_UNTIL_SERVICE", nameFlags);
MakeRptCmt(0x00009A48, "Maximum number of effective engine revolutions before an engine oil change is requested.\nRevolutions");
MakeNameEx(0x00009A4A, "ENG_OIL_KE_WARMUP_COOLANT_COEFFICIENT", nameFlags);
MakeNameEx(0x00009A4C, "ENG_OIL_KE_WARMUP_STAT_OPEN_MULTIPLIER", nameFlags);
MakeRptCmt(0x00009A4C, "Multiplier used to adjust the effect of coolant temp on estimated oil temp after termostat opens.\nMultiplier");
MakeNameEx(0x00009A4E, "ENG_OIL_KE_OIL_LEVEL_IGN_CYCLES", nameFlags);
MakeRptCmt(0x00009A4E, "Determine how many ignition cycles to collect low oil levelsamples prior to turning on low oil level light\nSHORTCARD");
MakeNameEx(0x00009A4F, "EXECUTIVE_KE_STOP_ENABLED", nameFlags);
MakeRptCmt(0x00009A4F, "When set to TRUE a stop instruction will be used to fill up the dead time between tasks.\nBOOLEAN");
MakeNameEx(0x00009A50, "ENG_PROTECTION_KE_ENGINE_PROTECTION_COOLANT_HIG", nameFlags);
MakeRptCmt(0x00009A50, "Coolant Temperature must rise above this threshold toenable engine overtemperature protection\nDegrees C");
MakeNameEx(0x00009A52, "ENG_PROTECTION_KE_ENGINE_PROTECTION_COOLANT_LOW", nameFlags);
MakeRptCmt(0x00009A52, "Coolant temperature threshold below which engine overtemperatureprotection is disabled\nDegrees C");
MakeNameEx(0x00009A54, "ENG_PROTECTION_KE_ENGINE_PROTECTION_DELAY_TIME", nameFlags);
MakeNameEx(0x00009A56, "ENG_PROTECTION_KE_CYCLES_BETWEEN_RAMP_STEPS", nameFlags);
MakeRptCmt(0x00009A56, "Number of engine cycles to run before ramping in or out another cylinder.\nUnitless");
MakeNameEx(0x00009A58, "ENG_PROTECTION_KE_CYCLES_BETWEEN_SWITCHING", nameFlags);
MakeRptCmt(0x00009A58, "Number of engine cycles to run before switching cylinder groups.\nUnitless");
MakeNameEx(0x00009A5A, "ENG_PROTECTION_KE_ENGINE_ALARM_COOLANT_TEMP", nameFlags);
MakeRptCmt(0x00009A5A, "Turn on 120 peeps per minute alarm and check gauges lamp when coolant temperature exceeds this value.\nDegrees C");
MakeNameEx(0x00009A5C, "ENG_PROTECTION_KE_ENGINE_PROTECTION_STARTUP_DEL", nameFlags);
MakeRptCmt(0x00009A5C, "Amount of time to delay engine overheat protection modeafter engine has been running\nSeconds");
MakeNameEx(0x00009A5E, "ENG_PROTECTION_KE_ENG_SHUTDOWN_CLT_TEMP_OFFSET", nameFlags);
MakeNameEx(0x00009A60, "ENG_PROTECTION_KE_ENGINE_SHUTDOWN_COOLANT_TIME", nameFlags);
MakeNameEx(0x00009A62, "ENG_PROTECTION_KE_ENG_SHUTDOWN_LOW_CLT_ENABLE", nameFlags);
MakeRptCmt(0x00009A62, "Set TRUE to enable engine shutdown based on low coolant switch.\nBOOLEAN");
MakeNameEx(0x00009A64, "ENG_PROTECTION_KE_ENGINE_SHUTDOWN_TIME", nameFlags);
MakeRptCmt(0x00009A64, "Initiate engine shutdown when the 300 beeps per minute alarm has been sounding for this amount of time.\nSeconds");
MakeNameEx(0x00009A66, "ENG_PROTECTION_KE_CYLINDER_CUTOUT_HYSTERESIS", nameFlags);
MakeRptCmt(0x00009A66, "Hysteresis on the Torque_Percentage applied to prevent cyclingbetween the number of cylinders enabled.\nPercent");
MakeNameEx(0x00009A68, "ENG_PROTECTION_KV_CYLINDER_GROUP_ONE", nameFlags);
MakeRptCmt(0x00009A68, "Vector specifying first set of cylinders to disable for engine overtemperature protection\nBOOLEAN");
MakeNameEx(0x00009A69, "ENG_PROTECTION_KV_CYLINDER_GROUP_TWO", nameFlags);
MakeRptCmt(0x00009A69, "Vector specifying second set of cylinders to disable for engine overtemperature protection\nBOOLEAN");
MakeNameEx(0x00009A6A, "ENG_PROTECTION_KV_ENG_PROT_CYLINDERS_TO_DISABLE", nameFlags);
MakeRptCmt(0x00009A6A, "Vector specifying which cylinders to disable for Engine protectionFALSE = DISABLED\nBOOLEAN");
MakeNameEx(0x00009A72, "ENG_PROTECTION_KV_BTM_PM_CYLINDERS_TO_DISABLE", nameFlags);
MakeRptCmt(0x00009A72, "Vector specifying which cylinders to disable for brake torque management and ETC power management FALSE=DISABLED.\nBOOLEAN");
MakeNameEx(0x00009A7A, "ENG_PROTECTION_KV_POWER_HOP_PM_CYL_TO_DISABLE", nameFlags);
MakeRptCmt(0x00009A7A, "Vector specifing which cylinders to disable for power hop torque management, based on number of cylinders to be disabled.\nBOOLEAN");
MakeNameEx(0x00009A82, "PROTECTED_KV_ENGINE_SPEED_LIMIT", nameFlags);
MakeRptCmt(0x00009A82, "Engine speed below which the ETC governor attemptsto keep the engine speed.\nRPM");
MakeNameEx(0x00009A96, "PROTECTED_KE_ENGINE_OVERSPEED_LAMP", nameFlags);
MakeRptCmt(0x00009A96, "Engine speed threshold for lighting the engine overspeed lamp\nRPM");
MakeNameEx(0x00009A98, "PROTECTED_KE_TACH_PULLUP_ENABLE", nameFlags);
MakeRptCmt(0x00009A98, "If TRUE the tachometer is pulled up internal to the PCM.\nBOOLEAN");
MakeNameEx(0x00009A99, "PROTECTED_KE_ENGINE_SPEED_FILTER_COEF", nameFlags);
MakeRptCmt(0x00009A99, "Filter coefficient used to first order lag filter engine speed.\nUnitless");
MakeNameEx(0x00009A9A, "PROTECTED_KE_FANLOCKUPRPMLIMIT", nameFlags);
MakeRptCmt(0x00009A9A, "Calibration value at which the engine speed is limited to prevent fan failure due to rotational speed.\nRPM");
MakeNameEx(0x00009A9C, "ENG_STATE_KE_NO_REF_TIME", nameFlags);
MakeRptCmt(0x00009A9C, "Engine is considered stopped if no ref pulses have occured in this amount of time.\nSeconds");
MakeNameEx(0x00009A9E, "CRITICAL_REGION_KE_IGNITION_OFF_TIME", nameFlags);
MakeRptCmt(0x00009A9E, "Ignition must be off for this period of time before the state changes due to ignition being off.\nSeconds");
MakeNameEx(0x00009AA0, "CRITICAL_REGION_KE_EXTENDED_POWEROFF_ON_TIME", nameFlags);
MakeRptCmt(0x00009AA0, "Amount of time the Engine will stay in the Extended Poweroff state to allow the EVAP diagnostic to run.\nSeconds_L");
MakeNameEx(0x00009AA4, "CRITICAL_REGION_KV_STARTRUN_PULSES", nameFlags);
MakeRptCmt(0x00009AA4, "Number of consecutive low resolution reference pulses above KV_Startrun_RPM required for transition from Crank to Run.\nPulses");
MakeNameEx(0x00009AC4, "CRITICAL_REGION_KV_STARTRUN_RPM", nameFlags);
MakeRptCmt(0x00009AC4, "Engine speed threshold for transition from Crank to Run. See KE_Startrun_Pulses for more information.\nRPM");
MakeNameEx(0x00009AE4, "ENG_TORQUE_KE_ENGINE_MAX_TORQUE", nameFlags);
MakeRptCmt(0x00009AE4, "Maximum net torque output from the engine.\nft-lb");
MakeNameEx(0x00009AE6, "ENG_TORQUE_KE_ENGINE_INERTIA", nameFlags);
MakeRptCmt(0x00009AE6, "Desired axle torque for rear axle protection\nMult0to2");
MakeNameEx(0x00009AE8, "ENG_TORQUE_KV_THERMAL_EFF_BLEND_FACTOR", nameFlags);
MakeRptCmt(0x00009AE8, "Interpolation fraction between E0 and E80 fuel for Indicated MBT Torque Efficiency tables.\nMult_0_to_1");
MakeNameEx(0x00009AF2, "ENG_TORQUE_KV_AC_TURN_ON_DELAY", nameFlags);
MakeNameEx(0x00009B0E, "ENG_TORQUE_KV_AC_TURN_OFF_DELAY", nameFlags);
MakeRptCmt(0x00009B0E, "AC compressor turn off delay to prevent engine flareF( AC_Torque_Adjusted ).\nSeconds");
MakeNameEx(0x00009B2A, "ENG_TORQUE_KV_AC_BUMP_AIR_REF_DLY_OFF", nameFlags);
MakeNameEx(0x00009B38, "ENG_TORQUE_KV_AC_BUMP_AIR_REF_DLY_ON", nameFlags);
MakeNameEx(0x00009B46, "ENG_TORQUE_KE_MAXIMUM_AC_BUMP_THROTTLE_AREA", nameFlags);
MakeRptCmt(0x00009B46, "Used to clip and hold the ac bump throttle area for ETC.\nPercent");
MakeNameEx(0x00009B48, "ENG_TORQUE_KA_AC_BUMP_SPARK_RETARD_LIMIT", nameFlags);
MakeRptCmt(0x00009B48, "Maximum amount of spark retard allowed for AC Bump logic.\nDegrees");
MakeNameEx(0x00009CC2, "ENG_TORQUE_KE_UNITS_CONSTANT", nameFlags);
MakeNameEx(0x00009CC6, "ENG_TORQUE_KA_INDICATED_MBT_TORQUE_EFF_E0", nameFlags);
MakeRptCmt(0x00009CC6, "Thermal Efficiency factor used in calculating Indicated_MBT_Torque with E0 fuel.\nNONE 0-1");
MakeNameEx(0x00009F66, "ENG_TORQUE_KA_INDICATED_MBT_TORQUE_EFF_E80", nameFlags);
MakeRptCmt(0x00009F66, "Thermal Efficiency factor used in calculating Indicated_MBT_Torque with E80 fuel.\nNONE 0-1");
MakeNameEx(0x0000A206, "ENG_TORQUE_KA_TORQUE_LOSS_FROM_SPARK_RETARD", nameFlags);
MakeNameEx(0x0000A2BA, "ENG_TORQUE_KV_AC_COMPRESSOR_TORQUE", nameFlags);
MakeRptCmt(0x0000A2BA, "Torque consumed by friction in AC compressor when AC compressor clutch is engaged.\nlb_ft");
MakeNameEx(0x0000A2D0, "ENG_TORQUE_KV_AC_COMP_IAT_TORQUE", nameFlags);
MakeRptCmt(0x0000A2D0, "AC compressor torque loss due to induction air temperature\nlb_ft");
MakeNameEx(0x0000A2F0, "ENG_TORQUE_KV_ACCESSORY_DRIVE_TORQUE", nameFlags);
MakeRptCmt(0x0000A2F0, "Parasitic torque due to powersteering pump and alternator\nlb_ft");
MakeNameEx(0x0000A31A, "ENG_TORQUE_KA_FRICTION_TORQUE", nameFlags);
MakeRptCmt(0x0000A31A, "Torque consumed by friction in engine -- base value.\nlb_ft");
MakeNameEx(0x0000A416, "ENG_TORQUE_KA_OIL_TEMP_FRICTION_MODIFIER", nameFlags);
MakeRptCmt(0x0000A416, "This is the change in the friction torque due to changesin oil temperature.\nNONE 0-4");
MakeNameEx(0x0000A6B6, "ENG_TORQUE_KE_INDICATED_TORQUE_FILTER", nameFlags);
MakeRptCmt(0x0000A6B6, "This is the filter coefficient for indicated MBT torque andindicated MBT torque all cylinders.\nSeconds");
MakeNameEx(0x0000A6B8, "ENG_TORQUE_KE_STALL_PROTECTION_DUTY_CYCLE", nameFlags);
MakeRptCmt(0x0000A6B8, "Duty cycle broadcast on the Delivered Torque PWM.\nPercent");
MakeNameEx(0x0000A6BA, "ENG_TORQUE_KE_AC_BUMP_SPARK_ENABLE", nameFlags);
MakeRptCmt(0x0000A6BA, "Enables spark for AC Bump logic when TRUE.\nBOOLEAN");
MakeNameEx(0x0000A6BC, "ENG_TORQUE_KE_AC_BUMP_CLUTCH_DELAY", nameFlags);
MakeRptCmt(0x0000A6BC, "Amount of time from AC_Commanded_On TRUE to when compressorload hits the engine.\nSeconds");
MakeNameEx(0x0000A6BE, "ENG_TORQUE_KE_AC_BUMP_TORQUE_RAMP_IN", nameFlags);
MakeRptCmt(0x0000A6BE, "The rate at which the torque is ramped in when the AC compressorclutch engages.\nFoot Pounds");
MakeNameEx(0x0000A6C0, "ENG_TORQUE_KE_AC_BUMP_TORQUE_RAMP_OUT", nameFlags);
MakeRptCmt(0x0000A6C0, "The rate at which the torque is ramped out when the AC compressorclutch disengages.\nFoot Pounds");
MakeNameEx(0x0000A6C2, "ENG_TORQUE_KE_AC_FLOW_OFFSET_DELTA", nameFlags);
MakeRptCmt(0x0000A6C2, "Any delta change in AC Flow Offset that is less than this amount, the variation correction cells will be reset.\nGrams per Second");
MakeNameEx(0x0000A6C4, "ENG_TORQUE_KE_AC_BUMP_SPARK_DURATION_LIMIT", nameFlags);
MakeRptCmt(0x0000A6C4, "Any non-zero AC_Bump_Torque value that persists for this amountof time will be set to zero.\nSeconds");
MakeNameEx(0x0000A6C6, "ENG_TORQUE_KE_TCS_SHIFT_DUTY_CYCLE", nameFlags);
MakeRptCmt(0x0000A6C6, "Duty cycle broadcast on the Delivered Torque PWM in the eventthat the PCM determines that a shift is in progress.\nPercent");
MakeNameEx(0x0000A6C8, "ENG_TORQUE_KE_TCS_DEL_TORQ_DUTY_CYCLE_LOW", nameFlags);
MakeRptCmt(0x0000A6C8, "Lowest duty cycle broadcast on the Delivered Torque PWM for normal conditions.\nPercent");
MakeNameEx(0x0000A6CA, "ENG_TORQUE_KE_ENGINE_SPEED_STALL", nameFlags);
MakeRptCmt(0x0000A6CA, "Engine speed below which stall protection mode will be enabledwhen TCS_Stall_Protection_Number is below a cal also.\nRPM");
MakeNameEx(0x0000A6CC, "ENG_TORQUE_KE_TCS_STALL_DELTA_GAIN", nameFlags);
MakeRptCmt(0x0000A6CC, "Gain on the derivative term for calculation ofTCS_Stall_Protection_Number.\nScaler 0-16");
MakeNameEx(0x0000A6CE, "ENG_TORQUE_KE_ENG_SPEED_STALL_ABSOLUTE_HI", nameFlags);
MakeNameEx(0x0000A6D0, "ENG_TORQUE_KE_ENG_SPEED_STALL_ABSOLUTE_LO", nameFlags);
MakeNameEx(0x0000A6D2, "ENG_TORQUE_KE_MIN_TORQUE_NORM", nameFlags);
MakeRptCmt(0x0000A6D2, "Used to calculate torque PWM minimum\nFraction -1_to_1");
MakeNameEx(0x0000A6D4, "ENG_TORQUE_KE_LCT_TRQ_MNG_FAIL_DUTY_CYCLE", nameFlags);
MakeNameEx(0x0000A6D6, "ENG_TORQUE_KV_AC_BUMP_CLUTCH_OFF_SPK_DLY", nameFlags);
MakeRptCmt(0x0000A6D6, "Time from KE_HLD_AC_AIR_OFF expiring until AC Bump_Spark Retard is ramped out.  F( AC_Torque_Adjusted ).\nSeconds");
MakeNameEx(0x0000A6F2, "ENG_TORQUE_KV_AC_INERTIA_TORQUE", nameFlags);
MakeRptCmt(0x0000A6F2, "The inertia Torque that compensates for the inertia load of the A/C Clutch. F( AC_Torque ).\nFt Pounds");
MakeNameEx(0x0000A70E, "ENG_TORQUE_KV_RAMP_INERTIA_AIRFLOW_OUT", nameFlags);
MakeRptCmt(0x0000A70E, "Amount of AC Inertia Torque air to ramp out per 12.5ms loop once KV_HLD_AC_AIR_ON timer expires. F( AC_Inertia_Torque ).\nGPS");
MakeNameEx(0x0000A730, "ENG_TORQUE_KE_AC_BUMP_SPARK_IDLE_OFF", nameFlags);
MakeRptCmt(0x0000A730, "When TRUE, bump spark will not be calculated at idle.\nBOOLEAN");
MakeNameEx(0x0000A732, "ENG_TORQUE_KV_HLD_AC_AIR_ON", nameFlags);
MakeRptCmt(0x0000A732, "Time to hold_AC_Inertia_Torque air following AC_Commanded_On is TRUE.  F( AC_Torque_Adjusted ).\nSeconds");
MakeNameEx(0x0000A74E, "ENG_TORQUE_KE_HLD_AC_AIR_OFF", nameFlags);
MakeRptCmt(0x0000A74E, "Time to hold AC_Torque contribution to CIA beforeramping down to CIA without AC Torque\nSeconds");
MakeNameEx(0x0000A750, "ETC_ENGINE_AIR_KV_ENG_ACCELERATION_THRESHOLD", nameFlags);
MakeRptCmt(0x0000A750, "Lookup for engine accel threshold above which lead governing isenabled as a function of engine speed.\nEngine_Accel_Type_Vs_RPM_Table");
MakeNameEx(0x0000A77A, "ETC_ENGINE_AIR_KV_ENGINE_SPEED_GOV_INT_GAIN", nameFlags);
MakeRptCmt(0x0000A77A, "Integral gain value for the PID engine speed governor indexed withEngine Speed Error.\nRPM_S_Vs_EngSpd_Int_Gain");
MakeNameEx(0x0000A7A4, "ETC_ENGINE_AIR_KV_ENG_SPEED_GOV_DERIVATIVE_GAIN", nameFlags);
MakeRptCmt(0x0000A7A4, "Derivative gain value for the PID engine speed governor indexed with Engine_Speed_Error.\nRPM_S_Vs_EngSpd_Deriv_Gain");
MakeNameEx(0x0000A7CE, "ETC_ENGINE_AIR_KV_ENGINE_SPEED_GOV_PROP_GAIN", nameFlags);
MakeRptCmt(0x0000A7CE, "Proportional gain value for the PID engine speed governor indexed with Engine_Speed_Error.\nRPM_S_Vs_EngSpd_Prop_Gain");
MakeNameEx(0x0000A7F8, "ETC_ENGINE_AIR_KV_VEH_SPEED_GOV_INT_GAIN", nameFlags);
MakeRptCmt(0x0000A7F8, "Integral gain value for the PID vehicle speed governor indexed withDesired_Throttle_Position.\nPercent_Vs_VehSpd_Int_Gain");
MakeNameEx(0x0000A7FE, "ETC_ENGINE_AIR_KV_VEH_SPEED_GOV_PROP_GAIN", nameFlags);
MakeRptCmt(0x0000A7FE, "Proportional gain value for the PID vehicle speed governor indexedwith Vehicle speed error.\nMPH_S_Vs_VehSpd_Prop_Gain");
MakeNameEx(0x0000A80E, "ETC_ENGINE_AIR_KV_VEH_ACCELERATION_THRESHOLD", nameFlags);
MakeRptCmt(0x0000A80E, "Vehicle accel threshold above which lead governing is enabled asa function of Vehicle_Acceleration_Error\nMPH_Per_300ms_S_Vs_MPH_Table");
MakeNameEx(0x0000A82E, "ETC_ENGINE_AIR_KV_ENG_SPEED_GOV_AREA_INITIAL", nameFlags);
MakeRptCmt(0x0000A82E, "Initial value used for throttle area if less than Desired_Throttle_Position.\nGear_Vs_Percent_Table");
MakeNameEx(0x0000A842, "ETC_ENGINE_AIR_KV_TRANS_STAB_GOV_AREA_INITIAL", nameFlags);
MakeRptCmt(0x0000A842, "Initial value used for throttle area if less than Desired_Throttle_Position and ETC Trans stablization is enabled.\nGear_Vs_Percent_Table");
MakeNameEx(0x0000A856, "ETC_ENGINE_AIR_KV_ENG_SPD_GOV_PID_DELAY_CNT", nameFlags);
MakeRptCmt(0x0000A856, "Specifies the number of control loops that the PID terms will be initialized upon activation of the engine speed governor.\nGear_Vs_Count_Table");
MakeNameEx(0x0000A860, "ETC_ENGINE_AIR_KE_ENG_SPD_GOV_EXIT_HYSTERESIS", nameFlags);
MakeRptCmt(0x0000A860, "Exit Engine speed gov when speed drops this amout below Engine_ Speed_Max_Limit and RPM_Gov is not the throt cmd source\nRPM");
MakeNameEx(0x0000A862, "ETC_ENGINE_AIR_KE_ENGINE_SPD_GOV_AREA_MIN", nameFlags);
MakeRptCmt(0x0000A862, "Lower clamp for engine speed governor speed area\nPercent");
MakeNameEx(0x0000A864, "ETC_ENGINE_AIR_KE_VEH_SPEED_GOV_AREA_INITIAL", nameFlags);
MakeRptCmt(0x0000A864, "Initial value used in lead mode if current throttle area is less than this calibration.\nPercent");
MakeNameEx(0x0000A866, "ETC_ENGINE_AIR_KE_VEH_SPEED_DERIVATIVE_GAIN", nameFlags);
MakeRptCmt(0x0000A866, "The gain coefficient in the Vehicle speed gov derivative term\nVehicle_Spd_Gain_Type");
MakeNameEx(0x0000A868, "ETC_ENGINE_AIR_KE_VEH_SPD_GOV_EXIT_HYSTERESIS", nameFlags);
MakeRptCmt(0x0000A868, "Exit vehicle speed gov when speed drops this amout below Vehicle_ Speed_Max_Limit and MPH_Gov is not the throt cmd source\nMPH");
MakeNameEx(0x0000A86A, "ETC_ENGINE_AIR_KE_VEHICLE_SPD_GOV_AREA_MIN", nameFlags);
MakeRptCmt(0x0000A86A, "Lower clamp for governor speed area\nPercent");
MakeNameEx(0x0000A86C, "ETC_ENGINE_AIR_KE_ACCEL_LOW_MPH_THRESHOLD", nameFlags);
MakeRptCmt(0x0000A86C, "Programmed acceleration low vehicle speed.\nMPH");
MakeNameEx(0x0000A86E, "ETC_ENGINE_AIR_KE_ACCEL_HIGH_MPH_THRESHOLD", nameFlags);
MakeRptCmt(0x0000A86E, "Programmed acceleration High vehicle speed.\nMPH");
MakeNameEx(0x0000A870, "ETC_ENGINE_AIR_KE_LOW_SPEED_ACCEL_RATE", nameFlags);
MakeRptCmt(0x0000A870, "Programmed acceleration low vehicle speed acceleration rate.\nMPH_Per_Second_S");
MakeNameEx(0x0000A872, "ETC_ENGINE_AIR_KE_MEDIUM_SPEED_ACCEL_RATE", nameFlags);
MakeRptCmt(0x0000A872, "Programmed acceleration Medium vehicle speed acceleration rate.\nMPH_Per_Second_S");
MakeNameEx(0x0000A874, "ETC_ENGINE_AIR_KE_HIGH_SPEED_ACCEL_RATE", nameFlags);
MakeRptCmt(0x0000A874, "Programmed acceleration High vehicle speed acceleration rate.\nMPH_Per_Second_S");
MakeNameEx(0x0000A876, "ETC_ENGINE_AIR_KE_ACCEL_GOVERNOR_PROPORTIONAL_G", nameFlags);
MakeRptCmt(0x0000A876, "Programmed acceleration proportional gain term.\nPercent_S");
MakeNameEx(0x0000A878, "ETC_ENGINE_AIR_KE_ACCEL_GOVERNOR_INTEGRAL_GAIN", nameFlags);
MakeRptCmt(0x0000A878, "Programmed acceleration integral gain term.\nVehicle_Accel_Int_Gain_Type");
MakeNameEx(0x0000A87A, "ETC_ENGINE_AIR_KE_LOW_SPEED_MAX_AREA", nameFlags);
MakeRptCmt(0x0000A87A, "Clamp for max throttle commanded when vehicle speed is too low\nPercent");
MakeNameEx(0x0000A87C, "ETC_ENGINE_AIR_KE_VEHICLE_SPEED_FILT_COEF", nameFlags);
MakeRptCmt(0x0000A87C, "Coefficient used to filter vehicle speed for core ETC algorithm\nCoefficient");
MakeNameEx(0x0000A87E, "ETC_ENGINE_AIR_KE_ENGINE_SPEED_GOV_ENABLED", nameFlags);
MakeRptCmt(0x0000A87E, "Used to prevent engine speed governor from executing.\nBOOLEAN");
MakeNameEx(0x0000A87F, "FUEL_KE_TWO_BANK_FUEL_CONTROL", nameFlags);
MakeRptCmt(0x0000A87F, "Used to determine if two bank fuel control is to be used or not.\nBOOLEAN");
MakeNameEx(0x0000A880, "ETC_PEDAL_KE_PEDAL_TRANSITION_INTERVAL", nameFlags);
MakeRptCmt(0x0000A880, "Time period for transitioning to reduced or failed performance\nSeconds");
MakeNameEx(0x0000A882, "ETC_PEDAL_KE_PEDAL_ROTATION_SCALER", nameFlags);
MakeRptCmt(0x0000A882, "Indicated pedal position to load scaler.\nScaler_4");
MakeNameEx(0x0000A884, "ETC_PEDAL_KE_RELAXED_PEDAL_DEADBAND", nameFlags);
MakeRptCmt(0x0000A884, "Deadband subrtracted from pedal position for pedal load\nPercent");
MakeNameEx(0x0000A886, "ETC_PEDAL_KV_PEDAL_AREA_REDUCED", nameFlags);
MakeRptCmt(0x0000A886, "Lookup reduced performance desired throttle area vs pedal load.\nPercent_Area_Vs_Percent_Table");
MakeNameEx(0x0000A8C8, "ETC_PEDAL_KV_PEDAL_HYSTERESIS", nameFlags);
MakeRptCmt(0x0000A8C8, "Lookup for hysteresis in indicated pedal position vs. position.\nPercent_Vs_Percent_Table");
MakeNameEx(0x0000A90A, "ETC_PEDAL_KE_BATTERY_SAVER_TIME", nameFlags);
MakeRptCmt(0x0000A90A, "Engine / Pedal inactivity time limit for battery saver enable.\nSeconds");
MakeNameEx(0x0000A90C, "ETC_PEDAL_KA_PEDAL_AREA_A", nameFlags);
MakeRptCmt(0x0000A90C, "Pedal area as a function of pedal rotation and altitude (baro).\nPercent Pedal Area");
MakeNameEx(0x0000ABA0, "ETC_PEDAL_KA_PEDAL_AREA_B", nameFlags);
MakeRptCmt(0x0000ABA0, "Pedal area as a function of pedal rotation and altitude (baro) with trailer mode engaged.\nPercent Pedal Area");
MakeNameEx(0x0000AE34, "ETC_R_PEDAL_KE_R_PEDAL_TRANSITION_INTERVAL", nameFlags);
MakeRptCmt(0x0000AE34, "REDUNDANT time period for transitioning to reduced or failed      performance\nR_Seconds");
MakeNameEx(0x0000AE38, "ETC_R_PEDAL_KE_R_PEDAL_ROTATION_SCALER", nameFlags);
MakeRptCmt(0x0000AE38, "REDUNDANT Indicated pedal position to Rotation scaler.\nR_Scaler_4");
MakeNameEx(0x0000AE3A, "ETC_R_PEDAL_KE_R_RELAXED_PEDAL_DEADBAND", nameFlags);
MakeRptCmt(0x0000AE3A, "REDUNDANT Deadband subrtracted from pedal position for the pedal load\nR_Percent");
MakeNameEx(0x0000AE3C, "ETC_R_PEDAL_KV_R_PEDAL_AREA_REDUCED", nameFlags);
MakeRptCmt(0x0000AE3C, "REDUNDANT Lookup reduced performance desired throttle area vs  pedal load.\nR_Percent_Area_Vs_R_Percnt_Table");
MakeNameEx(0x0000AE7E, "ETC_R_PEDAL_KV_R_PEDAL_HYSTERESIS", nameFlags);
MakeRptCmt(0x0000AE7E, "REDUNDANT Lookup for hysteresis in indicated pedal position vs.  position.\nR_Percent_Vs_R_Percent_Table");
MakeNameEx(0x0000AEC0, "ETC_R_PEDAL_KA_R_PEDAL_AREA_A", nameFlags);
MakeRptCmt(0x0000AEC0, "REDUNDANT Pedal area as a function of altitude (baro).\nPercent Pedal Area");
MakeNameEx(0x0000B154, "ETC_R_PEDAL_KA_R_PEDAL_AREA_B", nameFlags);
MakeRptCmt(0x0000B154, "REDUNDANT Pedal area as a function of altitude (baro) with trailer mode engaged.\nPercent Pedal Area");
MakeNameEx(0x0000B3E8, "ETC_R_THROTTLE_KV_R_THROTTLE_ROTATION", nameFlags);
MakeRptCmt(0x0000B3E8, "REDUNDANT throttle area to throttle angle conversion table.\nR_Rotation_Vs_Area_Table");
MakeNameEx(0x0000B476, "ETC_R_THROTTLE_KV_R_MAX_THROTTLE_POSITION", nameFlags);
MakeRptCmt(0x0000B476, "REDUNDANT Max permitted Throttle angle vs RPM for reduced induction noise and improves transient response without losing power.\nR_Rotation_Vs_RPM_Table");
MakeNameEx(0x0000B498, "ETC_R_THROTTLE_KV_R_MAX_ALLOWED_NORMAL_THROTTLE", nameFlags);
MakeRptCmt(0x0000B498, "REDUNDANT max permitted Throttle angle vs indicated pedal position in normal operating modes.\nR_Rotation_Vs_Percent_By10_Table");
MakeNameEx(0x0000B4AE, "ETC_R_THROTTLE_KE_R_MAX_IDLE_AREA", nameFlags);
MakeRptCmt(0x0000B4AE, "REDUNDANT Maximum idle area contribution allowed for ETC\nR_Percent Area_Area");
MakeNameEx(0x0000B4B0, "ETC_R_THROTTLE_KE_R_MAX_MIN_TORQUE_AUTHORITY", nameFlags);
MakeRptCmt(0x0000B4B0, "REDUNDANT limit the authority of drop throttle to command the  throttle\nR_Percent_Area");
MakeNameEx(0x0000B4B2, "ETC_R_THROTTLE_KE_R_MAX_DRAG_THROTTLE_POSITION", nameFlags);
MakeRptCmt(0x0000B4B2, "REDUNDANTMaximum throttle position that Drag control can command\nR_Pedal_Rotation");
MakeNameEx(0x0000B4B4, "ETC_R_THROTTLE_KE_R_MAX_IDLE_THROTTLE_POSITION", nameFlags);
MakeRptCmt(0x0000B4B4, "Maximum throttle position that idle control can command.\nR_Pedal_Rotation");
MakeNameEx(0x0000B4B6, "ETC_R_THROTTLE_KE_R_LIMITED_POWER_MAX_THROT_POS", nameFlags);
MakeRptCmt(0x0000B4B6, "Maximum throttle position that limited power mode is allowed.\nR_Pedal_Rotation");
MakeNameEx(0x0000B4B8, "ETC_R_THROTTLE_KE_R_THROTTLE_STOP_MIN_SW", nameFlags);
MakeRptCmt(0x0000B4B8, "Min value to prevent throttle from reaching the mechanicalstop\nR_Percent_Rotation");
MakeNameEx(0x0000B4BA, "ETC_R_THROTTLE_KE_R_THROTTLE_STOP_MAX_SW", nameFlags);
MakeRptCmt(0x0000B4BA, "Max value to prevent throttle from reaching the mechanicalstop\nR_Percent_Rotation");
MakeNameEx(0x0000B4BC, "ETC_R_THROTTLE_KE_R_MIN_MECHANICAL_POSITION_AR", nameFlags);
MakeRptCmt(0x0000B4BC, "Used to rescale des throttle area unfiltered to account for themechanical stop for area to rotation conversion lookups\nR_Percent_Area");
MakeNameEx(0x0000B4BE, "ETC_R_THROTTLE_KE_R_THROTTLE_HI_LIMIT_PERIOD", nameFlags);
MakeRptCmt(0x0000B4BE, "Number of 18.75 ms loops that the throttle position can be abovethe max allowed throttle position.\nR_SHORTCARD");
MakeNameEx(0x0000B4C0, "ETC_R_THROTTLE_KE_R_DELTA_MAX_ALLOW_THROT_LIMIT", nameFlags);
MakeRptCmt(0x0000B4C0, "The maximum allowed desired throttle delta between current and previous loop.\nR_Percent_Rotation");
MakeNameEx(0x0000B4C2, "ETC_SERIAL_DATA_KE_TPS_WOT_10BIT_EQUIVALENT", nameFlags);
MakeRptCmt(0x0000B4C2, "Value representing max software stop and would also be defined as 100% throttle position\nRaw_10_Bit_AD_Type");
MakeNameEx(0x0000B4C4, "ETC_SERIAL_DATA_KE_MAX_PPS_IND", nameFlags);
MakeRptCmt(0x0000B4C4, "Value representing max software stop and would also be defined as 100% pedal position\nRaw_10_Bit_AD_Type");
MakeNameEx(0x0000B4C6, "ETC_SERIAL_DATA_KA_ETC_PM_TORQUE", nameFlags);
MakeRptCmt(0x0000B4C6, "Lookup of power management torque based on desired throttle  position and engine speed\nFoot_Pounds_S");
MakeNameEx(0x0000B58C, "ETC_SERIAL_DATA_KE_ETC_LOW_VOLTAGE_THRESHOLD", nameFlags);
MakeRptCmt(0x0000B58C, "Voltage at which the smart pedal/actuator will not function.\nVolts");
MakeNameEx(0x0000B58E, "ETC_SERIAL_DATA_KE_SHUTDOWN_VACUUM_TOO_LOW", nameFlags);
MakeRptCmt(0x0000B58E, "Vacuum level at which braking ability may be inadequate to stop  the vehicle\nkPa");
MakeNameEx(0x0000B590, "ETC_SERIAL_DATA_KE_SHUTDOWN_VACUUM_TOO_LOW_TIME", nameFlags);
MakeRptCmt(0x0000B590, "Time limit that Vacuum level can be low at which power management can be entered if in limited authority.\nSeconds");
MakeNameEx(0x0000B592, "ETC_SERIAL_DATA_KE_IND_THROTTLE_POSITION_SCALER", nameFlags);
MakeRptCmt(0x0000B592, "Scaler to convert the ETM indicated throttle position in units of counts, to units of percent rotation\nScaler 0 to 4");
MakeNameEx(0x0000B594, "ETC_SERIAL_DATA_KE_TACM_CLEAR_CODES_TIMER_1", nameFlags);
MakeRptCmt(0x0000B594, "Time limit that TPS codes will be masked at low voltage after  engine starts.\nSeconds");
MakeNameEx(0x0000B596, "ETC_SERIAL_DATA_KE_TACM_FAULT_INHIBIT_MAX_VOLT", nameFlags);
MakeRptCmt(0x0000B596, "Upper voltage below which TPS Faults are masked if the engine  is not running.\nVolts");
MakeNameEx(0x0000B598, "ETC_SERIAL_DATA_KE_TACM_FAULT_INHIBIT_MIN_VOLT", nameFlags);
MakeRptCmt(0x0000B598, "Lower voltage above which TPS Faults are masked if the engine  is not running.\nVolts");
MakeNameEx(0x0000B59A, "ETC_THROT_KV_THROTTLE_LOAD", nameFlags);
MakeRptCmt(0x0000B59A, "Throttle area to pseudo throttle position conversion table.\nPercent_Vs_Percent_Area_Table");
MakeNameEx(0x0000B5DC, "ETC_THROT_KV_THROTTLE_ROTATION", nameFlags);
MakeRptCmt(0x0000B5DC, "Throttle area to throttle rotation conversion table.\nRotation_Vs_Percent_Area_Table");
MakeNameEx(0x0000B66A, "ETC_THROT_KV_MAX_THROTTLE_POSITION", nameFlags);
MakeRptCmt(0x0000B66A, "Max permitted Throttle angle vs RPM.  Provides reduced induction noise and improves transient response without losing power.\nRotation_Vs_RPM_Table");
MakeNameEx(0x0000B68C, "ETC_THROT_KV_MAX_ALLOWED_NORMAL_THROTTLE", nameFlags);
MakeRptCmt(0x0000B68C, "Max permitted Throttle angle vs indicated pedal position in normal operating modes.\nRotation_Vs_Percent_By10_Table");
MakeNameEx(0x0000B6A2, "ETC_THROT_KV_THROT_SLEW_INCR_1ST_GEAR", nameFlags);
MakeRptCmt(0x0000B6A2, "Lookup of Increasing Throttle Slew Rate in Degrees Per Engine Revolution for manual trans. in 1st gear.\nDegrees_Per_Revolution");
MakeNameEx(0x0000B6C4, "ETC_THROT_KV_THROT_SLEW_INCR_2ND_GEAR", nameFlags);
MakeRptCmt(0x0000B6C4, "Lookup of Increasing Throttle Slew Rate in Degrees Per Engine Revolution for manual trans. in 2nd gear.\nDegrees_Per_Revolution");
MakeNameEx(0x0000B6E6, "ETC_THROT_KV_THROT_SLEW_INCR_3RD_GEAR", nameFlags);
MakeRptCmt(0x0000B6E6, "Lookup of Increasing Throttle Slew Rate in Degrees Per Engine Revolution for manual trans. in 3rd gear.\nDegrees_Per_Revolution");
MakeNameEx(0x0000B708, "ETC_THROT_KV_THROT_SLEW_INCR_4TH_GEAR", nameFlags);
MakeRptCmt(0x0000B708, "Lookup of Increasing Throttle Slew Rate in Degrees Per Engine Revolution for manual trans. in 4th gear.\nDegrees_Per_Revolution");
MakeNameEx(0x0000B72A, "ETC_THROT_KV_THROT_SLEW_INCR_5TH_GEAR", nameFlags);
MakeRptCmt(0x0000B72A, "Lookup of Increasing Throttle Slew Rate in Degrees Per Engine Revolution for manual trans. in 5th gear.\nDegrees_Per_Revolution");
MakeNameEx(0x0000B74C, "ETC_THROT_KV_THROT_SLEW_INCR_6TH_GEAR", nameFlags);
MakeRptCmt(0x0000B74C, "Lookup of Increasing Throttle Slew Rate in Degrees Per Engine Revolution for manual trans. in 6th gear.\nDegrees_Per_Revolution");
MakeNameEx(0x0000B76E, "ETC_THROT_KE_MIN_SLEW_RPM_1ST_GEAR", nameFlags);
MakeNameEx(0x0000B770, "ETC_THROT_KE_MIN_SLEW_RPM_2ND_GEAR", nameFlags);
MakeNameEx(0x0000B772, "ETC_THROT_KE_MIN_SLEW_RPM_3RD_GEAR", nameFlags);
MakeNameEx(0x0000B774, "ETC_THROT_KE_MIN_SLEW_RPM_4TH_GEAR", nameFlags);
MakeNameEx(0x0000B776, "ETC_THROT_KE_MIN_SLEW_RPM_5TH_GEAR", nameFlags);
MakeNameEx(0x0000B778, "ETC_THROT_KE_MIN_SLEW_RPM_6TH_GEAR", nameFlags);
MakeRptCmt(0x0000B778, "Min engine RPM for converting the max throttle angle per manuals.\nRPM");
MakeNameEx(0x0000B77A, "ETC_THROT_KE_MAX_IDLE_AREA", nameFlags);
MakeRptCmt(0x0000B77A, "Maximum idle area contribution allowed for ETC\nPercent_Area");
MakeNameEx(0x0000B77C, "ETC_THROT_KE_DRAG_CNTL_ACCEL_TOO_HI_TIME", nameFlags);
MakeRptCmt(0x0000B77C, "Time limit vehicle accel is allowed to be above an accel forprior to limiting the drag control function.\nSeconds");
MakeNameEx(0x0000B77E, "ETC_THROT_KE_DRAG_CNTL_ACCEL_TOO_HIGH", nameFlags);
MakeRptCmt(0x0000B77E, "limit on vehicle accel rate during which any drag controlfeature is allowed to be active.\nMPH_Per_300ms");
MakeNameEx(0x0000B780, "ETC_THROT_KE_MAX_MIN_TORQUE_AUTHORITY", nameFlags);
MakeRptCmt(0x0000B780, "Limit the authority of drop throttle to command the throttle\nPercent_Area");
MakeNameEx(0x0000B782, "ETC_THROT_KE_MIN_SLEW_RPM", nameFlags);
MakeRptCmt(0x0000B782, "Minimum engine speed for converting the max throttle angle per engine rev into an angle change per software loop.\nRPM");
MakeNameEx(0x0000B784, "ETC_THROT_KE_THROTTLE_SLEW_INCREASE", nameFlags);
MakeRptCmt(0x0000B784, "Maximum permitted throttle angle change per engine rev when thethrottle is opening.\nPercent_Rotation_Per_Rev");
MakeNameEx(0x0000B786, "ETC_THROT_KE_THROTTLE_SLEW_DECREASE", nameFlags);
MakeRptCmt(0x0000B786, "Maximum permitted throttle angle change per engine rev when thethrottle is closing.\nPercent_Rotation_Per_Rev");
MakeNameEx(0x0000B788, "ETC_THROT_KE_MAX_DRAG_THROTTLE_POSITION", nameFlags);
MakeRptCmt(0x0000B788, "Maximum throttle position that Drag control can command.\nPedal_Rotation");
MakeNameEx(0x0000B78A, "ETC_THROT_KE_MAX_IDLE_THROTTLE_POSITION", nameFlags);
MakeRptCmt(0x0000B78A, "Maximum throttle position that idle control can command.\nPedal_Rotation");
MakeNameEx(0x0000B78C, "ETC_THROT_KE_LIMITED_POWER_MAX_THROT_POS", nameFlags);
MakeRptCmt(0x0000B78C, "Maximum throttle position that limited power mode is allowed.\nPedal_Rotation");
MakeNameEx(0x0000B78E, "ETC_THROT_KE_THROTTLE_STOP_MIN_SW", nameFlags);
MakeRptCmt(0x0000B78E, "Min value to prevent throttle from reaching the mechanicalstop\nPercent_Rotation");
MakeNameEx(0x0000B790, "ETC_THROT_KE_THROTTLE_STOP_MAX_SW", nameFlags);
MakeRptCmt(0x0000B790, "Max value to prevent throttle from reaching the mechanicalstop\nPercent_Rotation");
MakeNameEx(0x0000B792, "ETC_THROT_KE_MIN_MECHANICAL_POSITION_AREA", nameFlags);
MakeRptCmt(0x0000B792, "Used to rescale des throttle area unfiltered to account for themechanical stop for area to rotation conversion lookups\nPercent_Area");
MakeNameEx(0x0000B794, "ETC_THROT_KE_THROTTLE_HI_LIMIT_PERIOD", nameFlags);
MakeRptCmt(0x0000B794, "Number of 18.75 ms loops that the throttle position can be abovethe max allowed throttle position.\nSHORTCARD");
MakeNameEx(0x0000B795, "ETC_THROT_KE_TRANS_DESIRED_THROTTLE_LOAD", nameFlags);
MakeRptCmt(0x0000B795, "Determines where in the throttle arbitration process the transload is obtained.\nThrottle_Load_Selector_Type");
MakeNameEx(0x0000B796, "ETC_THROT_KE_4WD_LO_THROTTLE_PROG_ENABLE", nameFlags);
MakeNameEx(0x0000B798, "ETC_THROT_KV_INCLUDE_THROT_SRC_IN_TPS_LOAD", nameFlags);
MakeRptCmt(0x0000B798, "Determines which throttle sources will be included in the transmission throttle position load parameter.\nBOOLEAN");
MakeNameEx(0x0000B7A0, "ETC_THROT_KE_DELTA_MAX_ALLOWED_THROT_LIMIT", nameFlags);
MakeRptCmt(0x0000B7A0, "Maximum allowed desired throttle delta between current and previous execution loop.\nPercent Rotation");
MakeNameEx(0x0000B7A2, "ETC_THROT_KE_MAX_STAT_PTO_MPH", nameFlags);
MakeRptCmt(0x0000B7A2, "ETC PTO safety gate. Stationary PTO is disabled if vehicle speed is >= this value.\nMPH");
MakeNameEx(0x0000B7A4, "ETC_THROT_KE_MAX_MOBILE_PTO_MPH", nameFlags);
MakeRptCmt(0x0000B7A4, "ETC PTO safety gate. Mobile PTO is disabled if vehicle speed is >= this value.\nMPH");
MakeNameEx(0x0000B7A6, "ETC_DATA_LOGGER_KE_ETC_FLIGHT_RECORD_SPEED_COEF", nameFlags);
MakeRptCmt(0x0000B7A6, "Coefficient used to filter vehicle speed for ETC Datalogger.\nCoefficient");
MakeNameEx(0x0000B7A8, "ETC_DATA_LOGGER_KE_TRIGGER_VALIDITY_PERIOD", nameFlags);
MakeRptCmt(0x0000B7A8, "Delay before Trigger validation period expires\nSeconds");
MakeNameEx(0x0000B7AA, "ETC_DATA_LOGGER_KE_DECEL_TRIGGER_THRESHOLD", nameFlags);
MakeRptCmt(0x0000B7AA, "Maximum deceleration threshold FOR triggering flight recorder\nMPH_Per_300ms_S");
MakeNameEx(0x0000B7AC, "FUEL_COMPOSITION_KE_FLEX_FUEL_EQUIPPED", nameFlags);
MakeRptCmt(0x0000B7AC, "Indicates that vehicle is flex fuel capable.\nTRUE/FALSE");
MakeNameEx(0x0000B7AE, "FUEL_COMPOSITION_KE_FFS_COMP_CHANGE_THRESH", nameFlags);
MakeRptCmt(0x0000B7AE, "Minimum fuel composition change to initiate an update of the filtered fuel composition.\nPercent");
MakeNameEx(0x0000B7B0, "FUEL_COMPOSITION_KE_FFS_COMP_DELAY_VOLUME", nameFlags);
MakeRptCmt(0x0000B7B0, "Volume of fuel to be consumed by the engine before a new fuel composition reaches the injector rail.\nLiters");
MakeNameEx(0x0000B7B2, "FUEL_COMPOSITION_KE_FFS_COMP_TRANSITION_VOLUME", nameFlags);
MakeRptCmt(0x0000B7B2, "Volume of fuel consumed by the engine during which the transition occurs from the old fuel composition to a new one.\nLiters");
MakeNameEx(0x0000B7B4, "FUEL_COMPOSITION_KE_FFS_COMPOSITION_DEFAULT", nameFlags);
MakeRptCmt(0x0000B7B4, "Value to be used when fuel composition can not otherwise be determined.\nPercent");
MakeNameEx(0x0000B7B6, "FUEL_COMPOSITION_KE_FFS_0PCT_ALCOHOL_FREQUENCY", nameFlags);
MakeRptCmt(0x0000B7B6, "Frequency of the FFS PWM input corresponding to 0% alcohol.\nHertz");
MakeNameEx(0x0000B7B8, "FUEL_COMPOSITION_KE_FFS_COMPOSITION_SLOPE", nameFlags);
MakeRptCmt(0x0000B7B8, "Proportional constant for determining fuel composition from the frequency of the FFS PWM input.\nScaler_16_S");
MakeNameEx(0x0000B7BA, "FUEL_COMPOSITION_KE_FFS_MIN_TEMPERATURE", nameFlags);
MakeRptCmt(0x0000B7BA, "Minimum temperature value measured by the Flex Fuel Sensor.\nDegrees_C");
MakeNameEx(0x0000B7BC, "FUEL_COMPOSITION_KE_FFS_MAX_TEMPERATURE", nameFlags);
MakeRptCmt(0x0000B7BC, "Maximum temperature value measured by the Flex Fuel Sensor.\nDegrees_C");
MakeNameEx(0x0000B7BE, "FUEL_COMPOSITION_KE_FFS_MIN_TEMP_LOW_TIME", nameFlags);
MakeRptCmt(0x0000B7BE, "Low time of FFS input PWM corresponding to the minimum temperature value measured by the Flex Fuel Sensor.\nMilliseconds");
MakeNameEx(0x0000B7C0, "FUEL_COMPOSITION_KE_FFS_TEMPERATURE_SLOPE", nameFlags);
MakeRptCmt(0x0000B7C0, "Proportional constant for determining fuel temperature from the low time of the Flex Fuel Sensor PWM input.\nMultiplier_-+_1000");
MakeNameEx(0x0000B7C2, "FUEL_CRANK_KV_FUEL_BARO_GAIN", nameFlags);
MakeRptCmt(0x0000B7C2, "Gain applied to account for air density charges with barometric pressure.\nNONE 0-2");
MakeNameEx(0x0000B7CC, "FUEL_CRANK_KV_FUEL_PRESSURE_DELAY", nameFlags);
MakeRptCmt(0x0000B7CC, "Amount of time to delay after powerup before allowing key on prime pulse to be delivered.\nSeconds");
MakeNameEx(0x0000B7EC, "FUEL_CRANK_KV_OCTIFIRE2_SOAKTIMER_MODIFIER", nameFlags);
MakeRptCmt(0x0000B7EC, "A modifier to Second_Octifire_Prime based on soaktimerif enabled.\nNONE 0_2");
MakeNameEx(0x0000B826, "FUEL_CRANK_KV_PRIME_PULSE_MASS", nameFlags);
MakeRptCmt(0x0000B826, "This is the mass of fuel to be injected on the first simultaneous, nonsynchronous (Prime) injection.\nGrams");
MakeNameEx(0x0000B846, "FUEL_CRANK_KV_FIRST_PULSE_MASS", nameFlags);
MakeRptCmt(0x0000B846, "This is the mass of fuel to be injected on the first simultaneous, synchronous (octifire) injection.\nGrams");
MakeNameEx(0x0000B866, "FUEL_CRANK_KV_SECOND_PULSE_MASS", nameFlags);
MakeNameEx(0x0000B886, "FUEL_CRANK_KV_FIRST_OCTIFIRE_REF_COUNT", nameFlags);
MakeNameEx(0x0000B896, "FUEL_CRANK_KV_SECOND_OCTIFIRE_REF_OFFSET", nameFlags);
MakeNameEx(0x0000B8A6, "FUEL_CRANK_KV_PRIME_MIN_RUN_TIME", nameFlags);
MakeRptCmt(0x0000B8A6, "This is the minimum engine run time required to allow a prime pulse to issued.\nSeconds");
MakeNameEx(0x0000B8C6, "FUEL_CRANK_KE_PRIME_FUEL_ENG_SPEED_DISABLE", nameFlags);
MakeNameEx(0x0000B8C8, "FUEL_CRANK_KE_USE_FUEL_PUMP_DEVELOPMENT_SW", nameFlags);
MakeRptCmt(0x0000B8C8, "If TRUE look at Pin J1-52 to check if FP dev switch is open, if so don't deliver prime pulse.\nBOOLEAN");
MakeNameEx(0x0000B8CA, "FUEL_CRANK_KE_SOAKTIMER_ENG_RUNTIME_LIMIT", nameFlags);
MakeNameEx(0x0000B8CE, "FUEL_CRANK_KE_SOAKTIMER_COOLANT_LIMIT", nameFlags);
MakeNameEx(0x0000B8D0, "FUEL_CRANK_KE_KEY_ON_PRIME_REENABLE_TIME", nameFlags);
MakeRptCmt(0x0000B8D0, "Key-on Prime is delivered if the previous key-on primedelivered was at least this time ago which is based onthe soak timer.\nSeconds");
MakeNameEx(0x0000B8D4, "FUEL_CRANK_KV_KEY_ON_SOAKTIMER_MODIFIER", nameFlags);
MakeRptCmt(0x0000B8D4, "A modifier to Key_On_Prime based on soaktimer if enabled.\nNONE 0_2");
MakeNameEx(0x0000B90E, "FUEL_CRANK_KV_OCTIFIRE1_SOAKTIMER_MODIFIER", nameFlags);
MakeRptCmt(0x0000B90E, "A modifier to First_Octifire_Prime based on soaktimerif enabled.\nNONE 0_2");
MakeNameEx(0x0000B948, "FUEL_CRANK_KA_FFS_COMPOSITION_GAIN", nameFlags);
MakeRptCmt(0x0000B948, "Gain applied to account for changes due to fuel alcohol composition\nMult 0 to 4");
MakeNameEx(0x0000BA06, "FUEL_CRANK_KE_CRANK_SEQUENTIAL_COOLANT_ENAB", nameFlags);
MakeRptCmt(0x0000BA06, "Enable sequential fueling during crank when coolant temperature is less than this calibration.\nDegrees_C");
MakeNameEx(0x0000BA08, "FUEL_CU_KE_CLUTCH_DFCO_SPK_EXIT_RATE", nameFlags);
MakeRptCmt(0x0000BA08, "Determines ramp rate of spark advance during exit of aclutch-based DFCO event.\nDegrees");
MakeNameEx(0x0000BA0A, "FUEL_CU_KE_DFCO_SPK_CONTINUE_REF_COUNT", nameFlags);
MakeRptCmt(0x0000BA0A, "Number of low res. reference pulse counts to hold continue spark after DFCO exit.\nCounts");
MakeNameEx(0x0000BA0C, "FUEL_CU_KE_DFCO_SPK_CONTINUE_TPS_HIGH", nameFlags);
MakeRptCmt(0x0000BA0C, "Throttle position high limit for usage of DFCO continue spark.\nPercent");
MakeNameEx(0x0000BA0E, "FUEL_CU_KE_DFCO_SPK_CONTINUE_TPS_LOW", nameFlags);
MakeRptCmt(0x0000BA0E, "Throttle position Low limit for usage of DFCO continue spark.\nPercent");
MakeNameEx(0x0000BA10, "FUEL_CU_KE_DFCO_SPK_DISABLED_HOLD_REF", nameFlags);
MakeNameEx(0x0000BA11, "FUEL_CU_KE_DFCO_SPK_INTERRUPTED_RAMP", nameFlags);
MakeNameEx(0x0000BA12, "FUEL_CU_KV_DFCO_SPK_CONTINUE_SPARK_HIGH", nameFlags);
MakeRptCmt(0x0000BA12, "If throttle position is above the high threshold, then this cal. is used for DFCO continue spark.\nDegrees");
MakeNameEx(0x0000BA3C, "FUEL_CU_KV_DFCO_SPK_CONTINUE_SPARK_LOW", nameFlags);
MakeRptCmt(0x0000BA3C, "If throttle position is below the low threshold, then this cal. is used for DFCO continue spark.\nDegrees");
MakeNameEx(0x0000BA66, "FUEL_CU_KV_DFCO_SPK_EXIT_RAMP_RATE", nameFlags);
MakeRptCmt(0x0000BA66, "This calibration establishes the rate in which Net Spark Advance will increase during DFCO exit.\nDegrees");
MakeNameEx(0x0000BA88, "FUEL_CU_KV_DFCO_SPK_HOLD_SPARK", nameFlags);
MakeRptCmt(0x0000BA88, "Net Spark advance during DFCO after the ramp is completed.\nDegrees");
MakeNameEx(0x0000BAB2, "FUEL_CU_KV_DFCO_SPK_ENTRY_RAMP_RATE", nameFlags);
MakeRptCmt(0x0000BAB2, "This calibration establishes the rate in which Net Spark Advance will decrease during DFCO.\nMultiplier_0_to_1");
MakeNameEx(0x0000BADC, "FUEL_CU_KE_STALL_ENGINE_SPEED", nameFlags);
MakeRptCmt(0x0000BADC, "Min engine speed in which fuel cutoff is still allowed.  Lowerspeeds than this may result in a stall.\nRPM");
MakeNameEx(0x0000BADE, "FUEL_CU_KE_ENGINE_OVERSPEED_TIME", nameFlags);
MakeRptCmt(0x0000BADE, "The time that engine speed must exceed the calibratible threshold before fuel is shut off.\nSeconds");
MakeNameEx(0x0000BAE0, "FUEL_CU_KE_PN_ENGINE_OVERSPEED_HIGH", nameFlags);
MakeRptCmt(0x0000BAE0, "This is the Engine Speed above which fuel is shutoff if the transmission is in park or neutral.\nRPM");
MakeNameEx(0x0000BAE2, "FUEL_CU_KE_PN_ENGINE_OVERSPEED_LOW", nameFlags);
MakeRptCmt(0x0000BAE2, "Engine Speed must fall below this limit before allowing fuel to be turned back on if the transmission is in park or neutral.\nRPM");
MakeNameEx(0x0000BAE4, "FUEL_CU_KE_ENG_OVERSPEED_VSS_FAIL_HIGH", nameFlags);
MakeRptCmt(0x0000BAE4, "Eng speed above which fuel is shutoff if a VSS failure existsUsed for chassis protection on med duty trucks\nRPM");
MakeNameEx(0x0000BAE6, "FUEL_CU_KE_ENG_OVERSPEED_VSS_FAIL_LOW", nameFlags);
MakeRptCmt(0x0000BAE6, "Eng speed must fall below before fuel is turned on if a VSS failureexists.  Used for chassis protection on med duty trucks\nRPM");
MakeNameEx(0x0000BAE8, "FUEL_CU_KV_ENGINE_OVERSPEED_HIGH", nameFlags);
MakeNameEx(0x0000BAFC, "FUEL_CU_KV_ENGINE_OVERSPEED_LOW", nameFlags);
MakeRptCmt(0x0000BAFC, "This is the calibration that the engine speed must fall below before allowing fuel to be turned back on.\nRPM");
MakeNameEx(0x0000BB10, "FUEL_CU_KE_LOW_RPM_FUEL_CUTOFF_HIGH", nameFlags);
MakeRptCmt(0x0000BB10, "Turn fuel on above this RPM if fuel is currently turned off due to low RPM.\nRPM");
MakeNameEx(0x0000BB12, "FUEL_CU_KE_LOW_RPM_FUEL_CUTOFF_LOW", nameFlags);
MakeRptCmt(0x0000BB12, "Turn fuel off below this RPM if fuel is the engine speed has been above KE_Low_RPM_Fuel_Cutoff_High.\nRPM");
MakeNameEx(0x0000BB14, "FUEL_CU_KV_COLD_ENGINE_PROTECTION_TIME", nameFlags);
MakeRptCmt(0x0000BB14, "Amount of time that cold engine protection should be enabled\nSeconds");
MakeNameEx(0x0000BB34, "FUEL_CU_KE_CLUTCH_DFCO_ENTRY_DELAY", nameFlags);
MakeRptCmt(0x0000BB34, "Clutch-based DFCO enabling conditions must exist continuously for this long to enable clutch-based DFCO.\nSeconds");
MakeNameEx(0x0000BB36, "FUEL_CU_KE_CLUTCH_DFCO_EXIT_TPS_INCREASE", nameFlags);
MakeRptCmt(0x0000BB36, "Exit clutch-based DFCO if throttle position increases by more than this amount over a 25 mS interval.\nPercent");
MakeNameEx(0x0000BB38, "FUEL_CU_KE_CLUTCH_DFCO_HOLD_TIME", nameFlags);
MakeRptCmt(0x0000BB38, "The duration of a clutch-based DFCO event.\nSeconds");
MakeNameEx(0x0000BB3A, "FUEL_CU_KE_CLUTCH_THROTTLE_DECREASE", nameFlags);
MakeNameEx(0x0000BB3C, "FUEL_CU_KE_CLUTCH_DFCO_REENABLE_DELAY", nameFlags);
MakeRptCmt(0x0000BB3C, "Minimum amount of time between clutch-based DFCO events.\nSeconds");
MakeNameEx(0x0000BB3E, "FUEL_CU_KE_CLUTCH_THROTTLE_WINDOW", nameFlags);
MakeRptCmt(0x0000BB3E, "Window of time either before or after the clutch pedal is depressed when a throttle decrease indicates a shift maneuver.\nSeconds");
MakeNameEx(0x0000BB40, "FUEL_CU_KE_DFCO_REENTRY_DELAY", nameFlags);
MakeRptCmt(0x0000BB40, "Amount of time to disable DFCO from becoming active after exiting DFCO.\nSeconds");
MakeNameEx(0x0000BB42, "FUEL_CU_KE_CLUTCH_DFCO_COOLANT_TEMP", nameFlags);
MakeRptCmt(0x0000BB42, "Minimum coolant temperature to enable clutch-based DFCO.\nDegrees_C");
MakeNameEx(0x0000BB44, "FUEL_CU_KE_CLUTCH_DFCO_ENGINE_SPEED", nameFlags);
MakeRptCmt(0x0000BB44, "Minimum engine speed to enable clutch-based DFCO.\nRPM");
MakeNameEx(0x0000BB46, "FUEL_CU_KE_CLUTCH_DFCO_MAP", nameFlags);
MakeRptCmt(0x0000BB46, "Maximum manifold pressure to enable clutch-based DFCO.\nkPa");
MakeNameEx(0x0000BB48, "FUEL_CU_KE_CLUTCH_DFCO_THROTTLE_POSITION", nameFlags);
MakeRptCmt(0x0000BB48, "Maximum throttle position to enable clutch-based DFCO.\nPercent");
MakeNameEx(0x0000BB4A, "FUEL_CU_KE_CLUTCH_DFCO_VEHICLE_SPEED", nameFlags);
MakeRptCmt(0x0000BB4A, "Minimum vehicle speed to enable clutch-based DFCO.\nMPH");
MakeNameEx(0x0000BB4C, "FUEL_CU_KE_DFCO_COOLANT_TEMPERATURE", nameFlags);
MakeRptCmt(0x0000BB4C, "Minimum coolant to enable DFCO.\nDegrees_C");
MakeNameEx(0x0000BB4E, "FUEL_CU_KE_DFCO_THROTTLE_HYSTERESIS", nameFlags);
MakeRptCmt(0x0000BB4E, "Throttle must be < (KV_DFCO_Throttle_Position + this) to keep DFCO enabled.\nPercent");
MakeNameEx(0x0000BB50, "FUEL_CU_KE_DFCO_VEH_SPEED_HYSTERESIS", nameFlags);
MakeRptCmt(0x0000BB50, "Hysteresis on vehicle speed during DFCO wait timer\nMPH");
MakeNameEx(0x0000BB52, "FUEL_CU_KE_DFCO_ENGINE_SPEED_HYSTERESIS", nameFlags);
MakeNameEx(0x0000BB54, "FUEL_CU_KE_DFCO_MANIFOLD_PRESSURE_HYSTER", nameFlags);
MakeNameEx(0x0000BB56, "FUEL_CU_KV_DFCO_VEHICLE_SPEED", nameFlags);
MakeRptCmt(0x0000BB56, "Vehicle speed must be > this to enable DFCO.\nMPH");
MakeNameEx(0x0000BB60, "FUEL_CU_KV_DFCO_ENGINE_SPEED", nameFlags);
MakeRptCmt(0x0000BB60, "Minimum engine speed to enable DFCO.\nRPM");
MakeNameEx(0x0000BB74, "FUEL_CU_KV_DFCO_EXIT_ENGINE_SPEED", nameFlags);
MakeRptCmt(0x0000BB74, "When engine speed goes below this cal with fuel cutoff, the fuel is turned on.\nRPM");
MakeNameEx(0x0000BB88, "FUEL_CU_KV_DFCO_FAST_EXIT_DELTA_RPM", nameFlags);
MakeRptCmt(0x0000BB88, "If the engine speed changes by more than this in a constant time period, a DFCO fast exit will occur.\nRPM_S");
MakeNameEx(0x0000BB8C, "FUEL_CU_KV_DFCO_MANIFOLD_PRESSURE", nameFlags);
MakeRptCmt(0x0000BB8C, "Maximum manifold pressure to enable DFCO.\nkPa");
MakeNameEx(0x0000BB96, "FUEL_CU_KV_DFCO_EXIT_MANIFOLD_PRESSURE", nameFlags);
MakeRptCmt(0x0000BB96, "When MAP goes above this cal with fuel cutoff, the fuel is turned on.\nkPa");
MakeNameEx(0x0000BBA0, "FUEL_CU_KV_DFCO_THROTTLE_POSITION", nameFlags);
MakeRptCmt(0x0000BBA0, "Throttle must be < this to enable DFCO.\nPercent");
MakeNameEx(0x0000BBCA, "FUEL_CU_KV_DFCO_ENTRY_TIME", nameFlags);
MakeRptCmt(0x0000BBCA, "DFCO enabling conditions must exist continuously for this long to enable DFCO.\nSeconds");
MakeNameEx(0x0000BBD0, "FUEL_CU_KE_TOTAL_REFS_TO_MODIFY_AIR", nameFlags);
MakeRptCmt(0x0000BBD0, "Total number of reference pulses to factor in residual air for DFCO exits.\nRefs");
MakeNameEx(0x0000BBD1, "FUEL_CU_KE_SECONDARY_REFS_TO_MODIFY_AIR", nameFlags);
MakeRptCmt(0x0000BBD1, "Number of reference pulses to factor in residual air using KE_Final_DFCO_Residual_Factor for DFCO exits.\nRefs");
MakeNameEx(0x0000BBD2, "FUEL_CU_KE_INITIAL_DFCO_RESIDUAL_FACTOR", nameFlags);
MakeNameEx(0x0000BBD6, "FUEL_CU_KE_FINAL_DFCO_RESIDUAL_FACTOR", nameFlags);
MakeNameEx(0x0000BBDA, "FUEL_CU_KV_DFCO_TRANS_AIR_DELAY", nameFlags);
MakeRptCmt(0x0000BBDA, "Amount of time required to remove excess air added by the auto transmission forced downshift DFCO exit logic.\nSeconds");
MakeNameEx(0x0000BBFC, "FUEL_CU_KV_COLD_ENG_PROT_OVERSPEED_HIGH", nameFlags);
MakeRptCmt(0x0000BBFC, "This is the engine speed above which fuel is shutoff if cold engine protection mode is enabled.\nRPM");
MakeNameEx(0x0000BC1C, "FUEL_CU_KV_COLD_ENG_PROT_OVERSPEED_LOW", nameFlags);
MakeRptCmt(0x0000BC1C, "The engine speed must fall below this limit before allowing fuel to be turned back on, if cold engine protection is enabled.\nRPM");
MakeNameEx(0x0000BC3C, "FUEL_DY_KE_MAKEUP_FUEL_ENABLED", nameFlags);
MakeRptCmt(0x0000BC3C, "Flag used to enable/disable the calculation and delivery of makeup fuel.\nTRUE | FALSE");
MakeNameEx(0x0000BC3E, "FUEL_DY_KA_K2_PRIOR_STOMP_COMP_REDUCTION", nameFlags);
MakeNameEx(0x0000BCFC, "FUEL_DY_KV_K4_STOMP_COMP_DELTA_LIMIT", nameFlags);
MakeRptCmt(0x0000BCFC, "Minimum delta fuel limit to add stomp compensation.\nGrams");
MakeNameEx(0x0000BD06, "FUEL_DY_KV_K5_STOMP_COMP_DELTA_LOW_LIMIT", nameFlags);
MakeRptCmt(0x0000BD06, "Delta mass threshold to disable throttle stomp compensation on tip outs.\nGrams");
MakeNameEx(0x0000BD10, "FUEL_DY_KA_IMPACT_FACTOR_20KPA_MAP", nameFlags);
MakeRptCmt(0x0000BD10, "Describes the fraction of the injected pulse that will impact the port wall at 20kPa MAP.\nMult_0_to_1");
MakeNameEx(0x0000BDCE, "FUEL_DY_KA_IMPACT_FACTOR_100KPA_MAP", nameFlags);
MakeRptCmt(0x0000BDCE, "Describes the fraction of the injected pulse that will impact the port wall at 100kPa MAP.\nMult_0_to_1");
MakeNameEx(0x0000BE8C, "FUEL_DY_KA_BOIL_TIME_CONST_20KPA_MAP", nameFlags);
MakeRptCmt(0x0000BE8C, "Describes the time it takes for 63% of liquid fuel on port wall to vaporize at 20kPa MAP.\nSeconds");
MakeNameEx(0x0000BF4A, "FUEL_DY_KA_BOIL_TIME_CONST_100KPA_MAP", nameFlags);
MakeRptCmt(0x0000BF4A, "Describes the time it takes for 63% of liquid fuel on port wall to vaporize at 100kPa MAP.\nSeconds");
MakeNameEx(0x0000C008, "FUEL_DY_KE_DFCO_STOMP_COMP_TPS_MIN", nameFlags);
MakeRptCmt(0x0000C008, "Throttle position below which stomp comp will not be applied when exiting DFCO.\nPercent");
MakeNameEx(0x0000C00A, "FUEL_DY_KE_FUEL_IGNORE_WALL_WETTING_RPM", nameFlags);
MakeNameEx(0x0000C00C, "FUEL_DY_KE_FUEL_IGNORE_WALL_WETTING_TPS", nameFlags);
MakeNameEx(0x0000C00E, "FUEL_DY_KE_MIN_PULSE_WIDTH", nameFlags);
MakeNameEx(0x0000C010, "FUEL_DY_KA_K1_INITIAL_STOMP_COMP_TIME_FA", nameFlags);
MakeNameEx(0x0000C0CE, "FUEL_DY_KA_K3_STOMP_COMP_TIME_DECAY", nameFlags);
MakeRptCmt(0x0000C0CE, "The stomp compensation factor is decayed by this multiplier once per second.\nNONE 0_1");
MakeNameEx(0x0000C18C, "FUEL_DY_KV_K1_SOAKTIMER_MODIFIER", nameFlags);
MakeRptCmt(0x0000C18C, "A modifier to Stomp_Comp_Time_Decay_Factor based on.soaktimer if enabled.\nNONE 0_2");
MakeNameEx(0x0000C1C6, "FUEL_DY_KE_WALL_MASS_FACTOR", nameFlags);
MakeRptCmt(0x0000C1C6, "Multiplier used to guarantee stability of the Wall  Wetting model.\nNONE 0_2");
MakeNameEx(0x0000C1C8, "FUEL_DY_KV_IMPACT_FACTOR_MODIFIER", nameFlags);
MakeRptCmt(0x0000C1C8, "Factor, based on air flow, which reduces KA_Boiling_Time_Constant.\nNONE 0_1");
MakeNameEx(0x0000C20A, "FUEL_DY_KA_IMPACT_FACTOR_BLEND_FRACTION", nameFlags);
MakeRptCmt(0x0000C20A, "Normalized fraction describing the impact factor surface relative to the 20kPa and 100kPa MAP extremities.\nScaler_16_S");
MakeNameEx(0x0000C360, "FUEL_DY_KA_BOIL_TIME_CONST_BLND_FRACTION", nameFlags);
MakeRptCmt(0x0000C360, "Normalized fraction describing the boiling time constant surface relative to the 20kPa and 100kPa MAP extremities.\nScaler_16_S");
MakeNameEx(0x0000C4B6, "FUEL_DY_KV_INITIAL_WW_DELAY_REFS", nameFlags);
MakeRptCmt(0x0000C4B6, "Number of reference pulses to delay, after PCM state equal run, before enabling Wall Wetting.\nSHORTCARD");
MakeNameEx(0x0000C4C6, "FUEL_DY_KE_STARTUP_MAKEUP_DELAY", nameFlags);
MakeRptCmt(0x0000C4C6, "Number of reference pulses to delay after engine is running before calculating makeup fuel.\nCARDINAL");
MakeNameEx(0x0000C4C8, "FUEL_DY_KV_MAKEUP_FUEL_CHANNEL", nameFlags);
MakeRptCmt(0x0000C4C8, "Selects the cylinder to receive makeup fuel based on the current cylinder.\nCYL NUM");
MakeNameEx(0x0000C4D2, "FUEL_DY_KV_MAKEUP_CYLINDER_INDEX", nameFlags);
MakeRptCmt(0x0000C4D2, "Selects the cylinder index for which to calculate makeup fuel based on the cylinder to receive makeup fuel.\nCYL NUM");
MakeNameEx(0x0000C4DC, "FUEL_DY_KA_IMPACT_FACTOR_MODIFIER_2", nameFlags);
MakeRptCmt(0x0000C4DC, "Impact Factor modifier vs Delta Mass and Coolant Temp.\nScaler 0-1");
MakeNameEx(0x0000C630, "FUEL_DY_KA_BOILING_TIME_MODIFIER_2", nameFlags);
MakeRptCmt(0x0000C630, "Impact Factor modifier vs Delta Mass and Coolant Temp.\nScaler 0-1");
MakeNameEx(0x0000C784, "FUEL_DY_KV_BOILING_TIME_MODIFIER", nameFlags);
MakeRptCmt(0x0000C784, "Factor, based on air flow, which reduces KA_Boiling_Time_Constant.\nNONE 0_1");
MakeNameEx(0x0000C7C6, "FUEL_ECONOMY_KE_FUEL_ECONOMY_SCALER", nameFlags);
MakeRptCmt(0x0000C7C6, "Scaler used to adjust liters of fuel for fuel economy calculations.\nNONE 0_2");
MakeNameEx(0x0000C7C8, "FUEL_ECONOMY_KE_INSTANTANEOUS_FILTER_COEFF", nameFlags);
MakeRptCmt(0x0000C7C8, "Coefficient for filtering instantaneous fuel\nNONE 0-1");
MakeNameEx(0x0000C7CA, "FUEL_EQ_KV_GREEN_ENGINE_AIRFUEL_RATIO", nameFlags);
MakeRptCmt(0x0000C7CA, "Commanded Airfuel Ratio during Green Engine Crank.\nAirfuel Ratio");
MakeNameEx(0x0000C7D0, "FUEL_EQ_KE_CLEAR_FLOOD_THROTTLE_ENTER", nameFlags);
MakeRptCmt(0x0000C7D0, "Threshold which throttle position must initially cross for no crank or prime fuel to be delivered.\nPercent");
MakeNameEx(0x0000C7D2, "FUEL_EQ_KE_CLEAR_FLOOD_THROTTLE_EXIT", nameFlags);
MakeRptCmt(0x0000C7D2, "Threshold which throttle position must remain above for no crank or prime fuel to be delivered.\nPercent");
MakeNameEx(0x0000C7D4, "FUEL_EQ_KV_STOICHIOMETRIC_FUEL_AIR", nameFlags);
MakeRptCmt(0x0000C7D4, "Defines the ratio mass of fuel to mass of air for stoichiometric, based on alcohol content of fuel.\nMult_0_to_1");
MakeNameEx(0x0000C7F6, "FUEL_EQ_KV_OPEN_LP_EQ_RATIO_BLEND_FACTOR", nameFlags);
MakeNameEx(0x0000C800, "FUEL_EQ_KV_PARK_DRIVE_DELAY_TIME", nameFlags);
MakeRptCmt(0x0000C800, "Amount of time after PRNDL shifts into drive before adding park to drive enrichment.\nSeconds");
MakeNameEx(0x0000C820, "FUEL_EQ_KV_ENGINE_PROTECTION_EQUIVALENCE", nameFlags);
MakeRptCmt(0x0000C820, "Equivalence ratio based on engine speed if engine protection is enabled.\nEquiv_Ratio_Type");
MakeNameEx(0x0000C84A, "FUEL_EQ_KE_NORMAL_CRANK_EVENT_LIMIT", nameFlags);
MakeRptCmt(0x0000C84A, "Absolute ref count defining the end of the normal crank portion of KA_Crank_Equivalence_Ratio.\n1-32");
MakeNameEx(0x0000C84B, "FUEL_EQ_KE_EXTENDED_CRANK_EVENT_LIMIT", nameFlags);
MakeNameEx(0x0000C84C, "FUEL_EQ_KE_HOT_ENRICHMENT_COOLANT_ENTRY_", nameFlags);
MakeRptCmt(0x0000C84C, "Coolant temperature above which the hot enrichment state can become active.\nDegrees_C");
MakeNameEx(0x0000C84E, "FUEL_EQ_KE_HOT_ENRICHMENT_COOLANT_EXIT_T", nameFlags);
MakeRptCmt(0x0000C84E, "Coolant temperature below which the hot enrichment state will become inactive, used due to hysteresis.\nDegrees_C");
MakeNameEx(0x0000C850, "FUEL_EQ_KE_HOT_ENRICHMENT_THROTTLE_ENTRY", nameFlags);
MakeRptCmt(0x0000C850, "Throttle position above which the hot enrichment state can become active.\nPercent");
MakeNameEx(0x0000C852, "FUEL_EQ_KE_HOT_ENRICHMENT_THROTTLE_EXIT_", nameFlags);
MakeRptCmt(0x0000C852, "Throttle position below which the hot enrichment state will become inactive, used due to hysteresis.\nPercent");
MakeNameEx(0x0000C854, "FUEL_EQ_KE_HOT_ENRICHMENT_MAP_ENTRY_THRE", nameFlags);
MakeRptCmt(0x0000C854, "Manifold pressure above which the hot enrichment state can become active.\nkPa");
MakeNameEx(0x0000C856, "FUEL_EQ_KE_HOT_ENRICHMENT_MAP_EXIT_THRES", nameFlags);
MakeRptCmt(0x0000C856, "Manifold pressure below which the hot enrichment state will become inactive, used due to hysteresis.\nkPa");
MakeNameEx(0x0000C858, "FUEL_EQ_KE_HOT_ENRICHMENT_VEH_SPEED_ENTR", nameFlags);
MakeRptCmt(0x0000C858, "Vehicle speed above which the hot enrichment state can become active.\nMPH");
MakeNameEx(0x0000C85A, "FUEL_EQ_KE_HOT_ENRICHMENT_VEH_SPEED_EXIT", nameFlags);
MakeRptCmt(0x0000C85A, "Vehicle speed below which the hot enrichment state will become inactive, used due to hysteresis.\nMPH");
MakeNameEx(0x0000C85C, "FUEL_EQ_KE_HOT_ENRICHMENT_EQUIVALENCE_OF", nameFlags);
MakeRptCmt(0x0000C85C, "Coolant temperature threshold in which enrichmentwill be applied.\nDegrees_C");
MakeNameEx(0x0000C85E, "FUEL_EQ_KE_HOT_ENRICHMENT_EQUIVALENCE_MU", nameFlags);
MakeRptCmt(0x0000C85E, "Percentage of enrichment as a function of coolant temperature.\nMult_0_to_2");
MakeNameEx(0x0000C860, "FUEL_EQ_KE_MAXIMUM_ENRICHMENT_EQUIVALENC", nameFlags);
MakeRptCmt(0x0000C860, "Maximum allowable enrichment equivalence ratio.\nEquiv_Ratio_Type");
MakeNameEx(0x0000C862, "FUEL_EQ_KE_POWER_ENRICHMENT_HOT_TEMP", nameFlags);
MakeRptCmt(0x0000C862, "Coolant temperature threshold above which a different enable criteria for PE is used.\nDegrees_C");
MakeNameEx(0x0000C864, "FUEL_EQ_KE_POWER_ENRICHMENT_THROTTLE_HYS", nameFlags);
MakeRptCmt(0x0000C864, "Hysteresis to the base throttle threshold to prevent noise from turning PE on and off.\nPercent");
MakeNameEx(0x0000C866, "FUEL_EQ_KE_POWER_ENRICHMENT_COT_HYSTERES", nameFlags);
MakeRptCmt(0x0000C866, "Hysteresis to the base throttle threshold to prevent noise from turning PE on and off, while in COT.\nPercent");
MakeNameEx(0x0000C868, "FUEL_EQ_KE_POWER_ENRICHMENT_MAP_THRESHOL", nameFlags);
MakeRptCmt(0x0000C868, "Base MAP threshold to enable PE.\nkPa");
MakeNameEx(0x0000C86A, "FUEL_EQ_KE_POWER_ENRICHMENT_MAP_HYSTERES", nameFlags);
MakeRptCmt(0x0000C86A, "Hysteresis to the base MAP threshold to prevent noise from turning PE on and off.\nkPa");
MakeNameEx(0x0000C86C, "FUEL_EQ_KV_POWER_ENRICHMENT_HOT_THRESHOL", nameFlags);
MakeRptCmt(0x0000C86C, "Defines the base enable throttle position for power  enrichment when coolant temperature is above a calibration threshold.\nPercent");
MakeNameEx(0x0000C892, "FUEL_EQ_KV_POWER_ENRICHMENT_COLD_THRESHO", nameFlags);
MakeRptCmt(0x0000C892, "Defines the base enable throttle position for power  enrichment when coolant temperature is below a calibration threshold.\nPercent");
MakeNameEx(0x0000C8B8, "FUEL_EQ_KV_POWER_ENRICHMENT_RPM_EQUIVALE", nameFlags);
MakeRptCmt(0x0000C8B8, "Defines the base equivalence ratio for power enrichment based on RPM.\nEquiv_Ratio_Type");
MakeNameEx(0x0000C8DE, "FUEL_EQ_KV_POWER_ENRICHMENT_COOLANT_EQUI", nameFlags);
MakeRptCmt(0x0000C8DE, "Used to modify the base equivalence ratio for power enrichment based on coolant.\nEquiv_Ratio_Type");
MakeNameEx(0x0000C904, "FUEL_EQ_KV_POWER_ENRICHMENT_IAT_EQUIV", nameFlags);
MakeRptCmt(0x0000C904, "Used to modify the base equivalence ratio for power enrichment based on IAT. For Holden application.\nEquiv_Ratio_Type");
MakeNameEx(0x0000C92A, "FUEL_EQ_KA_OPEN_LOOP_EQ_RATIO_E0", nameFlags);
MakeNameEx(0x0000CBB0, "FUEL_EQ_KA_OPEN_LOOP_EQ_RATIO_E80", nameFlags);
MakeNameEx(0x0000CE36, "FUEL_EQ_KA_FAST_AFTERSTART_APPLY_DELAY", nameFlags);
MakeRptCmt(0x0000CE36, "Number of reference pulses after engine run to wait prior to applying Fast Afterstart Enrichment.\nEngine_Revolutions");
MakeNameEx(0x0000CE9A, "FUEL_EQ_KA_FAST_AFTERSTART_HOLD_REFS", nameFlags);
MakeRptCmt(0x0000CE9A, "Number of reference pulses initiated at engine run to start the Fast Afterstart Enrichment decay.\nEngine_Revolutions");
MakeNameEx(0x0000CEFE, "FUEL_EQ_KA_AFTERSTART_DECAY_DELAY", nameFlags);
MakeNameEx(0x0000CF62, "FUEL_EQ_KA_AFTERSTART_DECAY_STEP", nameFlags);
MakeRptCmt(0x0000CF62, "This calibration along with the rate of change of KA_Afterstart_Decay_Delay determines the afterstart enrichment decay rate.\nEngine_Revolutions");
MakeNameEx(0x0000CFC6, "FUEL_EQ_KA_AFTERSTART_DECAY_MULTIPLIER", nameFlags);
MakeRptCmt(0x0000CFC6, "Decay multiplier applied to the current Afterstart Enrichment.\nNONE 0_1");
MakeNameEx(0x0000D084, "FUEL_EQ_KV_PARK_DRIVE_DECAY_DELAY", nameFlags);
MakeNameEx(0x0000D094, "FUEL_EQ_KV_PARK_DRIVE_DECAY_STEP", nameFlags);
MakeRptCmt(0x0000D094, "This calibration along with the rate of change of KV_Park_Drive_Decay_Delay determines the park to drive enrichment decay rate.\nEngine_Revolutions");
MakeNameEx(0x0000D0A4, "FUEL_EQ_KV_PARK_DRIVE_DECAY_MULTIPLIER", nameFlags);
MakeRptCmt(0x0000D0A4, "Decay multiplier applied to the current Park to Drive Enrichment.\nNONE 0_1");
MakeNameEx(0x0000D0C4, "FUEL_EQ_KA_INITIAL_CLT_AND_FFS_ENRICH", nameFlags);
MakeNameEx(0x0000D182, "FUEL_EQ_KV_INITIAL_IAT_ENRICHMENT", nameFlags);
MakeRptCmt(0x0000D182, "Initial enrichment, based on Induction Air Temperature, to be added to open loop equivalence ratio.\nNONE -1_4");
MakeNameEx(0x0000D1A2, "FUEL_EQ_KV_INITIAL_PARK_DRIVE_ENRICHMENT", nameFlags);
MakeRptCmt(0x0000D1A2, "Initial enrichment, applied when a park to drive transition occurs, to be added to open loop equivalence ratio.\nNONE -1_4");
MakeNameEx(0x0000D1C2, "FUEL_EQ_KV_INITIAL_CLT_SOAKTIME_MODIFIER", nameFlags);
MakeRptCmt(0x0000D1C2, "A modifier to Initial_Coolant_Enrichment based onsoaktimer if enabled.\nNONE 0_2");
MakeNameEx(0x0000D1FC, "FUEL_EQ_KA_INITIAL_HOT_SOAK_ENRICHMENT", nameFlags);
MakeRptCmt(0x0000D1FC, "Initial Hot Soak enrichment based on Time Since EngineLast Ran and Coolant Temperature.\nNONE -32_32");
MakeNameEx(0x0000D64A, "FUEL_EQ_KE_FAST_AFTERSTART_PD_MAX", nameFlags);
MakeRptCmt(0x0000D64A, "Maximum amount of KV_Fast_Afterstart Enrichment to allow Park to Drive.\nEquiv_Ratio_S_Type");
MakeNameEx(0x0000D64C, "FUEL_EQ_KE_FAST_AFTERSTART_ENRICH_ENBLD", nameFlags);
MakeRptCmt(0x0000D64C, "Option to enable/disable the Fast Afterstart Enrichment algorithm.\nBOOLEAN");
MakeNameEx(0x0000D64E, "FUEL_EQ_KV_FAST_AFTERSTART_DECAY_STEPS", nameFlags);
MakeRptCmt(0x0000D64E, "Equivalence ratio decay step for Fast Afterstart Enrichment. Amount decayed every KV_Fast_Afterstart_Decay_Intrvl.\nEquiv_Ratio_S_Type");
MakeNameEx(0x0000D658, "FUEL_EQ_KV_FAST_AFTERSTART_DECAY_INTRVL", nameFlags);
MakeRptCmt(0x0000D658, "Number of ref pulses between decay steps for Fast Afterstart Enrichment\nRef Pulses");
MakeNameEx(0x0000D65E, "FUEL_EQ_KE_PCT_TRQ_DES_TO_ENABLE_PE", nameFlags);
MakeRptCmt(0x0000D65E, "When PE is not active, Pct_Trq_Des_To_Enable_PE is set to this cal as enabling threshold.\nPercent_0_To_200");
MakeNameEx(0x0000D660, "FUEL_EQ_KE_HYST_PCT_TRQ_FOR_PE", nameFlags);
MakeRptCmt(0x0000D660, "Pct_Trq_Des_To_Enable_PE threshold hystersis value applied when PE is active.\nPercent_0_To_200");
MakeNameEx(0x0000D662, "FUEL_EQ_KE_TRQ_MGT_PWR_ENRICH_THROT_HYS", nameFlags);
MakeRptCmt(0x0000D662, "PE throttle threshold hysteresis value applied when PE is active and ETC torque management is active.\nPercent");
MakeNameEx(0x0000D664, "FUEL_EQ_KV_CRANK_EQ_RATIO_BLEND_FACTOR", nameFlags);
MakeNameEx(0x0000D67A, "FUEL_EQ_KV_CRANK_EQ_RATIO_E80_FACTOR", nameFlags);
MakeNameEx(0x0000D6A0, "FUEL_EQ_KA_FAST_AFTERSTART_ENRICHMENT", nameFlags);
MakeRptCmt(0x0000D6A0, "Additional coolant and fuel composition based afterstart enrichment.\nNONE 0_4");
MakeNameEx(0x0000D75E, "FUEL_EQ_KA_LC_FUEL_DELTA", nameFlags);
MakeRptCmt(0x0000D75E, "Returns the target  for Lean EQ based on the engine load.\nEquiv_Ratio");
MakeNameEx(0x0000D9D4, "FUEL_EQ_KA_CRANK_ER_ENLEAN_MODIFIER", nameFlags);
MakeRptCmt(0x0000D9D4, "Modifer based on Coolant and RPM to better blend(enlean) from crank fuel to run fuel\nMult_0_to_1");
MakeNameEx(0x0000DBC2, "FUEL_EQ_KA_PE_DELAY_ADJUSTMENT", nameFlags);
MakeNameEx(0x0000DD0C, "FUEL_EQ_KE_PE_DELAY_COUNT", nameFlags);
MakeRptCmt(0x0000DD0C, "PE conditions must exists for this amount before PE is enabled.\nSeconds");
MakeNameEx(0x0000DD0E, "FUEL_EQ_KE_PE_DELAY_ENGINE_SPEED", nameFlags);
MakeRptCmt(0x0000DD0E, "Engine speed threshold to bypass PE_Delay, when RPM is above threshold.\nRPM");
MakeNameEx(0x0000DD10, "FUEL_EQ_KE_PE_DELAY_ENGINE_SPEED_RISE", nameFlags);
MakeRptCmt(0x0000DD10, "Engine speed delta threshold used with vehicle speed to bypass PE_Delay, when RPM is above threshold.\nRPM");
MakeNameEx(0x0000DD12, "FUEL_EQ_KE_PE_DELAY_ENGINE_SPEED_RISE_MP", nameFlags);
MakeRptCmt(0x0000DD12, "Vehicle speed threshold used with Engine speed delta criteria to bypass PE_Delay, when MPH is above or equal to threshold.\nMPH");
MakeNameEx(0x0000DD14, "FUEL_EQ_KE_PE_DELAY_TEMPERATURE_HIGH", nameFlags);
MakeRptCmt(0x0000DD14, "Coolant temperature upper window to bypass PE_Delay, when coolant is above threshold.\nDegrees_C");
MakeNameEx(0x0000DD16, "FUEL_EQ_KE_PE_DELAY_TEMPERATURE_LOW", nameFlags);
MakeRptCmt(0x0000DD16, "Coolant temperature lower window to bypass PE_Delay, when coolant is below threshold.\nDegrees_C");
MakeNameEx(0x0000DD18, "FUEL_EQ_KE_PE_DELAY_THROTTLE_RISE", nameFlags);
MakeRptCmt(0x0000DD18, "Throttle delta threshold used with vehicle speed to bypass PE_Delay, when throttle delta is >= threshold.\nPercent");
MakeNameEx(0x0000DD1A, "FUEL_EQ_KE_PE_DELAY_THROTTLE_RISE_MPH", nameFlags);
MakeRptCmt(0x0000DD1A, "Vehicle speed threshold used with throttle delta to bypass PE_Delay, when MPH is below threshold.\nMPH");
MakeNameEx(0x0000DD1C, "FUEL_EQ_KE_PE_DELAY_VEHICLE_SPEED_DROP", nameFlags);
MakeRptCmt(0x0000DD1C, "Vehicle speed delta threshold used to decrement PE_Delay, when MPH decrease >= threshold.\nMPH");
MakeNameEx(0x0000DD1E, "FUEL_EQ_KE_PE_DELAY_VEHICLE_SPEED_MPH", nameFlags);
MakeRptCmt(0x0000DD1E, "Vehicle speed threshold used to decrement PE_Delay, when MPH is below threshold.\nMPH");
MakeNameEx(0x0000DD20, "FUEL_EQ_KE_PE_DELAY_VEHICLE_SPEED_RISE", nameFlags);
MakeRptCmt(0x0000DD20, "Vehicle speed threshold used to decrement PE_Delay, when MPH increase >= threshold.\nMPH");
MakeNameEx(0x0000DD22, "FUEL_EQ_KE_PE_DELAY_VEHICLE_SPEED_TPS", nameFlags);
MakeRptCmt(0x0000DD22, "Throttle position threshold used to decrement PE_Delay, when throttle is above threshold.\nPercent");
MakeNameEx(0x0000DD24, "FUEL_EQ_KE_OPEN_LOOP_LEAN_LIMIT", nameFlags);
MakeRptCmt(0x0000DD24, "Lower (lean) limit for final equivalence ration when in anidle condition.\nEquiv_Ratio_Type");
MakeNameEx(0x0000DD26, "FUEL_EQ_KE_PP_CLT", nameFlags);
MakeRptCmt(0x0000DD26, "Coolant temperature higher than this value will enable piston protection if other conditions are satisfied\nDegrees C");
MakeNameEx(0x0000DD28, "FUEL_EQ_KE_PP_DELAY_TIME", nameFlags);
MakeRptCmt(0x0000DD28, "Delay time in seconds before entering piston protection mode.\nSeconds");
MakeNameEx(0x0000DD2A, "FUEL_EQ_KE_PP_EQ_RAMP_RATE", nameFlags);
MakeRptCmt(0x0000DD2A, "This determines the blending rate\nSeconds");
MakeNameEx(0x0000DD2C, "FUEL_EQ_KE_PP_EQ_STEPSIZE", nameFlags);
MakeRptCmt(0x0000DD2C, "This determines the amount of change to the current equivalence ratio at each ramp rate.\nEquiv Ratio");
MakeNameEx(0x0000DD2E, "FUEL_EQ_KE_PP_MAF", nameFlags);
MakeRptCmt(0x0000DD2E, "Airflow rate higher than this value will enable piston protection if other conditions are satisfied\nGrams/Second");
MakeNameEx(0x0000DD30, "FUEL_EQ_KE_PP_RPM", nameFlags);
MakeRptCmt(0x0000DD30, "Engine speed higher than this value will enable piston protection if other conditions are satisfied\nRPM");
MakeNameEx(0x0000DD32, "FUEL_EQ_KE_PP_TPS", nameFlags);
MakeRptCmt(0x0000DD32, "Throttle position higher than this value will enable piston protection if other conditions are satisfied\nPercent");
MakeNameEx(0x0000DD34, "FUEL_EQ_KE_LC_VEHICLE_SPEED_HYST_HIGH", nameFlags);
MakeRptCmt(0x0000DD34, "When vehicle speed is above this value with other conditions satisfied, it will enable Lean Cruise mode.\nMPH");
MakeNameEx(0x0000DD36, "FUEL_EQ_KE_LC_VEHICLE_SPEED_HYST_LOW", nameFlags);
MakeRptCmt(0x0000DD36, "When vehicle speed is above this value with other conditions satisfied, it will enable Lean Cruise mode.\nMPH");
MakeNameEx(0x0000DD38, "FUEL_EQ_KV_PISTON_PROTECTION_EQUIVALENCE", nameFlags);
MakeRptCmt(0x0000DD38, "Equivalence ratio if piston protection is enabled.\nEquiv_Ratio_Type");
MakeNameEx(0x0000DD62, "FUEL_EQ_KV_POWER_ENRICHMENT_RPM_THRESHOL", nameFlags);
MakeRptCmt(0x0000DD62, "Engine speed threshold to enable PE, when RPM is above or equal to threshold.\nRPM");
MakeNameEx(0x0000DD6C, "FUEL_EQ_KA_CRANK_EQUIVALENCE_RATIO", nameFlags);
MakeRptCmt(0x0000DD6C, "Fuel/Air equivalence ratio to use during crankfor gasoline.\nEquiv_Ratio_Type");
MakeNameEx(0x0000E22C, "FUEL_EQ_KE_PE_EQ_STEPSIZE", nameFlags);
MakeRptCmt(0x0000E22C, "Step size taken for ramp-in or ramp-out of the PE EQ offset\nEquiv_Ratio_Type");
MakeNameEx(0x0000E22E, "FUEL_EQ_KE_PE_EQ_RAMP_IN_RATE", nameFlags);
MakeRptCmt(0x0000E22E, "Unit time taken before applying stepsize to ramp-out PE EQ offset\nSeconds");
MakeNameEx(0x0000E230, "FUEL_EQ_KE_PE_EQ_RAMP_OUT_RATE", nameFlags);
MakeRptCmt(0x0000E230, "Unit time taken before applying stepsize to ramp-in PE EQ offset\nSeconds");
MakeNameEx(0x0000E232, "FUEL_EQ_KE_LC_EQ_STEP_SIZE", nameFlags);
MakeRptCmt(0x0000E232, "This is the step size in which ramping is done.\nEquiv_Ratio_Type");
MakeNameEx(0x0000E234, "FUEL_EQ_KE_LC_ENGINE_RUN_TIME", nameFlags);
MakeRptCmt(0x0000E234, "When engine run time is above this, with other conditions satisfied, it will enable Lean Cruise mode.\nSeconds");
MakeNameEx(0x0000E238, "FUEL_EQ_KE_LC_TIME_SINCE_IDLE", nameFlags);
MakeRptCmt(0x0000E238, "When Time_Since_Last_Idle is above this with other conditions satisfied, it will enable Lean Cruise mode.\nSeconds");
MakeNameEx(0x0000E23A, "FUEL_EQ_KV_LC_COOLANT_MULTIPLIER", nameFlags);
MakeRptCmt(0x0000E23A, "Multiplier used to vary the amount of lean cruise effect during warmup.\n0_to_1");
MakeNameEx(0x0000E260, "FUEL_EQ_KE_ICAT_CAN_ACTIVATE_RTN", nameFlags);
MakeRptCmt(0x0000E260, "Determines if Return to Normal will function after an ICAT intrusive event.\nBoolean");
MakeNameEx(0x0000E261, "FUEL_EQ_KE_POSD_CAN_ACTIVATE_RTN", nameFlags);
MakeRptCmt(0x0000E261, "Determines if Return to Normal will function after an POSD intrusive event.\nBoolean");
MakeNameEx(0x0000E262, "FUEL_EQ_KE_RETURN_TO_NORMAL_EQ_RATIO", nameFlags);
MakeRptCmt(0x0000E262, "Equivalence ratio if Return to Normal is active.\nEquiv_Ratio_Type");
MakeNameEx(0x0000E264, "FUEL_EQ_KV_PO2_RETURN_TO_NORMAL_MAX_TIME", nameFlags);
MakeRptCmt(0x0000E264, "Max amount time that the Retun to Normal feature will be allowed to be continuously active.\nSeconds");
MakeNameEx(0x0000E276, "FUEL_IO_KE_BOUNDARY_OFFSET", nameFlags);
MakeNameEx(0x0000E278, "FUEL_IO_KE_ENG_PROTECTION_NORMAL_END_OF_", nameFlags);
MakeRptCmt(0x0000E278, "Normal pulse end of injection location if engine protection is enabled, in number of lores periods after the boundary.\nLores_Periods");
MakeNameEx(0x0000E27A, "FUEL_IO_KE_ENG_PROTECTION_TRIM_END_OF_IN", nameFlags);
MakeRptCmt(0x0000E27A, "Trim pulse end of injection location if engine protection is enabled, in number of lores periods after the boundary.\nLores_Periods");
MakeNameEx(0x0000E27C, "FUEL_IO_KV_NORMAL_END_OF_INJECTION_COOLA", nameFlags);
MakeNameEx(0x0000E29C, "FUEL_IO_KV_TRIM_END_OF_INJECTION_COOLANT", nameFlags);
MakeRptCmt(0x0000E29C, "Defines the trim pulse end of injection location, based on coolant temperature, in number of lores periods after the boundary.\n");
MakeNameEx(0x0000E2BC, "FUEL_IO_KE_MINIMUM_INJECTOR_OFF_TIME", nameFlags);
MakeRptCmt(0x0000E2BC, "Minimum amount of time that an injector must remain off before turning on again.\nMilliseconds");
MakeNameEx(0x0000E2BE, "FUEL_IO_KV_INJECTOR_OFFSET_ADJUSTMENT", nameFlags);
MakeRptCmt(0x0000E2BE, "This is the injector offset used to account for injector dynamics due vacuum effects on the trapped sac volume fuel.\nMilliseconds");
MakeNameEx(0x0000E2E0, "FUEL_IO_KA_INJECTOR_OFFSET", nameFlags);
MakeNameEx(0x0000E698, "FUEL_IO_KA_FIRST_CYL_TO_GET_SEQUENTIAL", nameFlags);
MakeNameEx(0x0000E6B8, "FUEL_IO_KV_BANK_FOR_CYLINDER", nameFlags);
MakeRptCmt(0x0000E6B8, "This calibration associates each cylinder with a bank of the engine.\nBank1|Bank2");
MakeNameEx(0x0000E6C0, "FUEL_IO_KA_UPDATE_FUEL_CHANNELS", nameFlags);
MakeRptCmt(0x0000E6C0, "Determines whether to update Fuel Pulse Width for the injector based on the current cylinder.\nTRUE|FALSE");
MakeNameEx(0x0000E700, "FUEL_IO_KE_AIRBAG_ENG_SHUTDOWN_VEH_SPEED", nameFlags);
MakeRptCmt(0x0000E700, "Threshold below which the vehicle is considered to stationary\nMPH");
MakeNameEx(0x0000E702, "FUEL_IO_KE_AIRBAG_ENG_SHUTDOWN_TIMER", nameFlags);
MakeRptCmt(0x0000E702, "Timer above which the vehicle is considered to have been longenough to allow the state of the airbag to shutdown the engine\nSeconds");
MakeNameEx(0x0000E704, "FUEL_IO_KE_DESOOT_COOLANT_THRESH", nameFlags);
MakeRptCmt(0x0000E704, "Coolant must be at least this temperature to enable Desoot mode.\nDegrees_C");
MakeNameEx(0x0000E706, "FUEL_IO_KE_DESOOT_COOLANT_THRESH_HYSTERE", nameFlags);
MakeRptCmt(0x0000E706, "Hysteresis required of coolant temperature to disable Desoot mode.\nDegrees_C");
MakeNameEx(0x0000E708, "FUEL_IO_KE_DESOOT_MAP_THRESH", nameFlags);
MakeRptCmt(0x0000E708, "MAP must be at least this calibration to enable Desoot mode.\nkPa");
MakeNameEx(0x0000E70A, "FUEL_IO_KE_DESOOT_MAP_THRESH_HYSTERESIS", nameFlags);
MakeRptCmt(0x0000E70A, "Hysteresis required of MAP to disable Desoot mode.\nkPa");
MakeNameEx(0x0000E70C, "FUEL_IO_KE_DESOOT_LO_MAP_EXIT_THRESH", nameFlags);
MakeRptCmt(0x0000E70C, "If MAP falls below this calibration, disable Desoot mode immediately.\nkPa");
MakeNameEx(0x0000E70E, "FUEL_IO_KE_DESOOT_DELAY_TIME", nameFlags);
MakeRptCmt(0x0000E70E, "Conditions must exist for this amount of time for the Desoot mode to activate.\nSeconds");
MakeNameEx(0x0000E70F, "FUEL_IO_KE_USE_CRANK_EOIT", nameFlags);
MakeRptCmt(0x0000E70F, "Prevent Desoot mode from affecting the end of injection targets\nBOOLEAN");
MakeNameEx(0x0000E710, "FUEL_IO_KE_DESOOT_EOIT", nameFlags);
MakeRptCmt(0x0000E710, "EOIT to use when Desoot mode has been activated\nLores_Periods");
MakeNameEx(0x0000E712, "FUEL_IO_KV_END_OF_INJECTION_CRANK_TARGET", nameFlags);
MakeNameEx(0x0000E732, "FUEL_IO_KV_INJECTOR_TRIM_FACTOR", nameFlags);
MakeRptCmt(0x0000E732, "Allows for scaling of the final injector pulse width for demonstration purposes.\nScaler_0_to_2");
MakeNameEx(0x0000E742, "FUEL_IO_KA_DESOOT_UPDATE_FUEL_CHANNELS", nameFlags);
MakeRptCmt(0x0000E742, "Determines whether to update Fuel Pulse Width for the injector based on the current cylinder when DeSoot mode is active\nBOOLEAN");
MakeNameEx(0x0000E782, "FUEL_IO_KV_FIRST_FUEL_DELAY", nameFlags);
MakeRptCmt(0x0000E782, "Number of Ref pulses after sync that must occur before sequentialfuel delivery to allow prime fuel to be used.\nSHORTCARD");
MakeNameEx(0x0000E786, "FUEL_IO_KE_MINIMUM_TRIM_PULSE_WIDTH", nameFlags);
MakeRptCmt(0x0000E786, "\n");
MakeNameEx(0x0000E788, "FUEL_LO_KE_CANISTER_LIMIT", nameFlags);
MakeRptCmt(0x0000E788, "Used to determine if canister purge is active or inactive.\nPercent");
MakeNameEx(0x0000E78A, "FUEL_LO_KE_RPM_HYSTERESIS", nameFlags);
MakeRptCmt(0x0000E78A, "Provides more stability when transitioning from one cell to another.\nRPM");
MakeNameEx(0x0000E78C, "FUEL_LO_KE_MAP_HYSTERESIS", nameFlags);
MakeRptCmt(0x0000E78C, "Provides more stability when transitioning from one cell to another.\nkPa");
MakeNameEx(0x0000E78E, "FUEL_LO_KE_LONG_TERM_IDLE_THROTTLE_THRES", nameFlags);
MakeRptCmt(0x0000E78E, "Throttle threshold used to determine idle condition.\nPercent");
MakeNameEx(0x0000E790, "FUEL_LO_KE_LONG_TERM_IDLE_VEH_SPEED_THRE", nameFlags);
MakeRptCmt(0x0000E790, "Vehicle speed threshold used to determine idle condition.\nMPH");
MakeNameEx(0x0000E792, "FUEL_LO_KV_RPM_BOUNDARY", nameFlags);
MakeRptCmt(0x0000E792, "Boundary for cells based on engine speed.\nRPM");
MakeNameEx(0x0000E798, "FUEL_LO_KV_MAP_BOUNDARY", nameFlags);
MakeRptCmt(0x0000E798, "Boundary for cells based on manifold pressure.\nkPa");
MakeNameEx(0x0000E79E, "FUEL_LO_KE_BLENDING_SELECTED", nameFlags);
MakeRptCmt(0x0000E79E, "Allow blending if target is below the current long term correction.\nTRUE|FALSE");
MakeNameEx(0x0000E7A0, "FUEL_LO_KE_BLENDING_TIMER", nameFlags);
MakeRptCmt(0x0000E7A0, "Time between long term memory blends.\nSeconds");
MakeNameEx(0x0000E7A4, "FUEL_LO_KE_LONG_TERM_DELTA", nameFlags);
MakeRptCmt(0x0000E7A4, "If cell value changes more than this, reset integrator to 1.0.\nNONE 0-2");
MakeNameEx(0x0000E7A6, "FUEL_LO_KV_PLM_REDUCTION_FACTOR", nameFlags);
MakeRptCmt(0x0000E7A6, "Factor to reduce PLM by before applying to pulse width.\nNONE 0-1");
MakeNameEx(0x0000E7E8, "FUEL_LO_KE_ADAPTIVE_LOW_COOLANT_LIMIT", nameFlags);
MakeRptCmt(0x0000E7E8, "Minimum coolant temperature to allow long term cell update.\nDegrees_C");
MakeNameEx(0x0000E7EA, "FUEL_LO_KE_ADAPTIVE_HIGH_COOLANT_LIMIT", nameFlags);
MakeRptCmt(0x0000E7EA, "Maximum coolant temperature to allow long term cell update.\nDegrees_C");
MakeNameEx(0x0000E7EC, "FUEL_LO_KE_LONG_TERM_CORRECTION_ENABLED", nameFlags);
MakeRptCmt(0x0000E7EC, "Indicates long term cell update is enabled.\nTRUE|FALSE");
MakeNameEx(0x0000E7EE, "FUEL_LO_KE_UPDATE_THRESHOLD", nameFlags);
MakeRptCmt(0x0000E7EE, "Amount the integrator must be above or below 1.0 for an update to occur.\nNONE 0-2");
MakeNameEx(0x0000E7F0, "FUEL_LO_KE_UPDATE_DELTA", nameFlags);
MakeRptCmt(0x0000E7F0, "Value of the long term update amount.\nNONE 0-2");
MakeNameEx(0x0000E7F2, "FUEL_LO_KE_LONG_TERM_MINIMUM", nameFlags);
MakeRptCmt(0x0000E7F2, "Minimum long term correction.\nNONE 0-2");
MakeNameEx(0x0000E7F4, "FUEL_LO_KE_LONG_TERM_IDLE_MAXIMUM", nameFlags);
MakeRptCmt(0x0000E7F4, "Maximum long term correction for idle purge cells.\nNONE 0-2");
MakeNameEx(0x0000E7F6, "FUEL_LO_KE_LONG_TERM_IDLE_MINIMUM", nameFlags);
MakeRptCmt(0x0000E7F6, "Minimum long term correction for idle purge cells.\nNONE 0-2");
MakeNameEx(0x0000E7F8, "FUEL_LO_KE_LONG_TERM_MAXIMUM", nameFlags);
MakeRptCmt(0x0000E7F8, "Maximum long term correction.\nNONE 0-2");
MakeNameEx(0x0000E7FA, "FUEL_LO_KE_LONG_TERM_UPDATE_RATE", nameFlags);
MakeRptCmt(0x0000E7FA, "Time required for update condition to exist to allow Long Term Adaptive update.\nSeconds");
MakeNameEx(0x0000E7FC, "FUEL_LO_KE_PLM_INCREASE_DELTA", nameFlags);
MakeRptCmt(0x0000E7FC, "Value to increase PLM by when learning up.\nNONE 0-2");
MakeNameEx(0x0000E7FE, "FUEL_LO_KE_PLM_REDUCTION_DELTA", nameFlags);
MakeRptCmt(0x0000E7FE, "Value to reduce PLM by when learning down.\nNONE 0-2");
MakeNameEx(0x0000E800, "FUEL_LO_KE_ADAPTIVE_NON_PURGE_MAX_KAM_LI", nameFlags);
MakeRptCmt(0x0000E800, "Max BLM which can be learned in KAM for non-CCP cells\nNONE 0-2");
MakeNameEx(0x0000E802, "FUEL_LO_KE_ADAPTIVE_PURGE_MAX_KAM_LIMIT", nameFlags);
MakeRptCmt(0x0000E802, "Max BLM which can be learned in KAM for CCP cells\nNONE 0-2");
MakeNameEx(0x0000E804, "FUEL_LO_KV_ADAPTIVE_MIN_KAM_LIMIT", nameFlags);
MakeRptCmt(0x0000E804, "Minimum block learn modifier which can be learned in KAM.\nNONE 0-2");
MakeNameEx(0x0000E80A, "FUEL_LO_KV_PLM_UPDATE_OFFSET", nameFlags);
MakeRptCmt(0x0000E80A, "If the BLM for the cell falls more than this offset below the BLM in KAM for the cell, the PLM is decrease.\nNONE 0-2");
MakeNameEx(0x0000E832, "FUEL_LO_KE_NON_CCP_KAM_LOW_COOLANT_LIMIT", nameFlags);
MakeRptCmt(0x0000E832, "Lower limit of coolant window to tranfer non-CCP BLM values to KAM.\nDegrees_C");
MakeNameEx(0x0000E834, "FUEL_LO_KE_NON_CCP_KAM_HIGH_COOLANT_LIMI", nameFlags);
MakeRptCmt(0x0000E834, "Upper limit of coolant window to tranfer non-CCP BLM values to KAM.\nDegrees_C");
MakeNameEx(0x0000E836, "FUEL_LO_KV_PLM_MINIMUM", nameFlags);
MakeRptCmt(0x0000E836, "Minimum PLM correction.\nNONE 0-2");
MakeNameEx(0x0000E83A, "FUEL_LO_KV_ADAPTIVE_LOW_MAP_LIMIT", nameFlags);
MakeRptCmt(0x0000E83A, "Mimimum manifold pressure to allow long term cell update.\nkPa");
MakeNameEx(0x0000E844, "FUEL_O2_KE_POST_DERIVATIVE_TERM_FILTER", nameFlags);
MakeRptCmt(0x0000E844, "Time coefficient for first order lag filter.\nNONE 0-1");
MakeNameEx(0x0000E846, "FUEL_O2_KE_POST_PROPORTIONAL_IDLE_FACTOR", nameFlags);
MakeRptCmt(0x0000E846, "Modifier to proportional offset in idle condition to reduce the aggressiveness of proportional term.\nScaler 2");
MakeNameEx(0x0000E848, "FUEL_O2_KE_LONG_TERM_IDLETHROTTLE_THRESH", nameFlags);
MakeRptCmt(0x0000E848, "Throttle threshold used to determine idle condition.\nPercent");
MakeNameEx(0x0000E84A, "FUEL_O2_KE_LONG_TERM_IDLE_VEH_SPD_THRESH", nameFlags);
MakeRptCmt(0x0000E84A, "Vehicle speed threshold used to determine idle condition.\nSHORTCARD");
MakeNameEx(0x0000E84C, "FUEL_O2_KE_POST_OXYGEN_LEAN_READY", nameFlags);
MakeRptCmt(0x0000E84C, "Lower voltage threshold to determine when the oxygen sensor is ready.\nMillivolts");
MakeNameEx(0x0000E84E, "FUEL_O2_KE_POST_OXYGEN_RICH_READY", nameFlags);
MakeRptCmt(0x0000E84E, "Upper voltage threshold to determine when the oxygen sensor is ready.\nMillivolts");
MakeNameEx(0x0000E850, "FUEL_O2_KE_POST_OXYGEN_READY_COUNTER", nameFlags);
MakeRptCmt(0x0000E850, "Count number of samples outside the control limits to determine when the sensor hsa become ready.\nCounts");
MakeNameEx(0x0000E851, "FUEL_O2_KE_BANK_EXHAUST", nameFlags);
MakeRptCmt(0x0000E851, "Configuration of the exhaust system for the specific application.\nValue");
MakeNameEx(0x0000E852, "FUEL_O2_KE_POST_OXYGEN_INTEGRAL_COOLANT", nameFlags);
MakeRptCmt(0x0000E852, "Threshold for coolant temperature to enable Integral Part of Post Oxygen Fuel Trim.\nDegrees_C");
MakeNameEx(0x0000E854, "FUEL_O2_KV_POST_OXYGEN_BANK1_INTEGRATOR", nameFlags);
MakeRptCmt(0x0000E854, "Closed loop integrator enable criteria for post oxygen control.\nNONE 0-2");
MakeNameEx(0x0000E85E, "FUEL_O2_KV_POST_OXYGEN_BANK2_INTEGRATOR", nameFlags);
MakeRptCmt(0x0000E85E, "Closed loop integrator enable criteria for post oxygen control.\nNONE 0-2");
MakeNameEx(0x0000E868, "FUEL_O2_KE_POST_O2_DECEL_UPPER_LIMIT", nameFlags);
MakeRptCmt(0x0000E868, "Post O2 mode is DECEL if closed loop mode is greater than 0 and less than or equal to this calibration.\nNONE 0-64");
MakeNameEx(0x0000E86A, "FUEL_O2_KE_POST_O2_CRUISE_UPPER_LIMIT", nameFlags);
MakeNameEx(0x0000E86C, "FUEL_O2_KE_POST_O2_LIGHT_ACCEL_UPPER_LIM", nameFlags);
MakeNameEx(0x0000E86E, "FUEL_O2_KE_POST_TIME_CONSTANT", nameFlags);
MakeRptCmt(0x0000E86E, "Time coefficient for first order lag filter.\nNONE 0-1");
MakeNameEx(0x0000E870, "FUEL_O2_KV_POST_OXYGEN_INT_OFFSET_MAX", nameFlags);
MakeRptCmt(0x0000E870, "Limit maximum value of Post_Oxygen_Integral_Offset.\nMillivolts");
MakeNameEx(0x0000E87A, "FUEL_O2_KV_POST_OXYGEN_INT_OFFSET_MIN", nameFlags);
MakeRptCmt(0x0000E87A, "Limit minimum value of Post_Oxygen_Integral_Offset.\nMillivolts");
MakeNameEx(0x0000E884, "FUEL_O2_KV_BANK1_POST_LEAN_THRESHOLD", nameFlags);
MakeRptCmt(0x0000E884, "Post Oxygen lower threshold.\nMillivolts");
MakeNameEx(0x0000E88E, "FUEL_O2_KV_BANK2_POST_LEAN_THRESHOLD", nameFlags);
MakeRptCmt(0x0000E88E, "Post Oxygen lower threshold.\nMillivolts");
MakeNameEx(0x0000E898, "FUEL_O2_KV_BANK1_POST_RICH_THRESHOLD", nameFlags);
MakeRptCmt(0x0000E898, "Post Oxygen upper threshold.\nMillivolts");
MakeNameEx(0x0000E8A2, "FUEL_O2_KV_BANK2_POST_RICH_THRESHOLD", nameFlags);
MakeRptCmt(0x0000E8A2, "Post Oxygen upper threshold.\nMillivolts");
MakeNameEx(0x0000E8AC, "FUEL_O2_KE_POST_OXYGEN_INTEGRATE", nameFlags);
MakeRptCmt(0x0000E8AC, "Integration value for post Oxygen transitions.\nMillivolts");
MakeNameEx(0x0000E8AE, "FUEL_O2_KV_POST_OXYGEN_INTEGRAL_DELAY", nameFlags);
MakeRptCmt(0x0000E8AE, "Delay time between execution of the post oxygen integral correction.\nSeconds");
MakeNameEx(0x0000E8B8, "FUEL_O2_KV_POST_DERIV_DISABLE_TIME", nameFlags);
MakeRptCmt(0x0000E8B8, "Disable derivative offsets after starts for this amount of time.\nSeconds");
MakeNameEx(0x0000E8CC, "FUEL_O2_KV_POST_DERIV_RAMP_IN_TIME", nameFlags);
MakeRptCmt(0x0000E8CC, "Once enabled, ramp the derivative offsets to desired values by this time.\nSeconds");
MakeNameEx(0x0000E8E0, "FUEL_O2_KV_POST_OXYGEN_DERIVATIVE_OFFSET", nameFlags);
MakeRptCmt(0x0000E8E0, "Apply this additive offset as derivative term based on filtered PO2 signal.\nMillivolts");
MakeNameEx(0x0000E90A, "FUEL_O2_KV_POST_O2_PROPORTIONAL_OFFSET", nameFlags);
MakeRptCmt(0x0000E90A, "Apply this additive offset as proportional term based on filtered PO2 signal.\nMillivolts");
MakeNameEx(0x0000E944, "FUEL_O2_KV_POST_PROP_DISABLE_TIME", nameFlags);
MakeRptCmt(0x0000E944, "Disable proportional offsets after starts for this amount of time.\nSeconds");
MakeNameEx(0x0000E958, "FUEL_O2_KV_POST_PROP_RAMP_IN_TIME", nameFlags);
MakeRptCmt(0x0000E958, "Once enabled, ramp the proportional offsets to desired values by this time.\nSeconds");
MakeNameEx(0x0000E96C, "FUEL_PL_KV_INJECTOR_SLOPE", nameFlags);
MakeRptCmt(0x0000E96C, "Defines the slope of the injector versus on time.\nGrams/Sec");
MakeNameEx(0x0000E98E, "FUEL_PL_KV_FLOW_RATE_PUMP_CORRECTION", nameFlags);
MakeRptCmt(0x0000E98E, "Correction to injector flow rate based on fuel pump voltage, Ignition voltage.\nMult0to8");
MakeNameEx(0x0000E9C6, "FUEL_PL_KE_SHORT_PULSE_LIMIT", nameFlags);
MakeRptCmt(0x0000E9C6, "Pulses shorter than this will be increased by an amount KV_Short_pulse_Adjustment.\nMilliseconds");
MakeNameEx(0x0000E9C8, "FUEL_PL_KV_SHORT_PULSE_ADJUSTMENT", nameFlags);
MakeNameEx(0x0000EA4E, "FUEL_PL_KV_MINIMUM_PULSE_WIDTH", nameFlags);
MakeRptCmt(0x0000EA4E, "This is the minimum pulse width allowed.\nMilliseconds");
MakeNameEx(0x0000EA78, "FUEL_PL_KV_DEFAULT_PULSE_WIDTH", nameFlags);
MakeRptCmt(0x0000EA78, "This is the default pulse width used when the pulse is less than the minimum.\nMilliseconds");
MakeNameEx(0x0000EAA2, "FUEL_PL_KE_USE_INJ_SLOPE_MODIFIER", nameFlags);
MakeRptCmt(0x0000EAA2, "Determines if the Injector Slope will be modified for fuel flow.\nBOOLEAN");
MakeNameEx(0x0000EAA4, "FUEL_PL_KV_INJ_SLOPE_FUEL_FLOW_MOD", nameFlags);
MakeRptCmt(0x0000EAA4, "The correction to injector flow based on fuel flow rate.\nUnitless");
MakeNameEx(0x0000EABC, "FUEL_SH_KE_CL_IDLE_THROTTLE_POSITION", nameFlags);
MakeRptCmt(0x0000EABC, "Throttle position must be less than this calibration for Cl_Idle to be TRUE.\nPercent");
MakeNameEx(0x0000EABE, "FUEL_SH_KE_CL_IDLE_THROTTLE_HYSTERESIS", nameFlags);
MakeRptCmt(0x0000EABE, "Throttle position hysteresis for CL_Idle determination.\nPercent");
MakeNameEx(0x0000EAC0, "FUEL_SH_KE_CL_IDLE_VEHICLE_SPEED", nameFlags);
MakeRptCmt(0x0000EAC0, "Vehicle Speed must be less than this for CL_Idle to be TRUE.\nMPH");
MakeNameEx(0x0000EAC2, "FUEL_SH_KE_CL_IDLE_VEHICLE_SPEED_HYSTERE", nameFlags);
MakeRptCmt(0x0000EAC2, "Vehicle Speed hysteresis for CL_Idle determination.\nMPH");
MakeNameEx(0x0000EAC4, "FUEL_SH_KE_CL_LOW_RPM_RESET_COOLANT_TEMP", nameFlags);
MakeRptCmt(0x0000EAC4, "Coolant must be warmer than this to enable or trigger 'Low RPM Closed Loop Reset'.\nDegrees_C");
MakeNameEx(0x0000EAC6, "FUEL_SH_KE_CL_LOW_RPM_RESET_ENABLE_OFFSE", nameFlags);
MakeRptCmt(0x0000EAC6, "Engine speed must exceed 'desired idle speed' BY more than this to enable 'Low RPM Closed Loop Reset'.\nRPM");
MakeNameEx(0x0000EAC8, "FUEL_SH_KE_CL_LOW_RPM_RESET_INTEGRAL_TER", nameFlags);
MakeNameEx(0x0000EACA, "FUEL_SH_KE_CL_LOW_RPM_RESET_TRIGGER_OFFS", nameFlags);
MakeNameEx(0x0000EACC, "FUEL_SH_KV_CL_MODE", nameFlags);
MakeNameEx(0x0000EB6E, "FUEL_SH_KV_INTEGRAL_DELAY_BASE_LEAN", nameFlags);
MakeRptCmt(0x0000EB6E, "Base factor applied to the Integral_Delay_Base when both Slow and Fast O2 status are LEAN.\nSeconds");
MakeNameEx(0x0000EB80, "FUEL_SH_KV_INTEGRAL_DELAY_BASE_RICH", nameFlags);
MakeRptCmt(0x0000EB80, "Base factor applied to the Integral_Delay_Base when both Slow and Fast O2 status are RICH.\nSeconds");
MakeNameEx(0x0000EB92, "FUEL_SH_KV_INTEGRAL_DELAY_GAIN_LEAN", nameFlags);
MakeRptCmt(0x0000EB92, "Gain factor applied to the Integral_Delay_Base when both Slow and Fast O2 status are LEAN.\nNONE 0-2");
MakeNameEx(0x0000EBAC, "FUEL_SH_KV_INTEGRAL_DELAY_GAIN_RICH", nameFlags);
MakeRptCmt(0x0000EBAC, "Gain factor applied to the Integral_Delay_Base when both Slow and Fast O2 status are RICH.\nNONE 0-2");
MakeNameEx(0x0000EBC6, "FUEL_SH_KE_INTEGRAL_TERM_ADJUSTMENT_IDLE", nameFlags);
MakeRptCmt(0x0000EBC6, "Magnitude of adjustments to integral term under idle conditions.\nNONE 0-2");
MakeNameEx(0x0000EBC8, "FUEL_SH_KE_INTEGRAL_TERM_MINIMUM", nameFlags);
MakeRptCmt(0x0000EBC8, "The minimum integrator factor value allowed in closed loopmode.\nNONE 0-2");
MakeNameEx(0x0000EBCA, "FUEL_SH_KE_INTEGRAL_TERM_MINIMUM_AF_CL", nameFlags);
MakeRptCmt(0x0000EBCA, "The minimum integrator factor value allowed in Air FuelClosed Loop mode.\nNONE 0-2");
MakeNameEx(0x0000EBCC, "FUEL_SH_KE_INTEGRAL_TERM_MAXIMUM", nameFlags);
MakeRptCmt(0x0000EBCC, "The maximum allowed integrator value.\nNONE 0-2");
MakeNameEx(0x0000EBCE, "FUEL_SH_KV_INTEGRAL_TERM_ADJUSTMENT_LEAN", nameFlags);
MakeNameEx(0x0000EBE0, "FUEL_SH_KV_INTEGRAL_TERM_ADJUSTMENT_RICH", nameFlags);
MakeNameEx(0x0000EBF2, "FUEL_SH_KE_O2_AFTER_START_THRESHOLD_OFF", nameFlags);
MakeRptCmt(0x0000EBF2, "Offset added to O2 Rich Lean threshold. For Holden Vehicle only.\nMillivolts");
MakeNameEx(0x0000EBF4, "FUEL_SH_KE_O2_COLD_TEMPERATURE", nameFlags);
MakeNameEx(0x0000EBF6, "FUEL_SH_KE_O2_COLD_TIME", nameFlags);
MakeRptCmt(0x0000EBF6, "The offset is added to the Rich Lean threshold as long as Engine run time is less this. Used for Holden vehicles only.\nSeconds");
MakeNameEx(0x0000EBF8, "FUEL_SH_KV_O2_RICH_LEAN_THRESHOLD", nameFlags);
MakeRptCmt(0x0000EBF8, "Oxygen sensor voltage level for rich/lean decision\nMilliVolts");
MakeNameEx(0x0000EC1C, "FUEL_SH_KV_O2_OFF_RICH_LEAN_THRESHOLD", nameFlags);
MakeNameEx(0x0000EC40, "FUEL_SH_KE_PROPORTIONAL_TERM_IDLE_ENABLE", nameFlags);
MakeRptCmt(0x0000EC40, "Use specially formed idle proportional term at idle.\nTRUE_FALSE");
MakeNameEx(0x0000EC42, "FUEL_SH_KV_PROPORTIONAL_TERM_IDLE_BASE", nameFlags);
MakeRptCmt(0x0000EC42, "Proportional term base for each bank under idle conditions\nNONE 0-2");
MakeNameEx(0x0000EC54, "FUEL_SH_KV_PROPORTIONAL_TERM_IDLE_GAIN", nameFlags);
MakeRptCmt(0x0000EC54, "Gain factor applied to proportional term base for each bank under idle conditions\nNONE 0-2");
MakeNameEx(0x0000EC6E, "FUEL_SH_KV_PROP_TERM_NORMAL_BASE_LEAN", nameFlags);
MakeRptCmt(0x0000EC6E, "Base size of proportional term under normal (non-idle) conditions when Fast O2 Status is LEAN.\nNONE 0-2");
MakeNameEx(0x0000EC80, "FUEL_SH_KV_PROP_TERM_NORMAL_BASE_RICH", nameFlags);
MakeRptCmt(0x0000EC80, "Base size of proportional term under normal (non-idle) conditions when Fast O2 Status is RICH.\nNONE 0-2");
MakeNameEx(0x0000EC92, "FUEL_SH_KV_PROP_TERM_NORMAL_GAIN_LEAN", nameFlags);
MakeRptCmt(0x0000EC92, "Gain factor applied to proportional term under normal (non-idle) conditions when Fast O2 Status is LEAN.\nNONE 0-2");
MakeNameEx(0x0000ECAC, "FUEL_SH_KV_PROP_TERM_NORMAL_GAIN_RICH", nameFlags);
MakeRptCmt(0x0000ECAC, "Gain factor applied to proportional term under normal (non-idle) conditions when Fast O2 Status is RICH.\nNONE 0-2");
MakeNameEx(0x0000ECC6, "FUEL_SH_KE_PROPORTIONAL_TERM_AIRFUEL_GAI", nameFlags);
MakeRptCmt(0x0000ECC6, "Gain applied to proportional term when in Airfuel_Closedloop.\nNONE 0-2");
MakeNameEx(0x0000ECC8, "FUEL_SH_KV_SLOW_O2_FILTER", nameFlags);
MakeRptCmt(0x0000ECC8, "Filter constant for slow O2 voltage (long term mixture estimate for each bank (1 = Left; 2 = Right)\nSeconds");
MakeNameEx(0x0000ECDC, "FUEL_SH_KV_SLOW_O2_FILTER_FOR_CCP", nameFlags);
MakeRptCmt(0x0000ECDC, "Filter constant for slow O2 voltage (long term mixture estimatefor each bank (1 = Left; 2 = Right). Only used for CCP.\nSeconds");
MakeNameEx(0x0000ECF0, "FUEL_SH_KE_O2_MIN_RICH_LEAN_THRESHOLD", nameFlags);
MakeRptCmt(0x0000ECF0, "O2 Rich Lean Threshold is min limited to this value after all the offset are added.\nMiilivots");
MakeNameEx(0x0000ECF2, "FUEL_SH_KE_O2_MAX_RICH_LEAN_THRESHOLD", nameFlags);
MakeRptCmt(0x0000ECF2, "O2 Rich Lean Threshold is max limited to this value after all the offset are added.\nMiilivots");
MakeNameEx(0x0000ECF4, "FUEL_SH_KE_O2_R_L_COLD_OFFSET_COOLANT", nameFlags);
MakeRptCmt(0x0000ECF4, "Offset added to O2 Rich Lean threshold when Coolant Temperature is less than this and engine run time is below a Cal.\nDegrees C");
MakeNameEx(0x0000ECF6, "FUEL_SH_KE_O2_R_L_COLD_OFFSET_TIME", nameFlags);
MakeRptCmt(0x0000ECF6, "Offset added to O2 Rich Lean threshold when engine run time is less than this and coolant is below a Cal.\nSeconds");
MakeNameEx(0x0000ECF8, "FUEL_SH_KE_O2_RICH_LEAN_COLD_OFFSET", nameFlags);
MakeNameEx(0x0000ECFA, "FUEL_SH_KE_TPS_LAUNCH_TPS_THRESH", nameFlags);
MakeRptCmt(0x0000ECFA, "Threshold for determining closed TPS for launch integrator reset.\nPercent");
MakeNameEx(0x0000ECFC, "FUEL_SH_KE_TPS_LAUNCH_MPH_THRESH", nameFlags);
MakeRptCmt(0x0000ECFC, "Vehicle speed below which a launch condition will be allowed.\nMPH");
MakeNameEx(0x0000ECFE, "FUEL_SH_KE_TPS_LAUNCH_INT_THRESH", nameFlags);
MakeRptCmt(0x0000ECFE, "Fuel integrator value below which integrators can reset on a launch condition.\nUnitless");
MakeNameEx(0x0000ED00, "FUEL_SH_KV_CL_MINIMUM_MANIFOLD_PRESSURE", nameFlags);
MakeNameEx(0x0000ED0A, "FUEL_ST_KE_OXYGEN_LOWER_READY_VOLTAGE", nameFlags);
MakeRptCmt(0x0000ED0A, "Lower voltage threshold in which the oxygen sensor voltage must fall below before indicating oxygen sensor ready.\nMillivolts");
MakeNameEx(0x0000ED0C, "FUEL_ST_KE_OXYGEN_UPPER_READY_VOLTAGE", nameFlags);
MakeRptCmt(0x0000ED0C, "Upper voltage threshold in which the oxygen sensor voltage must go above before indicating oxygen sensor ready.\nMillivolts");
MakeNameEx(0x0000ED0E, "FUEL_ST_KE_OXYGEN_NOT_READY_TIME", nameFlags);
MakeNameEx(0x0000ED10, "FUEL_ST_KE_COLD_CLOSED_LOOP_TEMPERATURE", nameFlags);
MakeRptCmt(0x0000ED10, "Startup coolant temperature below which the cold wait timer, KE_Cold_Wait_Time, is used.\nDegrees_C");
MakeNameEx(0x0000ED12, "FUEL_ST_KE_HOT_CLOSED_LOOP_TEMPERATURE", nameFlags);
MakeRptCmt(0x0000ED12, "Startup coolant temperature above which the hot wait timer, KE_Hot_Wait_Time, is used.\nDegrees_C");
MakeNameEx(0x0000ED14, "FUEL_ST_KE_COLD_WAIT_TIME", nameFlags);
MakeRptCmt(0x0000ED14, "Engine run time before closed loop is allowed when startup coolant is below KE_Cold_Closed_Loop_Temperature.\nSeconds");
MakeNameEx(0x0000ED16, "FUEL_ST_KE_WARM_WAIT_TIME", nameFlags);
MakeNameEx(0x0000ED18, "FUEL_ST_KE_HOT_WAIT_TIME", nameFlags);
MakeRptCmt(0x0000ED18, "Engine run time before closed loop is allowed when startup coolant is above KE_Hot_Closed_Loop_Temperature.\nSeconds");
MakeNameEx(0x0000ED1A, "FUEL_ST_KV_CLOSED_LOOP_COOLANT_TEMPERATU", nameFlags);
MakeRptCmt(0x0000ED1A, "Defines the coolant temperature above which closed loop fuel is allowed.\nDegrees_C");
MakeNameEx(0x0000ED40, "FUEL_ST_KE_USE_AIRFUEL_CLOSED_LOOP_STATE", nameFlags);
MakeNameEx(0x0000ED41, "FUEL_ST_KE_O2_READY_COUNTER_THRESHOLD", nameFlags);
MakeRptCmt(0x0000ED41, "Number of O2 reads that must fall outside not ready window for the O2 sensor to be ready.\nCounter");
MakeNameEx(0x0000ED42, "FUEL_ST_KE_OPEN_LOOP_FOR_MISFIRE", nameFlags);
MakeRptCmt(0x0000ED42, "If this calibration is set TRUE, any Misfire faults will force Afterstart mode and reset LTM Fuel Cells.\nTRUE | FALSE");
MakeNameEx(0x0000ED44, "IAC_AIRFLOW_KE_IDLE_AREA_SCALAR", nameFlags);
MakeRptCmt(0x0000ED44, "Conversion factor to convert to percent WOT from an effective throttle area in millimeters squared.\nPercent_Per_mm_Squared");
MakeNameEx(0x0000ED46, "IAC_AIRFLOW_KE_THROTTLE_CRACKER_DISABLE_THRE", nameFlags);
MakeRptCmt(0x0000ED46, "Vehicle speed must be <= to this calibration to disable the extended throttle cracker function.\nMPH");
MakeNameEx(0x0000ED48, "IAC_AIRFLOW_KE_THROTTLE_CRACKER_ENABLE_THRES", nameFlags);
MakeRptCmt(0x0000ED48, "Vehicle speed must be >= to this calibration to enable the extended throttle cracker function.\nMPH");
MakeNameEx(0x0000ED4A, "IAC_AIRFLOW_KE_AC_OFFSET_FILTER_CONSTANT", nameFlags);
MakeRptCmt(0x0000ED4A, "Filter coefficient for first order lag filter.\nFilt_Coeff");
MakeNameEx(0x0000ED4C, "IAC_AIRFLOW_KE_CHOKE_FLOW_TIME", nameFlags);
MakeRptCmt(0x0000ED4C, "Calibration used before engine is running to generate desired effective area based on choke flow pressure ratio.\nSeconds");
MakeNameEx(0x0000ED4E, "IAC_AIRFLOW_KE_COOLING_FAN_CORRECTION", nameFlags);
MakeRptCmt(0x0000ED4E, "Default value of airflow required to compensate for the parasitic load from a single cooling fan.\nGPS");
MakeNameEx(0x0000ED50, "IAC_AIRFLOW_KE_COOLING_FANS_CORRECTION", nameFlags);
MakeRptCmt(0x0000ED50, "Default value of airflow required to compensate for the parasitic load from multiple cooling fans.\nGPS");
MakeNameEx(0x0000ED52, "IAC_AIRFLOW_KE_DFCO_ENTRANCE_HOLD_TIME", nameFlags);
MakeRptCmt(0x0000ED52, "The amount of time to hold decel fuel cutoff airflow before decaying it away.\nSeconds");
MakeNameEx(0x0000ED54, "IAC_AIRFLOW_KE_DFCO_ENTRY_RAMP_RATE", nameFlags);
MakeRptCmt(0x0000ED54, "This calibration increases or decreases the decel fuel cutoff air value when decel fuel cutoff is entered.\nGPS");
MakeNameEx(0x0000ED56, "IAC_AIRFLOW_KE_DFCO_EXIT_RAMP_RATE", nameFlags);
MakeRptCmt(0x0000ED56, "This calibration increases or decreases the decel fuel cutoff air value when decel fuel cutoff is exited.\nGPS");
MakeNameEx(0x0000ED58, "IAC_AIRFLOW_KE_DRIVE_CORRECTION_HIGH", nameFlags);
MakeRptCmt(0x0000ED58, "Upper limit allowed for adaptively learned correction to the airflow for the engine when the transmission is in gear.\nGPS");
MakeNameEx(0x0000ED5A, "IAC_AIRFLOW_KE_DRIVE_CORRECTION_LOW", nameFlags);
MakeRptCmt(0x0000ED5A, "Lower limit allowed for adaptively learned correction to the airflow for the engine when the transmission is in gear.\nGPS");
MakeNameEx(0x0000ED5C, "IAC_AIRFLOW_KE_DRIVE_FILTER_CONSTANT", nameFlags);
MakeRptCmt(0x0000ED5C, "Filter coefficient for first order lag filter for filtering Learned_Airflow_Drive.  Activation rate:  25 ms.\nFilt_Coeff");
MakeNameEx(0x0000ED5E, "IAC_AIRFLOW_KE_FAN_INHIBIT_REGULATOR_TIME", nameFlags);
MakeRptCmt(0x0000ED5E, "The constant speed regulator will be inhibited for this period of time when the Fan1 or Fan2 load has been applied or released.\nSeconds");
MakeNameEx(0x0000ED60, "IAC_AIRFLOW_KE_HIGH_TO_LOW_PRESSURE_TIME", nameFlags);
MakeNameEx(0x0000ED62, "IAC_AIRFLOW_KE_IDLE_TO_OFFIDLE_TIME", nameFlags);
MakeRptCmt(0x0000ED62, "Calibration to enable reset of Breakaway_Friction_Airflow if the engine running time equals this value.\nSeconds");
MakeNameEx(0x0000ED64, "IAC_AIRFLOW_KE_LEARNED_AC_AIRFLOW_OFFSET_DR", nameFlags);
MakeRptCmt(0x0000ED64, "Default value of AC_Airflow_Learned_Offset_DR.\nGPS");
MakeNameEx(0x0000ED66, "IAC_AIRFLOW_KE_LEARNED_AC_AIRFLOW_OFFSET_PN", nameFlags);
MakeRptCmt(0x0000ED66, "Default value of AC_Airflow_Learned_Offset_PN.\nGPS");
MakeNameEx(0x0000ED68, "IAC_AIRFLOW_KE_AC_OFFSET_LOW_DR", nameFlags);
MakeRptCmt(0x0000ED68, "Lower limit allowed for adaptively learned correctionto the AC airflow offset while in a drive gear or a manual.\nGPS");
MakeNameEx(0x0000ED6A, "IAC_AIRFLOW_KE_AC_OFFSET_HIGH_DR", nameFlags);
MakeRptCmt(0x0000ED6A, "Upper limit allowed for adaptively learned correctionto the AC airflow offset while in a drive gear or a manual.\nGPS");
MakeNameEx(0x0000ED6C, "IAC_AIRFLOW_KE_AC_OFFSET_LOW_PN", nameFlags);
MakeRptCmt(0x0000ED6C, "Lower limit allowed for adaptively learned correctionto the AC airflow offset while in park or neutralin an automatic.\nGPS");
MakeNameEx(0x0000ED6E, "IAC_AIRFLOW_KE_AC_OFFSET_HIGH_PN", nameFlags);
MakeRptCmt(0x0000ED6E, "Upper limit allowed for adaptively learned correctionto the AC airflow offset while in park or neutralin an automatic.\nGPS");
MakeNameEx(0x0000ED70, "IAC_AIRFLOW_KE_LEARNED_AIRFLOW_DRIVE", nameFlags);
MakeRptCmt(0x0000ED70, "Default value of Learned_Airflow_Drive.\nGPS");
MakeNameEx(0x0000ED72, "IAC_AIRFLOW_KE_LEARNED_AIRFLOW_PARK_NEUTRAL", nameFlags);
MakeRptCmt(0x0000ED72, "Default value of Learned_Airflow_Park_Neutral.\nGPS");
MakeNameEx(0x0000ED74, "IAC_AIRFLOW_KE_LOW_TO_HIGH_PRESSURE_TIME", nameFlags);
MakeNameEx(0x0000ED76, "IAC_AIRFLOW_KE_MAP_AD_FAIL_THRESHOLD", nameFlags);
MakeRptCmt(0x0000ED76, "Calibration used to determine the closed throttle  maximum AD MAP.\nA/D Counts");
MakeNameEx(0x0000ED78, "IAC_AIRFLOW_KE_MAP_FOR_IAC_RESET", nameFlags);
MakeRptCmt(0x0000ED78, "Calibration used to control IAC motor park position since MAP goes to baro on engine shut down.\nkPa");
MakeNameEx(0x0000ED7A, "IAC_AIRFLOW_KE_MAX_DESIRED_IDLE_EFF_AREA", nameFlags);
MakeNameEx(0x0000ED7C, "IAC_AIRFLOW_KE_PARK_NEUTRAL_CORRECTION_HIGH", nameFlags);
MakeRptCmt(0x0000ED7C, "Upper limit allowed for adaptively learned correction to the airflow for the engine when the transmission is not in gear.\nGPS");
MakeNameEx(0x0000ED7E, "IAC_AIRFLOW_KE_PARK_NEUTRAL_CORRECTION_LOW", nameFlags);
MakeRptCmt(0x0000ED7E, "Lower limit allowed for adaptively learned correction to the airflow for the engine when the transmission is not in gear.\nGPS");
MakeNameEx(0x0000ED80, "IAC_AIRFLOW_KE_PARK_NEUTRAL_FILTER_CONSTANT", nameFlags);
MakeRptCmt(0x0000ED80, "Filter coefficient for first order lag filter. Activation rate:  25 ms.\nFilt_Coeff");
MakeNameEx(0x0000ED82, "IAC_AIRFLOW_KE_OFFIDLE_SCALAR", nameFlags);
MakeNameEx(0x0000ED84, "IAC_AIRFLOW_KE_PERCENT_MAF_DEVIATION_FAIL_TH", nameFlags);
MakeNameEx(0x0000ED86, "IAC_AIRFLOW_KV_RAMP_AC_AIRFLOW_IN", nameFlags);
MakeRptCmt(0x0000ED86, "Calibration to ramp the airflow to the required operating point...F(AC Torque Adjusted).\nGPS");
MakeNameEx(0x0000EDA2, "IAC_AIRFLOW_KV_RAMP_AC_AIRFLOW_OUT", nameFlags);
MakeRptCmt(0x0000EDA2, "Calibration to ramp the airflow to zero....F(AC Torque Adjusted).\nGPS");
MakeNameEx(0x0000EDBE, "IAC_AIRFLOW_KE_START_UP_DECAY_INITIAL", nameFlags);
MakeRptCmt(0x0000EDBE, "Calibration defining the delta airflow increment used to decay the start up airflow value\nGPS");
MakeNameEx(0x0000EDC0, "IAC_AIRFLOW_KE_THROTTLE_FOLLOWER_TPS_HYSTERE", nameFlags);
MakeNameEx(0x0000EDC2, "IAC_AIRFLOW_KV_AUTO_TRANS_MAN_DWNSHFT_AIR", nameFlags);
MakeRptCmt(0x0000EDC2, "Amount of airflow necessary to reduce energy differential betweenthe engine and the transmission during a manual downshift\nGPS_S");
MakeNameEx(0x0000EDE6, "IAC_AIRFLOW_KV_CAT_LIGHTOFF_SPARK_AIRFLOW", nameFlags);
MakeRptCmt(0x0000EDE6, "Amount of airflow necessary to replace torque lost due tospecific amounts of catalyst lightoff spark retard\nGPS");
MakeNameEx(0x0000EDFC, "IAC_AIRFLOW_KV_RPM_FOLLOWER_AIRFLOW", nameFlags);
MakeRptCmt(0x0000EDFC, "Used to increasethe RPM follower airflow value based on engine speed\nGPS");
MakeNameEx(0x0000EE26, "IAC_AIRFLOW_KV_BREAKAWAY_AIRFLOW_VALUE", nameFlags);
MakeRptCmt(0x0000EE26, "Incremental value used to decay Breakaway_Friction_Airflow.\nGPS");
MakeNameEx(0x0000EE3A, "IAC_AIRFLOW_KV_BREAKAWAY_FRICTION_AIRFLOW", nameFlags);
MakeRptCmt(0x0000EE3A, "Calibration defining breakaway friction airflow.\nGPS");
MakeNameEx(0x0000EE5A, "IAC_AIRFLOW_KV_BREAKAWAY_FRICTION_DELAY", nameFlags);
MakeRptCmt(0x0000EE5A, "Calibration defining delay before Breakaway_Friction_Airflow starts to decay.\nCAM Revs");
MakeNameEx(0x0000EE6E, "IAC_AIRFLOW_KV_DFCO_DECAY_FILTER_COEFFICIENT", nameFlags);
MakeRptCmt(0x0000EE6E, "Filter coefficient used to decay decel fuel cutoff airflow when exiting decel fuel cutoff.\nFilt_Coeff");
MakeNameEx(0x0000EE92, "IAC_AIRFLOW_KV_DFCO_ENTRANCE_AIRFLOW", nameFlags);
MakeRptCmt(0x0000EE92, "Target decel fuel cutoff airflow value when entering decel fuel cutoff.\nGPS");
MakeNameEx(0x0000EEB6, "IAC_AIRFLOW_KV_DFCO_EXIT_AIRFLOW", nameFlags);
MakeRptCmt(0x0000EEB6, "Target decel fuel cutoff airflow value when exiting decel fuel cutoff.\nGPS");
MakeNameEx(0x0000EEDA, "IAC_AIRFLOW_KV_DRIVE_TO_PARK_NEUTRAL_DELAY", nameFlags);
MakeNameEx(0x0000EEFC, "IAC_AIRFLOW_KV_GEAR_TF_DELAY_TIME", nameFlags);
MakeRptCmt(0x0000EEFC, "Delay time before throttle follower airflow starts to decay when the throttle is closing and the transmission is in gear.\nSeconds");
MakeNameEx(0x0000EF20, "IAC_AIRFLOW_KV_MOTOR_PARK_AIRFLOW", nameFlags);
MakeRptCmt(0x0000EF20, "Required airflow when the IAC motor is parked.\nGPS");
MakeNameEx(0x0000EF34, "IAC_AIRFLOW_KV_NO_GEAR_TF_DECAY_AIRFLOW", nameFlags);
MakeRptCmt(0x0000EF34, "Throttle follower decay airflow value when the transmission is not in gear.  Activation rate: 12.5 ms.\nGPS");
MakeNameEx(0x0000EF58, "IAC_AIRFLOW_KV_NO_GEAR_TF_DELAY_TIME", nameFlags);
MakeRptCmt(0x0000EF58, "Delay time before throttle follower airflow starts to decay when the throttle is closing and the transmission is not in gear.\nSeconds");
MakeNameEx(0x0000EF7C, "IAC_AIRFLOW_KV_PARK_NEUTRAL_TO_DRIVE_DELAY", nameFlags);
MakeNameEx(0x0000EF9E, "IAC_AIRFLOW_KV_SQUARE_ROOT_AIR_TEMPERATURE", nameFlags);
MakeRptCmt(0x0000EF9E, "Used to generate the square root of air temperature.\nDeg_K_Sqrt");
MakeNameEx(0x0000EFBE, "IAC_AIRFLOW_KV_START_UP_AIRFLOW", nameFlags);
MakeRptCmt(0x0000EFBE, "Calibration defining start up airflow required.\nGPS");
MakeNameEx(0x0000EFD2, "IAC_AIRFLOW_KV_START_UP_DELAY_INITIAL", nameFlags);
MakeRptCmt(0x0000EFD2, "Calibration defining number of cam revolutions before Start_Up_Airflow_Initial is reduced.\nCAM Revs");
MakeNameEx(0x0000EFE6, "IAC_AIRFLOW_KV_THROTTLE_CRACKER_AF_DECAY", nameFlags);
MakeRptCmt(0x0000EFE6, "Calibration provides the airflow decay when the transmission state is set to not in gear.\nGPS");
MakeNameEx(0x0000F008, "IAC_AIRFLOW_KV_THROTTLE_CRACKER_AF_DECAY_DEL", nameFlags);
MakeRptCmt(0x0000F008, "Calibration provides the airflow decay delay when the transmission state is set to not in gear.\nSeconds");
MakeNameEx(0x0000F02A, "IAC_AIRFLOW_KV_THROTTLE_FOLLOWER_AIRFLOW", nameFlags);
MakeRptCmt(0x0000F02A, "This calibration is used to increase the throttle follower airflow value based on the position of the throttle.\nGPS");
MakeNameEx(0x0000F04C, "IAC_AIRFLOW_KV_WARMED_UP_AIRFLOW_DRIVE", nameFlags);
MakeRptCmt(0x0000F04C, "Airflow required by engine as coolant temperature is increasing and the transmission is in gear.\nGPS");
MakeNameEx(0x0000F06C, "IAC_AIRFLOW_KV_WARMED_UP_AIRFLOW_PARK_NEUTRA", nameFlags);
MakeRptCmt(0x0000F06C, "Airflow required by engine as coolant temperature is increasing and the transmission is not in gear.\nGPS");
MakeNameEx(0x0000F08C, "IAC_AIRFLOW_KA_GEAR_TF_DECAY_AIRFLOW", nameFlags);
MakeRptCmt(0x0000F08C, "Throttle follower decay airflow value when the transmission is in gear.  Activation rate: 12.5 ms.\nGPS");
MakeNameEx(0x0000F11C, "IAC_AIRFLOW_KA_THROTTLE_CRACKER_AIRFLOW", nameFlags);
MakeRptCmt(0x0000F11C, "This calibration table provides the extended throttle cracker airflow values when the throttle position criteria has been met.\nGPS");
MakeNameEx(0x0000F2B4, "IAC_AIRFLOW_KV_AC_OFF_PI_DELAY", nameFlags);
MakeNameEx(0x0000F2D0, "IAC_AIRFLOW_KV_AC_ON_PI_DELAY", nameFlags);
MakeNameEx(0x0000F2EC, "IAC_AIRFLOW_KE_AIR_LEARN_AIRFLOW_CORR_THRESH", nameFlags);
MakeRptCmt(0x0000F2EC, "Allowable variation between MAF and MAP based airflows to allow learning.\nMilligrams_Per_Cylinder");
MakeNameEx(0x0000F2EE, "IAC_AIRFLOW_KE_AIR_LEARN_COOLANT_TMP_LOW", nameFlags);
MakeRptCmt(0x0000F2EE, "Minimum coolant temperature at which Air Flow Learning can be enabled without interfering with Closed Loop Idle mode\nDegrees_C");
MakeNameEx(0x0000F2F0, "IAC_AIRFLOW_KE_AIR_LEARN_COOLANT_TMP_MIDDLE", nameFlags);
MakeRptCmt(0x0000F2F0, "Minimum coolant temperature at which Air Flow Learning can be enabled without interfering with any idle mode\nDegrees_C");
MakeNameEx(0x0000F2F2, "IAC_AIRFLOW_KE_AIR_LEARN_COOLANT_TMP_HIGH", nameFlags);
MakeRptCmt(0x0000F2F2, "Maximum coolant temperature at which Air Flow Learning can be enabled without interfering with any idle mode\nDegrees_C");
MakeNameEx(0x0000F2F4, "IAC_AIRFLOW_KE_AIR_LEARN_ENGINE_SPEED_MAX", nameFlags);
MakeRptCmt(0x0000F2F4, "MAX engine speed to allow air learning.\nRPM");
MakeNameEx(0x0000F2F6, "IAC_AIRFLOW_KE_AIR_LEARN_ENGINE_SPEED_MIN", nameFlags);
MakeRptCmt(0x0000F2F6, "MIN engine speed to allow air learning.\nRPM");
MakeNameEx(0x0000F2F8, "IAC_AIRFLOW_KE_AIR_LEARN_IND_THRT_PSTN_STAB", nameFlags);
MakeRptCmt(0x0000F2F8, "Maximum allowable variation in indicated Throttle Position to allow learning.\nPercent");
MakeNameEx(0x0000F2FA, "IAC_AIRFLOW_KE_AIR_LEARN_LIMIT", nameFlags);
MakeRptCmt(0x0000F2FA, "Maximum allowable compensation per cell in the Air Learn Correction array.\nPercent_Area_S");
MakeNameEx(0x0000F2FC, "IAC_AIRFLOW_KE_AIR_LEARN_LOW_VACUUM_DISABLE", nameFlags);
MakeRptCmt(0x0000F2FC, "Minimum allowable vacuum to allow learning.\nkPa");
MakeNameEx(0x0000F2FE, "IAC_AIRFLOW_KE_AIR_LEARN_MAX_DELTA", nameFlags);
MakeRptCmt(0x0000F2FE, "Maximum allowable difference between two adjacent cell in Air_Learn Correction array.\nPercent_Area_S");
MakeNameEx(0x0000F300, "IAC_AIRFLOW_KE_AIR_LEARN_STAB_TIMER", nameFlags);
MakeRptCmt(0x0000F300, "Limits learning from occuring every loop to reduce problems with transients.\nSeconds");
MakeNameEx(0x0000F302, "IAC_AIRFLOW_KE_TIME_SINCE_BARO_UPDATED", nameFlags);
MakeRptCmt(0x0000F302, "Maxmimum time allowed without Baro update before disabling Airflow Learning.\nSeconds_L");
MakeNameEx(0x0000F306, "IAC_AIRFLOW_KE_VSDI_INTEGRAL_DELAY", nameFlags);
MakeNameEx(0x0000F308, "IAC_AIRFLOW_KE_VSDI_DISABLE_VEHICLE_SPEED", nameFlags);
MakeRptCmt(0x0000F308, "Vehicle speed must be <= this cal to disable the VSDI mode of the throttle cracker function.\nMPH");
MakeNameEx(0x0000F30A, "IAC_AIRFLOW_KE_VSDI_ENABLE_VEHICLE_SPEED", nameFlags);
MakeRptCmt(0x0000F30A, "Vehicle speed must be > this cal to enable the VSDI mode of the throttle cracker function.\nMPH");
MakeNameEx(0x0000F30C, "IAC_AIRFLOW_KE_VSDI_THROTTLE_POSITION", nameFlags);
MakeRptCmt(0x0000F30C, "If in VSDI mode, use KA_Throttle_Cracker_Airflow to calculate extended throttle cracker, while throttle position is > this cal.\nPercent");
MakeNameEx(0x0000F30E, "IAC_AIRFLOW_KV_AIR_LEARN_RATE_LIMIT_DOWN", nameFlags);
MakeRptCmt(0x0000F30E, "Rate limit constant for increasing airflow.\nPercent_Area");
MakeNameEx(0x0000F33A, "IAC_AIRFLOW_KV_AIR_LEARN_RATE_LIMIT_UP", nameFlags);
MakeRptCmt(0x0000F33A, "Rate limit constant for increasing airflow.\nPercent_Area");
MakeNameEx(0x0000F366, "IAC_AIRFLOW_KV_ENG_SPD_OFFSET_AFLW_DR", nameFlags);
MakeRptCmt(0x0000F366, "Amount of airflow required to compensate for a temporary engine speed offset while in Drive\nGPS");
MakeNameEx(0x0000F37E, "IAC_AIRFLOW_KV_ENG_SPD_OFFSET_AFLW_PN", nameFlags);
MakeRptCmt(0x0000F37E, "Amount of airflow required to compensate for a temporary engine speed offset while in P/N in an Automatic\nGPS");
MakeNameEx(0x0000F396, "IAC_AIRFLOW_KV_ENG_SPD_OFFSET_AFLW_MULT_DR", nameFlags);
MakeRptCmt(0x0000F396, "Multiplier that compensate Engine Speed Offset Airflowbased on coolant temperature, while in Drive\nScaler_2_Vs_Deg_C_Table");
MakeNameEx(0x0000F3B6, "IAC_AIRFLOW_KV_ENG_SPD_OFFSET_AFLW_MULT_PN", nameFlags);
MakeRptCmt(0x0000F3B6, "Multiplier that compensate Engine Speed Offset Airflowbased on coolant temperature, while in PN\nScaler_2_Vs_Deg_C_Table");
MakeNameEx(0x0000F3D6, "IAC_AIRFLOW_KV_PN_EXTENDED_THROT_CRACKER", nameFlags);
MakeRptCmt(0x0000F3D6, "This cal provides the extended throttle cracker airflow values while in neutral or when the clutch is depressed.\nGPS");
MakeNameEx(0x0000F3FA, "IAC_AIRFLOW_KV_VSDI_DESIRED_IDLE_SPEED", nameFlags);
MakeRptCmt(0x0000F3FA, "This cal provides desired idle speed for VSDI mode.\nRPM");
MakeNameEx(0x0000F410, "IAC_AIRFLOW_KV_CLO_SPARK_AIRFLOW_COOL_MULT", nameFlags);
MakeRptCmt(0x0000F410, "This cal provides value to adjust amount of airflow necessaryto compensate for catalyst spark retard as the enginewarms up.\nScaler_2_Vs_Deg_C_Table");
MakeNameEx(0x0000F430, "IAC_AIRFLOW_KV_VSDI_SPEED_LOW_IN_PN", nameFlags);
MakeRptCmt(0x0000F430, "VSDI integral correction when VSDI engine speed error is too low.\nGPS");
MakeNameEx(0x0000F448, "IAC_AIRFLOW_KV_VSDI_SPEED_HIGH_IN_PN", nameFlags);
MakeRptCmt(0x0000F448, "VSDI integral correction when VSDI engine speed error is too high.\nGPS");
MakeNameEx(0x0000F460, "IAC_AIRFLOW_KE_PRESSURE_RATIO_MAP_HYSTERESIS", nameFlags);
MakeRptCmt(0x0000F460, "Used to control change in manifold pressure, used to calculate the pressure ratio.\nkPa");
MakeNameEx(0x0000F462, "IAC_AIRFLOW_KE_TRANSITION_AIRFLOW_SPEED_CONS", nameFlags);
MakeRptCmt(0x0000F462, "\n");
MakeNameEx(0x0000F464, "IAC_AIRFLOW_KV_AIRFLOW_DELAY_DR_TO_PN", nameFlags);
MakeRptCmt(0x0000F464, "CIA uses PN tables after this time when thePRNDL is moved from any gear to PN.Must be <= KV_Drive_To_Park_Neutral_Delay.\nSeconds");
MakeNameEx(0x0000F486, "IAC_AIRFLOW_KV_AIRFLOW_DELAY_PN_TO_DR", nameFlags);
MakeRptCmt(0x0000F486, "CIA uses DR tables after this time, when the PRNDL is movedfrom PN to another gear.Must be <= KV_Park_Neutral_To_Drive_Delay.\nSeconds");
MakeNameEx(0x0000F4A8, "IAC_AIRFLOW_KV_VARIATION_CORRECTION_MAXIMUM", nameFlags);
MakeRptCmt(0x0000F4A8, "The maximum value that any one of the variation correction cells can achieve.\nIAC_GPS_W");
MakeNameEx(0x0000F4BC, "IAC_MOTOR_KE_DEFAULT_PARK_POSITION", nameFlags);
MakeRptCmt(0x0000F4BC, "At powerup, if nonvolatile memory is lost, Actual_IAC_ Position is set to this parameter.\nSteps");
MakeNameEx(0x0000F4BE, "IAC_MOTOR_KE_IACV_STEP_RANGE", nameFlags);
MakeRptCmt(0x0000F4BE, "Maximum stepping range of IACV motor.\nSteps");
MakeNameEx(0x0000F4C0, "IAC_MOTOR_KE_IACV_LOW_FREQUENCY_STEP", nameFlags);
MakeRptCmt(0x0000F4C0, "IACV motor step frequency when engine manifold vacuumis high.\nIACV_Hz_Type");
MakeNameEx(0x0000F4C2, "IAC_MOTOR_KE_IACV_HIGH_FREQUENCY_STEP", nameFlags);
MakeRptCmt(0x0000F4C2, "IACV motor step frequency when engine manifold vacuumis low.\nIACV_Hz_Type");
MakeNameEx(0x0000F4C4, "IAC_MOTOR_KE_MANIFOLD_VACUUM_FOR_LOW_FREQU", nameFlags);
MakeRptCmt(0x0000F4C4, "This calibration and the following are a hysteresis pairto provide a switch point for IACV motor step frequency.\nkPa");
MakeNameEx(0x0000F4C6, "IAC_MOTOR_KE_MANIFOLD_VACUUM_FOR_HIGH_FREQ", nameFlags);
MakeRptCmt(0x0000F4C6, "This calibration and the previous are a hysteresis pairto provide a switch point for IACV motor step frequency.\nkPa");
MakeNameEx(0x0000F4C8, "IAC_MOTOR_KE_MAXIMUM_COIL_VOLTAGE", nameFlags);
MakeRptCmt(0x0000F4C8, "Disabling threshold for the IACV coils if ignition voltage goes above this parameter.\nVolts");
MakeNameEx(0x0000F4CA, "IAC_MOTOR_KE_MINIMUM_STEP_VOLTAGE", nameFlags);
MakeRptCmt(0x0000F4CA, "Below this threshold the IACV is not allowed to step.\nVolts");
MakeNameEx(0x0000F4CC, "IAC_MOTOR_KV_AREA_TO_IACV_STEPS", nameFlags);
MakeRptCmt(0x0000F4CC, "Calibration used to translate effective area into equivalent IACV motor steps.\nSteps_vs_mm_squared_Table");
MakeNameEx(0x0000F546, "IAC_MOTOR_KE_IMLR_DEADBAND_SPEED_ERROR", nameFlags);
MakeRptCmt(0x0000F546, "Lost motor reset logic can only engage when the absolute engine speed error is greater than this calibration.\nRPM");
MakeNameEx(0x0000F548, "IAC_MOTOR_KE_IMLR_MOTOR_LOST_TIME", nameFlags);
MakeRptCmt(0x0000F548, "IAC motor must appear lost for at least this amount of time before allowing the lost motor logic to initiate.\nSeconds");
MakeNameEx(0x0000F54A, "IAC_MOTOR_KE_IMLR_MOTOR_WAIT_FOR_NEXT", nameFlags);
MakeRptCmt(0x0000F54A, "After the IAC motor is determined lost wait for at least this amount of time before allowing the next move to occur.\nSeconds");
MakeNameEx(0x0000F54C, "IAC_MOTOR_KE_IMRR_THROTTLE_POSITION", nameFlags);
MakeRptCmt(0x0000F54C, "Minimum throttle position to begin a running reset of the IAC motor position.\nPercent");
MakeNameEx(0x0000F54E, "IAC_MOTOR_KE_IMRR_VEHICLE_SPEED", nameFlags);
MakeRptCmt(0x0000F54E, "Minimum vehicle speed to begin a running reset of the IAC motor position.\nMiles/Hour");
MakeNameEx(0x0000F550, "IAC_MOTOR_KV_IMLR_STEP_INCREMENT", nameFlags);
MakeRptCmt(0x0000F550, "Number of steps required to move to attempt to open/closed if the engine speed low/high and current in the lost motor mode.\nSteps");
MakeNameEx(0x0000F566, "IAC_REGULATORS_KE_ADAPTIVE_TEMPERATURE_HIGH", nameFlags);
MakeRptCmt(0x0000F566, "Coolant temperature must be below this calibration to enable adaptive updates.\nDegrees_C");
MakeNameEx(0x0000F568, "IAC_REGULATORS_KE_ADAPTIVE_TEMPERATURE_LOW", nameFlags);
MakeRptCmt(0x0000F568, "Coolant temperature must be above this calibration to enable adaptive updates.\nDegrees_C");
MakeNameEx(0x0000F56A, "IAC_REGULATORS_KE_ENGINE_SPEED_LIGHTLY_FILTERED", nameFlags);
MakeNameEx(0x0000F56C, "IAC_REGULATORS_KE_ENGINE_SPEED_HEAVILY_FILTERED", nameFlags);
MakeNameEx(0x0000F56E, "IAC_REGULATORS_KE_INTEGRAL_DEAD_BAND_ENGINE_SPE", nameFlags);
MakeNameEx(0x0000F570, "IAC_REGULATORS_KE_MAXIMUM_IDLE_AIRFLOW", nameFlags);
MakeRptCmt(0x0000F570, "Calibration used to limit the idle airflow to a maximum.\nGPS");
MakeNameEx(0x0000F572, "IAC_REGULATORS_KE_SPEED_ERROR_LIMIT_ADAPTIVE", nameFlags);
MakeRptCmt(0x0000F572, "Absolute value of engine speed error must be less than whis calibration for adaptive updates to occur.\nRPM");
MakeNameEx(0x0000F574, "IAC_REGULATORS_KE_SPEED_ERROR_LIMIT_TIMER", nameFlags);
MakeRptCmt(0x0000F574, "Continuous time engine speed must be below limit before adaptive updates are allowed.\nSeconds");
MakeNameEx(0x0000F576, "IAC_REGULATORS_KV_STALL_SAVER_SPEED_DRIVE", nameFlags);
MakeNameEx(0x0000F58E, "IAC_REGULATORS_KV_STALL_SAVER_SPEED_NEUTRAL", nameFlags);
MakeNameEx(0x0000F5A6, "IAC_REGULATORS_KE_START_UP_ENGINE_UNDER_SPEED_T", nameFlags);
MakeNameEx(0x0000F5A8, "IAC_REGULATORS_KV_D_SPEED_DECREASING", nameFlags);
MakeRptCmt(0x0000F5A8, "Derivative airflow correction when engine speed is decreasing.\nGPS");
MakeNameEx(0x0000F5BC, "IAC_REGULATORS_KV_D_SPEED_INCREASING", nameFlags);
MakeRptCmt(0x0000F5BC, "Derivative airflow correction when engine speed is increasing.\nGPS");
MakeNameEx(0x0000F5D0, "IAC_REGULATORS_KV_I_SPEED_HIGH_IN_DRIVE", nameFlags);
MakeRptCmt(0x0000F5D0, "Integral correction when Engine_Speed_Error_Sum is too high and transmission is in drive.\nGPS");
MakeNameEx(0x0000F5E8, "IAC_REGULATORS_KV_I_SPEED_HIGH_IN_PARK_NEUTRAL", nameFlags);
MakeRptCmt(0x0000F5E8, "Integral correction when Engine_Speed_Error_Sum is too high and transmission is in park or neutral.\nGPS");
MakeNameEx(0x0000F600, "IAC_REGULATORS_KV_I_SPEED_LOW_IN_DRIVE", nameFlags);
MakeRptCmt(0x0000F600, "Integral correction when Engine_Speed_Error_Sum is too low and transmission is in drive.\nGPS");
MakeNameEx(0x0000F618, "IAC_REGULATORS_KV_I_SPEED_LOW_IN_PARK_NEUTRAL", nameFlags);
MakeRptCmt(0x0000F618, "Integral correction when Engine_Speed_Error_Sum is too low and transmission is in park or neutral.\nGPS");
MakeNameEx(0x0000F630, "IAC_REGULATORS_KV_P_SPEED_HIGH_IN_DRIVE", nameFlags);
MakeRptCmt(0x0000F630, "Proportional correction when Engine_Speed_Error is positive and transmission is in drive.\nGPS");
MakeNameEx(0x0000F648, "IAC_REGULATORS_KV_P_SPEED_HIGH_IN_DRIVE_AC", nameFlags);
MakeNameEx(0x0000F660, "IAC_REGULATORS_KV_P_SPEED_HIGH_IN_PARK_NEUTRAL", nameFlags);
MakeRptCmt(0x0000F660, "Proportional correction when Engine_Speed_Error is positive and transmission is in park or neutral.\nGPS");
MakeNameEx(0x0000F678, "IAC_REGULATORS_KV_P_SPEED_LOW_IN_DRIVE", nameFlags);
MakeRptCmt(0x0000F678, "Proportional correction when Engine_Speed_Error is negative and transmission is in drive.\nGPS");
MakeNameEx(0x0000F690, "IAC_REGULATORS_KV_P_SPEED_LOW_IN_DRIVE_AC", nameFlags);
MakeNameEx(0x0000F6A8, "IAC_REGULATORS_KV_P_SPEED_LOW_IN_PARK_NEUTRAL", nameFlags);
MakeRptCmt(0x0000F6A8, "Proportional correction when Engine_Speed_Error is negative and transmission is in park or neutral.\nGPS");
MakeNameEx(0x0000F6C0, "IAC_REGULATORS_KE_PROPORTIONAL_DEAD_BAND_ENGINE", nameFlags);
MakeNameEx(0x0000F6C2, "IAC_REGULATORS_KE_EARLY_PID_ENTRANCE_MAX_TPS", nameFlags);
MakeRptCmt(0x0000F6C2, "TPS must be less than this value to enter Early PID mode. A zero value will completely disable this function.\nPercent");
MakeNameEx(0x0000F6C4, "IAC_REGULATORS_KE_EARLY_PID_RPM_HYSTERESIS", nameFlags);
MakeRptCmt(0x0000F6C4, "Once in early PID mode, extend the minimum set point speed criteria by this much.\nRPM");
MakeNameEx(0x0000F6C6, "IAC_REGULATORS_KE_START_UP_PID_DELAY", nameFlags);
MakeRptCmt(0x0000F6C6, "Calibration to delay PID control until after engine isrunning.\nSeconds");
MakeNameEx(0x0000F6C8, "IAC_REGULATORS_KE_DELAY_P_CONTROL", nameFlags);
MakeRptCmt(0x0000F6C8, "Cal to transition into proportional speed control duringcoast down and when exiting a neutral throttle tip in\nSeconds");
MakeNameEx(0x0000F6CA, "IAC_REGULATORS_KE_DELAY_I_CONTROL", nameFlags);
MakeRptCmt(0x0000F6CA, "Cal to transition into integral speed control duringcoast down and when exiting a neutral throttle tip in\nSeconds");
MakeNameEx(0x0000F6CC, "IAC_REGULATORS_KE_DELAY_D_CONTROL", nameFlags);
MakeRptCmt(0x0000F6CC, "Cal to transition into derivative speed control duringcoast down and when exiting a neutral throttle tip in\nSeconds");
MakeNameEx(0x0000F6CE, "IAC_REGULATORS_KE_DELAY_IDLE_SPARK", nameFlags);
MakeRptCmt(0x0000F6CE, "Cal to transition into idle saprk control during coastdown and when exiting a neutral throttle tip in\nSeconds");
MakeNameEx(0x0000F6D0, "IAC_RPM_KE_IDLE_TO_OFFIDLE_THROTTLE_POSI", nameFlags);
MakeNameEx(0x0000F6D2, "IAC_RPM_KE_IDLE_TO_OFFIDLE_VEHICLE_SPEED", nameFlags);
MakeNameEx(0x0000F6D4, "IAC_RPM_KE_ALTERNATOR_FIELD_DC_FILTER", nameFlags);
MakeNameEx(0x0000F6D6, "IAC_RPM_KE_BATTERY_CHARGE_DUTY_CYCLE", nameFlags);
MakeRptCmt(0x0000F6D6, "An alternator field duty cycle below this calibration will decrease the idle speed to decrease the alternator power output.\nPercent");
MakeNameEx(0x0000F6D8, "IAC_RPM_KE_BATTERY_DISCHARGE_DUTY_CYCLE", nameFlags);
MakeRptCmt(0x0000F6D8, "An alternator field duty cycle above this calibration will increase the idle speed to increase the alternator power output.\nPercent");
MakeNameEx(0x0000F6DA, "IAC_RPM_KE_COOLANT_TEMPERATURE_LOW_LIMIT", nameFlags);
MakeRptCmt(0x0000F6DA, "Lower coolant temperature limit for enabling heater performance idle speed offset.\nDegrees Celsius");
MakeNameEx(0x0000F6DC, "IAC_RPM_KE_COOLANT_TEMPERATURE_HIGH_LIMI", nameFlags);
MakeRptCmt(0x0000F6DC, "Upper coolant temperature limit for enabling heater performance idle speed offset.\nDegrees Celsius");
MakeNameEx(0x0000F6DE, "IAC_RPM_KE_DECREASE_BATTERY_VOLTAGE_SPEE", nameFlags);
MakeRptCmt(0x0000F6DE, "Integral gain when alternator voltage is below control setpoint.  Activation rate: 100 ms.\nRPM");
MakeNameEx(0x0000F6E0, "IAC_RPM_KE_DRIVE_ENGINE_SPEED_LIMIT", nameFlags);
MakeRptCmt(0x0000F6E0, "Maximum allowable set point speed with transmission in drive.\nRPM");
MakeNameEx(0x0000F6E2, "IAC_RPM_KE_ENGINE_PROTECTION_SPEED", nameFlags);
MakeRptCmt(0x0000F6E2, "Minimum engine speed when engine over tempuratureprotection is enabled.\nRPM");
MakeNameEx(0x0000F6E4, "IAC_RPM_KE_INCREASE_BATTERY_VOLTAGE_SPEE", nameFlags);
MakeRptCmt(0x0000F6E4, "Integral gain when alternator voltage is below control setpoint.  Activation rate: 100 ms.\nRPM");
MakeNameEx(0x0000F6E6, "IAC_RPM_KE_INDUCTION_AIR_TEMPERATURE_THR", nameFlags);
MakeRptCmt(0x0000F6E6, "Induction air temperature limit for enabling heater performance idle speed offset.\nDegrees Celsius");
MakeNameEx(0x0000F6E8, "IAC_RPM_KE_MAXIMUM_BATTERY_SPEED_OFFSET", nameFlags);
MakeRptCmt(0x0000F6E8, "Maximum allowable engine speed offset due to battery voltage.\nRPM");
MakeNameEx(0x0000F6EA, "IAC_RPM_KE_MINIMUM_TIME_AC_SPEED", nameFlags);
MakeNameEx(0x0000F6EE, "IAC_RPM_KE_OFFIDLE_TO_IDLE_THROTTLE_POSI", nameFlags);
MakeNameEx(0x0000F6F0, "IAC_RPM_KE_OFFIDLE_TO_IDLE_VEHICLE_SPEED", nameFlags);
MakeNameEx(0x0000F6F2, "IAC_RPM_KE_RAMP_HEATER_PERFORMANCE_SPEED", nameFlags);
MakeRptCmt(0x0000F6F2, "Heater performance speed offset will be ramped to zero by this value per activation.\nRPM");
MakeNameEx(0x0000F6F4, "IAC_RPM_KE_SET_POINT_CHANGE_DELAY_TIME", nameFlags);
MakeRptCmt(0x0000F6F4, "The amount of time that must elapse before the set point speed can be lowered after having been raised.\nSeconds");
MakeNameEx(0x0000F6F6, "IAC_RPM_KE_SET_POINT_SPEED_RATE_DRIVE", nameFlags);
MakeRptCmt(0x0000F6F6, "RPM rate that the set point speed can be raised or lowered when not in park or neutral.\nRPM");
MakeNameEx(0x0000F6F8, "IAC_RPM_KE_SET_POINT_SPEED_RATE_NEUTRAL", nameFlags);
MakeRptCmt(0x0000F6F8, "RPM rate that the set point speed can be raised or lowered when in park or neutral.\nRPM");
MakeNameEx(0x0000F6FA, "IAC_RPM_KE_START_UP_DELAY_TIME_NO_GEAR", nameFlags);
MakeRptCmt(0x0000F6FA, "Period of time to delay after the wait time before the value of Start_Up_Speed_Offset_No_Gear starts to decay toward zero.\nSeconds");
MakeNameEx(0x0000F6FC, "IAC_RPM_KE_START_UP_DELAY_TIME_IN_GEAR", nameFlags);
MakeRptCmt(0x0000F6FC, "Period of time to delay after the wait time before the value of Start_Up_Speed_Offset_In_Gear starts to decay toward zero.\nSeconds");
MakeNameEx(0x0000F6FE, "IAC_RPM_KE_START_UP_SPEED_DELTA_IN_GEAR", nameFlags);
MakeRptCmt(0x0000F6FE, "Delta RPM used to decay Start_Up_Speed_Offset_In_Gear toward zero.\nRPM");
MakeNameEx(0x0000F700, "IAC_RPM_KE_START_UP_SPEED_DELTA_NO_GEAR", nameFlags);
MakeRptCmt(0x0000F700, "Delta RPM used to decay Start_Up_Speed_Offset_No_Gear toward zero.\nRPM");
MakeNameEx(0x0000F702, "IAC_RPM_KV_ENGINE_SPEED_DRIVE_AC_OFF", nameFlags);
MakeRptCmt(0x0000F702, "Desired engine speed with transmission in drive and the air conditioner off.\nRPM");
MakeNameEx(0x0000F722, "IAC_RPM_KV_ENGINE_SPEED_DRIVE_AC_ON", nameFlags);
MakeRptCmt(0x0000F722, "Desired engine speed with transmission in drive and the air conditioner on.\nRPM");
MakeNameEx(0x0000F742, "IAC_RPM_KV_ENGINE_SPEED_NEUTRAL_AC_OFF", nameFlags);
MakeRptCmt(0x0000F742, "Desired engine speed with transmission in park or neutral and the air conditioner off.\nRPM");
MakeNameEx(0x0000F762, "IAC_RPM_KV_ENGINE_SPEED_NEUTRAL_AC_ON", nameFlags);
MakeRptCmt(0x0000F762, "Desired engine speed with transmission in park or neutral and the air conditioner on.\nRPM");
MakeNameEx(0x0000F782, "IAC_RPM_KV_HEATER_PERF_SPEED_OFFSET_PARK", nameFlags);
MakeRptCmt(0x0000F782, "Desired engine speed offset when heater performance is active and transmission is in park or neutral.\nRPM");
MakeNameEx(0x0000F7A2, "IAC_RPM_KV_HEATER_PERF_SPEED_OFFSET_DRIV", nameFlags);
MakeRptCmt(0x0000F7A2, "Desired engine speed offset when heater performance is active and transmission is in drive.\nRPM");
MakeNameEx(0x0000F7C2, "IAC_RPM_KV_START_UP_SPEED_OFFSET_IN_GEAR", nameFlags);
MakeRptCmt(0x0000F7C2, "Start up engine speed offset value when the transmission is in gear.\nRPM");
MakeNameEx(0x0000F7D6, "IAC_RPM_KV_START_UP_SPEED_OFFSET_NO_GEAR", nameFlags);
MakeRptCmt(0x0000F7D6, "Start up engine speed offset value when the transmission is not in gear.\nRPM");
MakeNameEx(0x0000F7EA, "IAC_RPM_KE_PARK_NEUTRAL_ENGINE_SPEED_LIM", nameFlags);
MakeRptCmt(0x0000F7EA, "Maximum allowable set point speed with transmission in park or neutral.\nRPM");
MakeNameEx(0x0000F7EC, "IAC_RPM_KE_START_UP_WAIT_TIME", nameFlags);
MakeRptCmt(0x0000F7EC, "Period of time after engine starts before looking to see if throttle was opened or vehicle speed was non-zero.\nSeconds");
MakeNameEx(0x0000F7EE, "IGNITION_KE_IGNITION_VOLTAGE_SCALE_FAC", nameFlags);
MakeRptCmt(0x0000F7EE, "Ignition 1 sensor scaling factor.\n");
MakeNameEx(0x0000F7F0, "PROTECTED_KE_IGN_VOLT_TOO_HIGH", nameFlags);
MakeRptCmt(0x0000F7F0, "Ignition voltage is too high if it is greater than this.\nVolts");
MakeNameEx(0x0000F7F2, "PROTECTED_KE_IGN_VOLT_TOO_LOW", nameFlags);
MakeRptCmt(0x0000F7F2, "Ignition voltage is too Low if it is less than this.\nVolts");
MakeNameEx(0x0000F7F4, "INLET_TEMP_KV_CHARGE_TEMPERATURE_SQUARE_ROO", nameFlags);
MakeNameEx(0x0000F81A, "INLET_TEMP_KV_CHARGE_TEMPERATURE_BIAS", nameFlags);
MakeNameEx(0x0000F83A, "INLET_TEMP_KV_CHARGE_TEMPERATURE_FILTER", nameFlags);
MakeNameEx(0x0000F85A, "MASS_AIR_FLOW_SENSOR_KV_MASS_AIRFLOW", nameFlags);
MakeRptCmt(0x0000F85A, "Mass Air Flow rate from sensor\nGram/Sec");
MakeNameEx(0x0000F904, "MEM_MANAGER_KE_MAX_RAM_FAIL_CTR_THRESHOLD", nameFlags);
MakeRptCmt(0x0000F904, "Threshold for maximum number of RAM test failures that canoccur before latching a permanent fault.\nCounts");
MakeNameEx(0x0000F905, "MEM_MANAGER_KE_IGNORE_RAM_TEST", nameFlags);
MakeRptCmt(0x0000F905, "When TRUE the ram test results are ignored.\nBoolean");
MakeNameEx(0x0000F906, "MEM_MANAGER_KE_MAX_ROM_FAIL_CTR_THRESHOLD", nameFlags);
MakeRptCmt(0x0000F906, "Threshold for maximum number of ROM test failures that canoccur before latching a permanent fault.\nCounts");
MakeNameEx(0x0000F907, "MEM_MANAGER_KE_IGNORE_FLASH_CHECKSUM", nameFlags);
MakeRptCmt(0x0000F907, "When TRUE the rom test results are ignored.\nBoolean");
MakeNameEx(0x0000F908, "INDUCTION_AIR_KE_INDUCTION_AIR_TEMPERATURE_DEF", nameFlags);
MakeRptCmt(0x0000F908, "Default induction air temperature used when IAT sensor is failed.\n");
MakeNameEx(0x0000F90A, "INDUCTION_AIR_KV_AIR_TEMP", nameFlags);
MakeRptCmt(0x0000F90A, "Converts induction air temperature A/D counts to Degrees C.\n");
MakeNameEx(0x0000F92C, "OISTER_KE_OIL_STARVE_ENABLE", nameFlags);
MakeRptCmt(0x0000F92C, "Bit selectable to allow oil starvation algorithm to run.\nBOOLEAN");
MakeNameEx(0x0000F92E, "OISTER_KE_DRIVER_WARNING_DELAY_TIME", nameFlags);
MakeRptCmt(0x0000F92E, "Driver notification to powertrain action delay time.\nSeconds");
MakeNameEx(0x0000F930, "OISTER_KE_HIGH_G_MINIMUM_TIME", nameFlags);
MakeRptCmt(0x0000F930, "Minimum amount of time  a high lateral acceleration manuever must be sustained before any powertrain action will take place.\nSeconds");
MakeNameEx(0x0000F932, "OISTER_KE_INTEGRAL_RESET_DELAY", nameFlags);
MakeRptCmt(0x0000F932, "This time will prevent lateral acceleration spikes from resetting the lateral G integrator.\nDelay_Seconds_W");
MakeNameEx(0x0000F934, "OISTER_KE_LAT_G_SPIKE_REJECTION_TIME", nameFlags);
MakeRptCmt(0x0000F934, "This time will allow lat G spikes to be ignored. After this time, the lat G will be acknowledged.\nSeconds");
MakeNameEx(0x0000F936, "OISTER_KE_LOWEST_GEAR_ALLOWED_LIMIT", nameFlags);
MakeRptCmt(0x0000F936, "Allows the limiting of oil starvation protection transmission upshifts.\nGear");
MakeNameEx(0x0000F938, "OISTER_KE_MINIMUM_VEHICLE_SPEED_FOR_OIS", nameFlags);
MakeRptCmt(0x0000F938, "Minimum vehicle speed to allow the conditions to exist for oil starvation protection.\nMPH");
MakeNameEx(0x0000F93A, "OISTER_KE_MAXIMUM_VEHICLE_SPEED_FOR_OIS", nameFlags);
MakeRptCmt(0x0000F93A, "Maximum vehicle speed to allow the conditions to exist for oil starvation protection.\nMPH");
MakeNameEx(0x0000F93C, "OISTER_KE_OIL_PRESSURE_G_ENABLE", nameFlags);
MakeRptCmt(0x0000F93C, "Lateral acceleration threshold to enable protection mode based on low oil pressure detection.\nGs_B_U");
MakeNameEx(0x0000F93E, "OISTER_KE_OIL_PRESSURE_NOISE_REJECTION", nameFlags);
MakeRptCmt(0x0000F93E, "Time delay to ensure the oil pressure level has truly exceeded the enable or disable thresholds.\nSeconds");
MakeNameEx(0x0000F940, "OISTER_KV_OIL_LEVEL_FILTER_COEFFICIENT", nameFlags);
MakeRptCmt(0x0000F940, "Filters the Lat G Seconds threshold transients based on the current threshold.\nUnitless");
MakeNameEx(0x0000F96A, "OISTER_KE_OIL_LEVEL_FILTER_COEFFICIENT", nameFlags);
MakeRptCmt(0x0000F96A, "Filters the maximum Lat G Seconds threshold transients based on the current threshold.\nUnitless");
MakeNameEx(0x0000F96C, "OISTER_KE_OIL_LOWEST_GEAR_RESET_SPEED", nameFlags);
MakeRptCmt(0x0000F96C, "Allows for the lowest gear possible to be reset to FIRST if the vehicle speed is below the cal.\nMPH");
MakeNameEx(0x0000F96E, "OISTER_KE_OIL_MINIMUM_VEHICLE_SPEED", nameFlags);
MakeRptCmt(0x0000F96E, "Minimum ETC  vehicle speed governor when the engine oil starvation protection  mode is enabled.\nMPH");
MakeNameEx(0x0000F970, "OISTER_KE_OIL_SPEED_LIMIT_DECREASE", nameFlags);
MakeRptCmt(0x0000F970, "Delta MPH  decrease of ETC vehicle speed governor when engine oil starvation protection mode is enabled.\nMPH");
MakeNameEx(0x0000F972, "OISTER_KE_OIL_SPEED_LIMIT_INCREASE", nameFlags);
MakeRptCmt(0x0000F972, "Delta MPH  increase of ETC vehicle speed governor when engine oil starvation protection mode is NOT enabled.\nMPH");
MakeNameEx(0x0000F974, "OISTER_KE_POWERTRAIN_ACTION_TIME", nameFlags);
MakeRptCmt(0x0000F974, "Minimum amount of time the powertrain action will remain active once it has been initiated.\nSeconds");
MakeNameEx(0x0000F976, "OISTER_KE_PROTECTION_G_HIGH_HYSTERESIS", nameFlags);
MakeRptCmt(0x0000F976, "Above this value will enable the High G Timer FOR skid pad testing detection.\nGs_B_U");
MakeNameEx(0x0000F977, "OISTER_KE_PROTECTION_G_LOW_HYSTERESIS", nameFlags);
MakeRptCmt(0x0000F977, "Below thisvalue will be considered not high G conditions\nGs_B_U");
MakeNameEx(0x0000F978, "OISTER_KE_THROTTLE_MAX_TO_RESUME_DRIVER", nameFlags);
MakeRptCmt(0x0000F978, "Once oil starvation is activated, throttle must close to this value before maximum speed is incremented.\nPercent");
MakeNameEx(0x0000F97A, "OISTER_KE_OIL_FILTER_COEFFICIENT", nameFlags);
MakeRptCmt(0x0000F97A, "Coefficient to filter the lateral acceleration variable using a first order lag filter.\nUnitless");
MakeNameEx(0x0000F97C, "OISTER_KV_OIL_MIN_ENGINE_RUN_TIME", nameFlags);
MakeRptCmt(0x0000F97C, "Minimum amount of time engine must be running before the Oil Starvation criteria will be considered.\nSeconds");
MakeNameEx(0x0000F9A2, "OISTER_KV_OIL_PRESSURE_DISABLE_LEVEL", nameFlags);
MakeRptCmt(0x0000F9A2, "Engine oil pressure necessary to disable the oil starvation mode.\nkPa");
MakeNameEx(0x0000F9C0, "OISTER_KV_OIL_PRESSURE_ENABLE_LEVEL", nameFlags);
MakeRptCmt(0x0000F9C0, "Abnormally low oil presure level which will cause engine damage if sustained.\nkPa");
MakeNameEx(0x0000F9DE, "OISTER_KV_OIL_TEMPERATURE_OFFSET", nameFlags);
MakeRptCmt(0x0000F9DE, "Compensates the Maximum Lat G Seconds threshold for oil temperature.\nG_Seconds");
MakeNameEx(0x0000F9FE, "OISTER_KV_RESET_INTEGRAL_LATERAL_GS", nameFlags);
MakeRptCmt(0x0000F9FE, "Threshold below which, the lateral_G integral gets reset to zero to avoid integral windup\nRPM");
MakeNameEx(0x0000FA30, "OISTER_KA_OIL_BASE_LEVEL_LH", nameFlags);
MakeRptCmt(0x0000FA30, "Left hand turn, threshold of Lateral G seconds, or an indication of amount of time spent as a function of G-forces\nG_Seconds");
MakeNameEx(0x0000FB5C, "OISTER_KA_OIL_BASE_LEVEL_RH", nameFlags);
MakeRptCmt(0x0000FB5C, "Right hand turn, threshold of Lateral G Seconds, or an indication of amount of time spent as  function of G-forces\nG_Seconds");
MakeNameEx(0x0000FC88, "OXYGEN_SENSOR_KE_DEV_CNTL_O2_HTR_AIRFLOW_LIMIT", nameFlags);
MakeRptCmt(0x0000FC88, "The maximum airflow for O2 heater device control to be allowed.\nGrams_Per_Second");
MakeNameEx(0x0000FC8A, "OXYGEN_SENSOR_KE_O2_HEATER_OVERVOLTAGE_LIMIT", nameFlags);
MakeRptCmt(0x0000FC8A, "Ignition voltage greater than or equal to this value will shut the heaters off to protect against overvoltage.\nVolts");
MakeNameEx(0x0000FC8C, "OXYGEN_SENSOR_KE_OXYGEN_SENSOR_SCALE_FACTOR", nameFlags);
MakeRptCmt(0x0000FC8C, "Used to scale oxygen sensor analog input.\nmV_per_AD_Count");
MakeNameEx(0x0000FC8E, "OXYGEN_SENSOR_KE_INRUSH_CURRENT_STABILIZE_TIME", nameFlags);
MakeNameEx(0x0000FC90, "OXYGEN_SENSOR_KE_HEATER_INRUSH_OHMS_FILT_COEF", nameFlags);
MakeRptCmt(0x0000FC90, "The coefficient to filter the heater inrush resistance.\nFilt Coef");
MakeNameEx(0x0000FC92, "OXYGEN_SENSOR_KE_HEATER_OHMS_FILTER_COEF", nameFlags);
MakeRptCmt(0x0000FC92, "The coefficient to filter the heater Resistance.\nFilter Coef");
MakeNameEx(0x0000FC94, "OXYGEN_SENSOR_KE_HEATER_ON_SAMPLE_DELAY", nameFlags);
MakeRptCmt(0x0000FC94, "The delay after the heaters are turned on during which part learning samples are being taken.\nSeconds");
MakeNameEx(0x0000FC96, "OXYGEN_SENSOR_KE_LPL_ABS_TEMP_DIFF", nameFlags);
MakeNameEx(0x0000FC98, "OXYGEN_SENSOR_KE_LIMIT_LEARN_RUN_TIME_ABORT", nameFlags);
MakeRptCmt(0x0000FC98, "The amount of time allowed for a limit part learn since engine run.\nSeconds");
MakeNameEx(0x0000FC9A, "OXYGEN_SENSOR_KE_MEASURED_HEATER_CURRENT_MIN", nameFlags);
MakeRptCmt(0x0000FC9A, "The current below which values are considered to be invalid.\nHeater_Amps");
MakeNameEx(0x0000FC9C, "OXYGEN_SENSOR_KE_O2_HEATER_REZERO_OFF_TIME", nameFlags);
MakeRptCmt(0x0000FC9C, "The minimum amount of time that the engine has been off to allow a O2 sensor limit part error learn.\nSeconds");
MakeNameEx(0x0000FCA0, "OXYGEN_SENSOR_KE_O2_HEATER_REZERO_TEMP_DIFF", nameFlags);
MakeRptCmt(0x0000FCA0, "The maximum temperature difference between ambient and coolant to allow a O2 sensor limit part error learn.\nDegrees_C");
MakeNameEx(0x0000FCA2, "OXYGEN_SENSOR_KE_O2_HEATER_ROOM_TEMP", nameFlags);
MakeRptCmt(0x0000FCA2, "The temperature offset used in the linear resistance temperature equation.\nDegrees_C");
MakeNameEx(0x0000FCA4, "OXYGEN_SENSOR_KE_POST_O2_HTR_STARTUP_COOL_MIN", nameFlags);
MakeNameEx(0x0000FCA6, "OXYGEN_SENSOR_KE_PRE_O2_SENSORS", nameFlags);
MakeRptCmt(0x0000FCA6, "Determines the number of pre O2 sensors used in the system.\n1-2");
MakeNameEx(0x0000FCA8, "OXYGEN_SENSOR_KE_RCOHT_LEARN_COOLANT_TEMP_MAX", nameFlags);
MakeRptCmt(0x0000FCA8, "The maximum coolant temperature to allow a O2 sensor limit part error learn.\nDegrees_C");
MakeNameEx(0x0000FCAA, "OXYGEN_SENSOR_KE_RCOHT_LEARN_COOLANT_TEMP_MIN", nameFlags);
MakeRptCmt(0x0000FCAA, "The minimum coolant temperature to allow O2 sensor limit part error learn.\nDegrees_C");
MakeNameEx(0x0000FCAC, "OXYGEN_SENSOR_KV_COLD_O2_HEATER_DELAY", nameFlags);
MakeRptCmt(0x0000FCAC, "The amount of delay for each O2 heater to allow evaporation of any condensation in the exhaust system.\nSeconds");
MakeNameEx(0x0000FCBC, "OXYGEN_SENSOR_KV_HEATER_INRUSH_RESIST_MAX", nameFlags);
MakeRptCmt(0x0000FCBC, "The maximum inrush resistance that can be added to the inrush resistancefilter.\nOhms");
MakeNameEx(0x0000FCC4, "OXYGEN_SENSOR_KV_LIMIT_PART_ERROR_MAX", nameFlags);
MakeNameEx(0x0000FCCC, "OXYGEN_SENSOR_KV_LIMIT_PART_ERROR_MIN", nameFlags);
MakeNameEx(0x0000FCD4, "OXYGEN_SENSOR_KV_O2_HEATER_CKT_VOLTAGE_ADJ", nameFlags);
MakeRptCmt(0x0000FCD4, "Used to adjust from the ignition voltage reading to get to the heater voltage drop.\nVolts");
MakeNameEx(0x0000FCDC, "OXYGEN_SENSOR_KV_O2_HEATER_PRESENT", nameFlags);
MakeRptCmt(0x0000FCDC, "Indicates whether the O2 sensor is installed. 0 = NOT installed. 1 = installed.\nO2_Heater_Present_Type");
MakeNameEx(0x0000FCE0, "OXYGEN_SENSOR_KV_O2_HEATER_ROOM_TEMP_RESIST", nameFlags);
MakeRptCmt(0x0000FCE0, "The heater resistance at KE_O2_Heater_Room_Temp degrees C.\nOhms");
MakeNameEx(0x0000FCE8, "OXYGEN_SENSOR_KV_O2_HEATER_TURN_OFF_TEMP", nameFlags);
MakeRptCmt(0x0000FCE8, "Temperature above which the O2 Sensor Heaters have reached that the Heaters need to be turned OFF.\nDegrees_C_S");
MakeNameEx(0x0000FCF0, "OXYGEN_SENSOR_KV_O2_HEATER_TURN_ON_TEMP", nameFlags);
MakeRptCmt(0x0000FCF0, "Temperature below which the O2 Sensor Heaters have cooled down sufficiently and should be turned ON.\nDegrees_C_S");
MakeNameEx(0x0000FCF8, "OXYGEN_SENSOR_KA_O2_HEATER_DEGREES_PER_OHM", nameFlags);
MakeRptCmt(0x0000FCF8, "The change in degrees C per 1 ohm resistance change in the oxygen sensor heater for each sensor.\nDegrees C");
MakeNameEx(0x0000FD88, "PTO_KE_LOW_SPEED_INHIBIT", nameFlags);
MakeRptCmt(0x0000FD88, "Filtered engine speed below which PTO modes can not be established.  Also clamps PTO_Maximum_Engine_Speed.\nRPM");
MakeNameEx(0x0000FD8A, "PTO_KE_HIGH_SPEED_INHIBIT", nameFlags);
MakeRptCmt(0x0000FD8A, "Filtered engine speed above which PTO modes can not be established.  Also clamps PTO_Maximum_Engine_Speed.\nRPM");
MakeNameEx(0x0000FD8C, "PTO_KE_LOW_VEH_SPEED_DISENGAGE", nameFlags);
MakeRptCmt(0x0000FD8C, "Minimum allowed vehicle speed before Mobile PTO disengages. Also differentiates between Stationary and Mobile Variable PTO.\nMPH");
MakeNameEx(0x0000FD8E, "PTO_KE_HIGH_VEH_SPEED_DISENGAGE", nameFlags);
MakeRptCmt(0x0000FD8E, "Maximum allowed HARDCODED vehicle speed for Mobile PTO.\nMPH");
MakeNameEx(0x0000FD90, "PTO_KE_PTO_HIGH_IDLE_ENABLED", nameFlags);
MakeRptCmt(0x0000FD90, "Determines whether PTO High Idle mode will be allowed basedon the high idle switch input.\nBOOLEAN");
MakeNameEx(0x0000FD92, "PTO_KE_HIGH_IDLE_BULB_CHECK_TIME", nameFlags);
MakeRptCmt(0x0000FD92, "Time for illuminating the High Idle Lamp for a bulb check.\nSeconds");
MakeNameEx(0x0000FD94, "PTO_KE_PTO_IDLE_ENGINE_SPEED_EEPROM", nameFlags);
MakeRptCmt(0x0000FD94, "PTO idle engine speed when PTO control is entered.  ALSO the High Idle engine speed.\nRPM");
MakeNameEx(0x0000FD95, "PTO_KE_PTO_MAX_ENGINE_SPEED_EEPROM", nameFlags);
MakeRptCmt(0x0000FD95, "Maximum allowed Engine Speed for PTO control.\nRPM");
MakeNameEx(0x0000FD96, "PTO_KE_SET_ENGINE_SPEED_EEPROM", nameFlags);
MakeRptCmt(0x0000FD96, "Preset PTO engine speed when SET is pressed.\nRPM");
MakeNameEx(0x0000FD97, "PTO_KE_RESUME_ENGINE_SPEED_EEPROM", nameFlags);
MakeRptCmt(0x0000FD97, "Preset PTO engine speed when RESUME is pressed.\nRPM");
MakeNameEx(0x0000FD98, "PTO_KE_PTO_MAX_VEHICLE_SPEED_EEPROM", nameFlags);
MakeRptCmt(0x0000FD98, "Maximum allowed vehicle speed for Mobile Variable PTO control.\nMPH");
MakeNameEx(0x0000FD9A, "PTO_KE_PTO_RAISE_ENGINE_SPD_DLY_TIME", nameFlags);
MakeRptCmt(0x0000FD9A, "Time after engaging PTO Relay before raising the engine speed.\nSeconds");
MakeNameEx(0x0000FD9C, "PTO_KE_PTO_RLY_ENGAGE_MAX_SPEED_EEPR", nameFlags);
MakeRptCmt(0x0000FD9C, "Max allowed engine speed for engaging PTO relay.\nRPM");
MakeNameEx(0x0000FD9D, "PTO_KV_DESIRED_OPTION_EEPROM_DEFAULT", nameFlags);
MakeRptCmt(0x0000FD9D, "Default PTO & Engine Shutdown option modes to be used before EEPROM is dealer programmed.\nBOOLEAN");
MakeNameEx(0x0000FD9E, "PTO_CONTROL_KE_PTO_INTEGRATOR_HIGH", nameFlags);
MakeRptCmt(0x0000FD9E, "Integrator maximum value while PTO is engaged.\nRPM");
MakeNameEx(0x0000FDA0, "PTO_CONTROL_KE_PTO_INTEGRATOR_LOW", nameFlags);
MakeRptCmt(0x0000FDA0, "Integrator minimum value while PTO is engaged.\nRPM");
MakeNameEx(0x0000FDA2, "PTO_CONTROL_KE_PTO_THROTTLE_AREA_LIMIT", nameFlags);
MakeRptCmt(0x0000FDA2, "Maximum desired throttle area that PTO can request.\nPercent");
MakeNameEx(0x0000FDA4, "PTO_CONTROL_KE_HYSTERESIS", nameFlags);
MakeRptCmt(0x0000FDA4, "Hysteresis constant.\nRPM");
MakeNameEx(0x0000FDA6, "PTO_CONTROL_KE_SCHEDULED_ACCEL_GAIN_OVER", nameFlags);
MakeRptCmt(0x0000FDA6, "Overspeed scheduled acceleration rate gain.\nRPM_Per_Second");
MakeNameEx(0x0000FDA8, "PTO_CONTROL_KE_SCHEDULED_ACCEL_GAIN_UNDER", nameFlags);
MakeRptCmt(0x0000FDA8, "Underspeed scheduled acceleration rate gain.\nRPM_Per_Second");
MakeNameEx(0x0000FDAA, "PTO_CONTROL_KE_PTO_ENG_SPEED_DELTA_HIGH", nameFlags);
MakeRptCmt(0x0000FDAA, "Acceleration error maximum value and maximum integrator increment per 100ms.\nRPM per 100ms");
MakeNameEx(0x0000FDAC, "PTO_CONTROL_KE_PTO_ENG_SPEED_DELTA_LOW", nameFlags);
MakeRptCmt(0x0000FDAC, "Acceleration error minimum value and maximum integrator decrement per 100ms.\nRPM per 100ms");
MakeNameEx(0x0000FDAE, "PTO_CONTROL_KV_PTO_BARO_COMPENSATION", nameFlags);
MakeRptCmt(0x0000FDAE, "Adjusts the PTO desired throttle area to compensate for ambient pressure.\nScaler");
MakeNameEx(0x0000FDB8, "PTO_CONTROL_KV_GAIN_TABLE", nameFlags);
MakeRptCmt(0x0000FDB8, "Effective Speed Error vs PTO Desired Throttle Area, Gain Table 0.\nPercent");
MakeNameEx(0x0000FDD6, "PTO_CONTROL_KA_VARIABLE_GAIN_WITH_SPEED", nameFlags);
MakeNameEx(0x0000FEF6, "PTO_CONTROL_KA_VELOCITY_COMPENSATION", nameFlags);
MakeNameEx(0x00010016, "PTO_CONTROL_KE_PTO_ENG_SPEED_FILTER", nameFlags);
MakeRptCmt(0x00010016, "Filter coefficient for engine speed for the PTO control algorithm.\nFilter_Coefficient");
MakeNameEx(0x00010018, "PTO_CONTROL_KE_OVERSPEED_DISENGAGE", nameFlags);
MakeRptCmt(0x00010018, "Maximum overspeed value (PTO_Eng_Speed_Error - Demand_Register) allowed without a PTO disengage.\nRPM");
MakeNameEx(0x0001001A, "PTO_CONTROL_KE_PERFORM_BRK_OR_CLUTCH_TEST", nameFlags);
MakeRptCmt(0x0001001A, "Brake before PTO security option. If TRUE, the brake or clutch input must be asserted before PTO can be enabled.\nBOOLEAN");
MakeNameEx(0x0001001C, "PTO_CONTROL_KE_PTO_EFF_SPD_ERROR_MAX", nameFlags);
MakeRptCmt(0x0001001C, "Maximum value effective speed error can be.\nRPM");
MakeNameEx(0x0001001E, "PTO_CONTROL_KE_PTO_INTEGRATOR_GAIN", nameFlags);
MakeRptCmt(0x0001001E, "Integrator gain when not in Resume or Accel modes.\nMultiplier_0_to_1");
MakeNameEx(0x00010020, "PTO_MANAGE_KE_ACCEL_TERMINATION_OVERSHOOT", nameFlags);
MakeNameEx(0x00010022, "PTO_MANAGE_KE_RESUME_VS_ACCEL_TIME", nameFlags);
MakeNameEx(0x00010024, "PTO_MANAGE_KE_PTO_SET_TIME", nameFlags);
MakeRptCmt(0x00010024, "The minimum amount of time the S/C switch must be depressed in order to move to engaged upon the release of the switch.\nSeconds");
MakeNameEx(0x00010026, "PTO_MANAGE_KE_TAP_DOWN_TIMEOUT", nameFlags);
MakeNameEx(0x00010028, "PTO_MANAGE_KE_TAP_DOWN_SPEED_HIGH", nameFlags);
MakeNameEx(0x0001002A, "PTO_MANAGE_KE_TAP_DOWN_VS_COAST_TIME", nameFlags);
MakeNameEx(0x0001002C, "PTO_MANAGE_KE_TAP_INCREMENT", nameFlags);
MakeRptCmt(0x0001002C, "The tap up/down increment to memory speed and demand register.\nRPM");
MakeNameEx(0x0001002E, "PTO_MANAGE_KE_TAP_UP_SPEED_HIGH", nameFlags);
MakeNameEx(0x00010030, "PTO_MANAGE_KE_TAP_UP_SPEED_LOW", nameFlags);
MakeNameEx(0x00010032, "PTO_MANAGE_KE_TAP_UP_VS_ACCEL_TIME", nameFlags);
MakeNameEx(0x00010034, "PTO_MANAGE_KV_ACCEL_STEP_FROM_SBE", nameFlags);
MakeRptCmt(0x00010034, "An additional term added to the Demand Register at the initiation of an Accel in order to obtain more Desired Throttle Area.\nRPM");
MakeNameEx(0x00010054, "PTO_MANAGE_KV_ACCEL_STEP_FROM_ENG", nameFlags);
MakeRptCmt(0x00010054, "An additional term added to the Demand Register at the initiation of an Accel in order to obtain more Desired Throttle Area.\nRPM");
MakeNameEx(0x00010074, "PTO_MANAGE_KV_RESUME_RATE", nameFlags);
MakeRptCmt(0x00010074, "The resume rate increment per 100 ms.\nRPM");
MakeNameEx(0x0001009E, "PTO_MANAGE_KV_ACCEL_RATE", nameFlags);
MakeRptCmt(0x0001009E, "The accel rate increment per 100 ms.\nRPM");
MakeNameEx(0x000100BE, "PTO_MANAGE_KE_COAST_RATE", nameFlags);
MakeRptCmt(0x000100BE, "The coast rate increment per 100 ms.\nRPM");
MakeNameEx(0x000100C0, "PTO_MANAGE_KE_TAP_RATE", nameFlags);
MakeRptCmt(0x000100C0, "The tap up/down rate increment per 100 ms.\nRPM");
MakeNameEx(0x000100C2, "SHIFT_LIGHT_KE_REASONABLE_ENGINE_SPEED", nameFlags);
MakeNameEx(0x000100C4, "SHIFT_LIGHT_KV_SHIFT_MAP_THRESHOLD", nameFlags);
MakeRptCmt(0x000100C4, "Turn off shift light when MAP is below this threshold.\nkPa");
MakeNameEx(0x000100CC, "SHIFT_LIGHT_KE_TEMPERATURE_LO", nameFlags);
MakeRptCmt(0x000100CC, "KSLTMPA -  The lowest coolant temperature at which to indicate a good shift point.\nDegrees_C");
MakeNameEx(0x000100CE, "SHIFT_LIGHT_KV_ENGINE_SPEED_LO", nameFlags);
MakeNameEx(0x000100D6, "SHIFT_LIGHT_KV_THROTTLE_LO", nameFlags);
MakeRptCmt(0x000100D6, "KTPSNLTA, KTPSNLTC -  The lowest throttle at which to indicate a good shift point from each upshiftable gear.\nPercent");
MakeNameEx(0x000100DE, "SHIFT_LIGHT_KA_THROTTLE_HI_BASIC", nameFlags);
MakeRptCmt(0x000100DE, "Throttle must be less than or equal to this value to permit a good shift point.\nPercent");
MakeNameEx(0x00010136, "SHIFT_LIGHT_KV_THROTTLE_HI_HYST", nameFlags);
MakeRptCmt(0x00010136, "Hysteresis value subtracted from KE_Throttle_Hi when the shift light is off.\nPercent");
MakeNameEx(0x0001013E, "SHIFT_LIGHT_KV_THROTTLE_HI_BARO_CORRECTION", nameFlags);
MakeRptCmt(0x0001013E, "Barometric correction used in determining the highest throttle allowed that indicates a good shift point.\nGain 0-16");
MakeNameEx(0x00010148, "SHIFT_LIGHT_KE_SHIFT_DURATION", nameFlags);
MakeRptCmt(0x00010148, "Max on time for the shift light.\nSeconds");
MakeNameEx(0x0001014A, "SHIFT_LIGHT_KV_GEAR_RATIO_LO", nameFlags);
MakeRptCmt(0x0001014A, "KTRNGR12, KTRNGR23, KTRNGR34, KTRNGR45 -  The lowest gear ratio (input/output) recognized as each upshiftable gear.\nInput/Out");
MakeNameEx(0x00010152, "SHIFT_LIGHT_KV_COLD_ENGINE_SPEED_LO", nameFlags);
MakeRptCmt(0x00010152, "Minimum engine speed allowed before indicating a good shift point when the engine is cold.\nRPM");
MakeNameEx(0x0001015A, "SHIFT_LIGHT_KE_COLD_TEMP_LO", nameFlags);
MakeRptCmt(0x0001015A, "Below this temperature, use the cold engine speed table to determine minimum engine speed for a good shift point.\nDegrees_C");
MakeNameEx(0x0001015C, "SHIFT_LIGHT_KV_DELAY_TIME", nameFlags);
MakeRptCmt(0x0001015C, "Delay time from a good shift point to when the light will be turned on.\nSeconds");
MakeNameEx(0x00010172, "SHIFT_LIGHT_KE_CLUTCH_TRANS_INHIBIT_TIME", nameFlags);
MakeRptCmt(0x00010172, "Number of shift light loops to prevent a good shift point condition following the release of the clutch pedal.\nSeconds");
MakeNameEx(0x00010174, "SHIFT_LIGHT_KE_EXECUTE_UPSHIFT_LIGHT_ALGORIT", nameFlags);
MakeRptCmt(0x00010174, "Set to TRUE if the upshift light logic should be executed.\nBoolean");
MakeNameEx(0x00010175, "SHIFT_LIGHT_KE_CONTROL_UPSHIFT_LIGHT", nameFlags);
MakeRptCmt(0x00010175, "Set to TRUE if the upshift light logic should directly controlthe upshift light PCM output. (Class2 message not used).\nBoolean");
MakeNameEx(0x00010176, "SPARK_ADVANCE_KA_CAT_LIGHTOFF_SPARK_RETARD", nameFlags);
MakeRptCmt(0x00010176, "The amount of spark retard to apply to lightoff the catalytic converter.\nDegrees_POSITIVE");
MakeNameEx(0x00010638, "SPARK_ADVANCE_KA_MBT_SPARK", nameFlags);
MakeRptCmt(0x00010638, "Spark Advance for mean best timing.\nDegrees");
MakeNameEx(0x00010890, "SPARK_ADVANCE_KA_MAIN_OT_HIGH_OCTANE", nameFlags);
MakeRptCmt(0x00010890, "This calibration determines base spark 'good fuel' contribution to spark advance.\nDegrees");
MakeNameEx(0x00010E3A, "SPARK_ADVANCE_KA_MAIN_OT_LOW_OCTANE", nameFlags);
MakeRptCmt(0x00010E3A, "This calibration determines base spark 'bad fuel' contribution to spark advance.\nDegrees");
MakeNameEx(0x000113E4, "SPARK_ADVANCE_KV_FFS_SPARK_BLEND_FACTOR", nameFlags);
MakeRptCmt(0x000113E4, "Interpolation fraction used to determine the portion of the FFS_Spark to use.\nMult_0_to_1");
MakeNameEx(0x000113EE, "SPARK_ADVANCE_KV_LAUNCH_SPARK_RAMP_OUT_MULT", nameFlags);
MakeRptCmt(0x000113EE, "Multiplier applied to the Launch Spark value every ref pulse ince the hold duration has expired.\n0 to 1");
MakeNameEx(0x00011414, "SPARK_ADVANCE_KV_LIMIT_MAX_RETARD", nameFlags);
MakeRptCmt(0x00011414, "Maximum spark retard limit allowed.\nDegrees");
MakeNameEx(0x0001143E, "SPARK_ADVANCE_KE_AIR_PER_CYLINDER_BLEND_RATIO", nameFlags);
MakeRptCmt(0x0001143E, "Describes the index and ratio for interpolation between two adjacent air per cylinder values.\nScaler_2_S");
MakeNameEx(0x00011440, "SPARK_ADVANCE_KE_HVS_RUN_MODE_ENABLE_RPM", nameFlags);
MakeRptCmt(0x00011440, "Engine speed threshold above which the EST will switch to low resnormal mode for non 24X applications.\nRPM");
MakeNameEx(0x00011442, "SPARK_ADVANCE_KE_HVS_RUN_MODE_DISABLE_RPM", nameFlags);
MakeRptCmt(0x00011442, "Engine speed threshold below which the EST will switch to low rescrank mode for non 24X applications.\nRPM");
MakeNameEx(0x00011444, "SPARK_ADVANCE_KV_HVS_SWITCH_MODES_REF_COUNT", nameFlags);
MakeNameEx(0x00011454, "SPARK_ADVANCE_KA_LAUNCH_SPARK", nameFlags);
MakeRptCmt(0x00011454, "This calibration is a spark advance or retard based on Coolant Temperature and Engine Run Time.\nDegrees");
MakeNameEx(0x0001155E, "SPARK_ADVANCE_KE_LAUNCH_SPARK_MAXCLTSOAKENABLE", nameFlags);
MakeRptCmt(0x0001155E, "Maximum Coolant Temperature for Soak Time multiplier to be applied to Launch Spark.\nDegrees C");
MakeNameEx(0x00011560, "SPARK_ADVANCE_KE_LAUNCH_SPARK_MINRUNSOAKENABLE", nameFlags);
MakeRptCmt(0x00011560, "Minimum Previous Engine Run Time for Soak Time multiplier to be applied to Launch Spark.\nSeconds");
MakeNameEx(0x00011564, "SPARK_ADVANCE_KE_LAUNCH_SPARKRPMMULTCOOLENABLE", nameFlags);
MakeRptCmt(0x00011564, "Minimum Coolant Temperature for enable of the Engine Speed Multiplier to Launch Spark.\nDegrees C");
MakeNameEx(0x00011566, "SPARK_ADVANCE_KE_LIGHTOFF_AND_LAUNCHRAMPINTIME", nameFlags);
MakeRptCmt(0x00011566, "Used to calculate a ramp in multiplier based upon engine run time.\nSeconds");
MakeNameEx(0x00011568, "SPARK_ADVANCE_KE_LAUNCH_SPARKRPMRUNTIME", nameFlags);
MakeRptCmt(0x00011568, "Minimum Engine Run Time for application of the RPMmultiplier.\nSeconds");
MakeNameEx(0x0001156A, "SPARK_ADVANCE_KV_LAUNCH_SPARK_RPM_MULTIPLIER", nameFlags);
MakeNameEx(0x00011594, "SPARK_ADVANCE_KV_LAUNCH_SPARK_SOAK_MULT", nameFlags);
MakeRptCmt(0x00011594, "This calibration is a multiplier applied to Launch Spark in short soak time conditions.\n0 to 2");
MakeNameEx(0x0001159C, "SPARK_ADVANCE_KV_LAUNCH_SPARK_DELTA_CYLAIRMASS", nameFlags);
MakeRptCmt(0x0001159C, "This calibration is an enabler to Launch Spark when an increasing change in cylinder air mass is above this threshold.\nGrams");
MakeNameEx(0x000115C6, "SPARK_ADVANCE_KV_LAUNCH_SPARK_DELTA_CYLAIRMULT", nameFlags);
MakeRptCmt(0x000115C6, "This calibration is a multiplier for the cylinder air mass threshold.\n0 to 1");
MakeNameEx(0x000115EC, "SPARK_ADVANCE_KV_LAUNCH_SPARK_DELT_CA_TPS_MULT", nameFlags);
MakeRptCmt(0x000115EC, "This calibration is a multiplier to be applied to the cyli- nder air threshold.\n0 to 2");
MakeNameEx(0x00011602, "SPARK_ADVANCE_KV_LAUNCH_SPARK_DURATION", nameFlags);
MakeRptCmt(0x00011602, "This calibration is the number of low resolution reference pulses.\nPulses");
MakeNameEx(0x00011616, "SPARK_ADVANCE_KA_EQ_RATIO_SPARK", nameFlags);
MakeRptCmt(0x00011616, "Equivalence ratio contribution to spark.\nDegrees");
MakeNameEx(0x000118B6, "SPARK_ADVANCE_KA_EGR_SPARK", nameFlags);
MakeRptCmt(0x000118B6, "EGR contribution to spark.\nDegrees");
MakeNameEx(0x00011BA8, "SPARK_ADVANCE_KA_IAT_SPARK", nameFlags);
MakeRptCmt(0x00011BA8, "This calibration determines the main induction air temperature spark.\nDegrees");
MakeNameEx(0x0001206A, "SPARK_ADVANCE_KA_RDSC_DAMPING_GAIN_CT", nameFlags);
MakeRptCmt(0x0001206A, "CLOSED Throttle gain to use in the calculation of RDSC active damping.\nDeg/RPM");
MakeNameEx(0x00012092, "SPARK_ADVANCE_KA_RDSC_DAMPING_GAIN_OT", nameFlags);
MakeRptCmt(0x00012092, "OPEN Throttle gain to use in the calculation of RDSC active damping.\nDeg/RPM");
MakeNameEx(0x000120BA, "SPARK_ADVANCE_KA_RDSC_PHASE_DELAY_TIME_CT", nameFlags);
MakeRptCmt(0x000120BA, "CLOSED Throttle delay of the actual deliveryof active damping spark.\nmSec");
MakeNameEx(0x000120E2, "SPARK_ADVANCE_KA_RDSC_PHASE_DELAY_TIME_OT", nameFlags);
MakeRptCmt(0x000120E2, "OPEN Throttle delay of the actual deliveryof active damping spark.\nmSec");
MakeNameEx(0x0001210A, "SPARK_ADVANCE_KA_RDSC_SPARK_LIMIT_CT", nameFlags);
MakeRptCmt(0x0001210A, "Limits the maximum absolute amount of RDSC active damping, when Closed Throttle.\nDegrees");
MakeNameEx(0x00012132, "SPARK_ADVANCE_KA_RDSC_SPARK_LIMIT_OT", nameFlags);
MakeRptCmt(0x00012132, "Limits the maximum absolute amount of RDSC active damping, when OPEN Throttle.\nDegrees");
MakeNameEx(0x0001215A, "SPARK_ADVANCE_KA_MAIN_CT_DRIVE", nameFlags);
MakeRptCmt(0x0001215A, "This calibration determines base spark closed throttle and drive contribution to spark advance.\nDegrees");
MakeNameEx(0x0001244C, "SPARK_ADVANCE_KA_MAIN_CT_PARK", nameFlags);
MakeRptCmt(0x0001244C, "This calibration determines base spark closed throttle and park or neutral contribution to spark advance.\nDegrees");
MakeNameEx(0x0001273E, "SPARK_ADVANCE_KA_CLT_SPARK", nameFlags);
MakeRptCmt(0x0001273E, "Coolant temperature spark contribution.\nDegrees");
MakeNameEx(0x00012FA0, "SPARK_ADVANCE_KE_EGR_SPARK_DELAY", nameFlags);
MakeRptCmt(0x00012FA0, "The amount of time delay before enabling or disabling EGR spark.\nSeconds");
MakeNameEx(0x00012FA2, "SPARK_ADVANCE_KE_EGR_DUTY_CYCLE_SPARK", nameFlags);
MakeRptCmt(0x00012FA2, "The EGR duty cycle threshold that allows enabling or disabling of EGR spark.\nPercent");
MakeNameEx(0x00012FA4, "SPARK_ADVANCE_KE_RDSC_BLENDOUT_TIME", nameFlags);
MakeRptCmt(0x00012FA4, "This is the time after RDSC is active to blend to 0 degrees.\nSeconds");
MakeNameEx(0x00012FA6, "SPARK_ADVANCE_KE_RDSC_COOLANT", nameFlags);
MakeRptCmt(0x00012FA6, "Coolant must be greater than this to enable RDSC.\nDeg C");
MakeNameEx(0x00012FA8, "SPARK_ADVANCE_KE_RDSC_COOLANT_HIGH_TEMP", nameFlags);
MakeRptCmt(0x00012FA8, "Coolant must be less than this to enable RDSC.\nDeg C");
MakeNameEx(0x00012FAA, "SPARK_ADVANCE_KE_RDSC_FAULTS_THAT_DISABLE", nameFlags);
MakeRptCmt(0x00012FAA, "This identifies the diagnostic fault groups which will disable RDSC control.\nBOOLEAN");
MakeNameEx(0x00012FAE, "SPARK_ADVANCE_KE_RDSC_IS_ENABLED", nameFlags);
MakeRptCmt(0x00012FAE, "This defines if RPM derivative spark control is enabled.\nBOOLEAN");
MakeNameEx(0x00012FB0, "SPARK_ADVANCE_KE_RDSC_KNOCK_LIMIT", nameFlags);
MakeRptCmt(0x00012FB0, "If ESC spark retard is greater than this then disable advance portion of RDSC.\nDegrees");
MakeNameEx(0x00012FB2, "SPARK_ADVANCE_KE_RDSC_MIN_DELTA_RPM_CT", nameFlags);
MakeRptCmt(0x00012FB2, "If RDSC delta RPM calculation is < this, then active damping is 0 degrees, when CLOSED Throttle.\nRPM");
MakeNameEx(0x00012FB4, "SPARK_ADVANCE_KE_RDSC_MIN_DELTA_RPM_OT", nameFlags);
MakeRptCmt(0x00012FB4, "If RDSC delta RPM calculation is < this, then active damping is 0 degrees, when OPEN Throttle.\nRPM");
MakeNameEx(0x00012FB6, "SPARK_ADVANCE_KE_RDSC_PE_FACTOR", nameFlags);
MakeRptCmt(0x00012FB6, "IF PE is active, then RDSC damping and bias is reduced by this factor.\nMultiplier");
MakeNameEx(0x00012FB8, "SPARK_ADVANCE_KE_RDSC_RUN_TIME", nameFlags);
MakeRptCmt(0x00012FB8, "RDSC is not allowed if engine has been running less than this time.\nSeconds");
MakeNameEx(0x00012FBA, "SPARK_ADVANCE_KE_RDSC_STEADY_STATE_TIME", nameFlags);
MakeRptCmt(0x00012FBA, "This is the time RDSC is active once steady state triggered.\nSeconds");
MakeNameEx(0x00012FBC, "SPARK_ADVANCE_KE_RDSC_TIP_TIME", nameFlags);
MakeRptCmt(0x00012FBC, "This is the time RDSC is active once tirggered via a tip-in or tip-out.\nSeconds");
MakeNameEx(0x00012FBE, "SPARK_ADVANCE_KE_RDSC_TIPIN_DELTA_TPS", nameFlags);
MakeRptCmt(0x00012FBE, "Delta throttle position must be greater than this to trigger RDSC on a tip-in.\nPercent");
MakeNameEx(0x00012FC0, "SPARK_ADVANCE_KE_RDSC_TIPIN_TPS", nameFlags);
MakeRptCmt(0x00012FC0, "50 mS old throttle position must have been less than this to trigger RDSC on tip-in.\nPercent");
MakeNameEx(0x00012FC2, "SPARK_ADVANCE_KE_RDSC_TIPOUT_DELTA_TPS", nameFlags);
MakeRptCmt(0x00012FC2, "Delta throttle position must be greater than this to trigger RDSC on a tip-out.\nPercent");
MakeNameEx(0x00012FC4, "SPARK_ADVANCE_KE_RDSC_TIPOUT_TPS", nameFlags);
MakeRptCmt(0x00012FC4, "50 mS old throttle position must have been greater than this to trigger RDSC on tip-out.\nPercent");
MakeNameEx(0x00012FC6, "SPARK_ADVANCE_KE_RDSC_TORQUE_CONTROL_SPARK", nameFlags);
MakeRptCmt(0x00012FC6, "If torque control spark is greater than this value, then disable RDSC.\nDegrees");
MakeNameEx(0x00012FC8, "SPARK_ADVANCE_KE_RDSC_TPS_THRESHOLD", nameFlags);
MakeNameEx(0x00012FCA, "SPARK_ADVANCE_KE_LIMIT_MAX_ADVANCE", nameFlags);
MakeRptCmt(0x00012FCA, "The maximum allowable spark advance.\nDegrees");
MakeNameEx(0x00012FCC, "SPARK_ADVANCE_KE_CT_TPS_THRESHOLD", nameFlags);
MakeRptCmt(0x00012FCC, "This calibration establishes the threshold for closed throttle base spark table lookups.\nPercent");
MakeNameEx(0x00012FCE, "SPARK_ADVANCE_KE_CT_TPS_HYSTERESIS", nameFlags);
MakeRptCmt(0x00012FCE, "This calibration establishes closed throttle hysteresis for the base spark table lookups.\nPercent");
MakeNameEx(0x00012FD0, "SPARK_ADVANCE_KE_CT_VEH_SPD_THRESHOLD", nameFlags);
MakeRptCmt(0x00012FD0, "This calibration establishes closed throttle vehicle speed threshold for the base spark table lookups.\nMPH");
MakeNameEx(0x00012FD2, "SPARK_ADVANCE_KE_CT_VEH_SPD_HYSTERESIS", nameFlags);
MakeRptCmt(0x00012FD2, "This calibration establishes closed throttle vehicle speed hysteresis for the base spark table lookups.\nMPH");
MakeNameEx(0x00012FD4, "SPARK_ADVANCE_KE_SHIFT_DR_TO_PN_RAMP", nameFlags);
MakeRptCmt(0x00012FD4, "Rate at which to ramp spark when transitioning from drive to park.\nDegrees");
MakeNameEx(0x00012FD6, "SPARK_ADVANCE_KE_EGR_SPARK_MULT_LIMIT", nameFlags);
MakeNameEx(0x00012FD8, "SPARK_ADVANCE_KE_SHIFT_PN_TO_DR_RAMP", nameFlags);
MakeRptCmt(0x00012FD8, "Rate at which to ramp spark when transitioning from park to drive.\nDegrees");
MakeNameEx(0x00012FDA, "SPARK_ADVANCE_KE_POWER_STEERING_PRESS_MOD", nameFlags);
MakeRptCmt(0x00012FDA, "This calibration is a high engine load power steering pressure input spark modifier.\nDegrees");
MakeNameEx(0x00012FDC, "SPARK_ADVANCE_KV_APPLIED_OCTANE_SCALER_MULT", nameFlags);
MakeRptCmt(0x00012FDC, "Modifies the calculated octane scaler to establish authority based on temperature.\nMultiplier_0_to_1");
MakeNameEx(0x00013002, "SPARK_ADVANCE_KV_ENG_PROTECTION_SPARK_ADVANCE", nameFlags);
MakeRptCmt(0x00013002, "Spark advance value based on engine speed if engine protection is enabled.\nDegrees");
MakeNameEx(0x0001302C, "SPARK_ADVANCE_KV_EQ_RATIO_MAP_MODIFIER", nameFlags);
MakeRptCmt(0x0001302C, "A MAP modifier applied to the equivalence ratio angle.\nMultiplier_0_to_2");
MakeNameEx(0x0001304E, "SPARK_ADVANCE_KV_IAT_RPM_MODIFIER", nameFlags);
MakeRptCmt(0x0001304E, "Induction air temperature spark modifier based on engine speed.\nMultiplier");
MakeNameEx(0x00013078, "SPARK_ADVANCE_KV_IAT_SPARK_COOLANT_MODIFIER", nameFlags);
MakeRptCmt(0x00013078, "Induction air temperature spark modifier based on coolant temperature.\nMultiplier_0_to_1");
MakeNameEx(0x000130C2, "SPARK_ADVANCE_KV_IDLE_FLARE_COOLANT_MULT", nameFlags);
MakeRptCmt(0x000130C2, "Modifies the flare control idle spark as a function of coolant temperature.\nMultiplier_0_to_1");
MakeNameEx(0x000130D6, "SPARK_ADVANCE_KV_LIMIT_LOW_RPM_DELTA", nameFlags);
MakeRptCmt(0x000130D6, "Maximum allowable spark advance delta between two consecutive events at low engine speeds.\nDegrees");
MakeNameEx(0x000130F2, "SPARK_ADVANCE_KV_RDSC_DELTA_RPM_TIME", nameFlags);
MakeRptCmt(0x000130F2, "This determines the sampling rate of RPM for delta RPM calc in RDSC.\nmSec");
MakeNameEx(0x00013106, "SPARK_ADVANCE_KV_RDSC_DELTA_RPM_SS_TIME", nameFlags);
MakeRptCmt(0x00013106, "This determines the sampling rate of RPM for delta RPM calc in steady state RDSC mode.\nmSec");
MakeNameEx(0x0001311A, "SPARK_ADVANCE_KV_RDSC_MPH_RANGE", nameFlags);
MakeRptCmt(0x0001311A, "If the vehicle speed is outside this range, disable RDSC.\nMPH");
MakeNameEx(0x0001311E, "SPARK_ADVANCE_KV_RDSC_RPM_RANGE", nameFlags);
MakeRptCmt(0x0001311E, "If the engine speed is outside this range, disable RDSC.\nRPM");
MakeNameEx(0x00013122, "SPARK_ADVANCE_KV_RDSC_SPARK_BIAS_DELAY", nameFlags);
MakeRptCmt(0x00013122, "Delay time after tip-in RDSC triggered, before allowing RDSC bias retard.\nSeconds");
MakeNameEx(0x00013136, "SPARK_ADVANCE_KV_RDSC_SPARK_BIAS_RETARD_CT", nameFlags);
MakeRptCmt(0x00013136, "Amount of RDSC spark bias retard when active, and CLOSED Throttle.\nDegrees");
MakeNameEx(0x0001314A, "SPARK_ADVANCE_KV_RDSC_SPARK_BIAS_RETARD_OT", nameFlags);
MakeRptCmt(0x0001314A, "Amount of RDSC spark bias retard when active, and OPEN Throttle.\nDegrees");
MakeNameEx(0x0001315E, "SPARK_ADVANCE_KV_RDSC_STEADY_STATE_TPS", nameFlags);
MakeRptCmt(0x0001315E, "If TPS is less than this steady state RDSC is triggered.\nPercent");
MakeNameEx(0x00013162, "SPARK_ADVANCE_KA_CLT_RPM_MODIFIER", nameFlags);
MakeRptCmt(0x00013162, "Coolant temperature spark modifier based on engine speed and coolant temperature.\n0 to 2");
MakeNameEx(0x00013774, "SPARK_ADVANCE_KV_CRANK_SPARK_MED_RES", nameFlags);
MakeRptCmt(0x00013774, "Spark advance when engine is cranking.\nDegrees");
MakeNameEx(0x0001379A, "SPARK_ADVANCE_KV_IDLE_FLARE_CONTROL", nameFlags);
MakeRptCmt(0x0001379A, "Spark modifier based on input from IAC to control engine startup idle flare.\nDegrees");
MakeNameEx(0x000137B0, "SPARK_ADVANCE_KV_IDLE_OVERSPEED_ERROR", nameFlags);
MakeRptCmt(0x000137B0, "This is the spark idle overspeed modifier.\nDegrees");
MakeNameEx(0x000137C4, "SPARK_ADVANCE_KV_IDLE_UNDERSPEED_ERROR", nameFlags);
MakeRptCmt(0x000137C4, "This is the spark idle underspeed modifier.\nDegrees");
MakeNameEx(0x000137D8, "SPARK_ADVANCE_KV_SHIFT_DR_TO_PN_INHIBIT", nameFlags);
MakeRptCmt(0x000137D8, "Inhibits the drive to park spark transition until this time is expired.\nSeconds");
MakeNameEx(0x000137FE, "SPARK_ADVANCE_KV_SHIFT_PN_TO_DR_INHIBIT", nameFlags);
MakeRptCmt(0x000137FE, "Inhibits the park to drive spark transition until this time is expired.\nSeconds");
MakeNameEx(0x00013824, "SPARK_ADVANCE_KA_FFS_E80_SPARK_SHIFT", nameFlags);
MakeRptCmt(0x00013824, "This cal determines the flex fuel contribution to spark advance assuming E80 fuel (80% ethanol).\nDegrees");
MakeNameEx(0x00013B18, "SPARK_ADVANCE_KA_FFS_E80_MBT_SPARK_SHIFT", nameFlags);
MakeRptCmt(0x00013B18, "This cal determines the flex fuel contribution to MBT assuming E80 fuel (80% ethanol).\nDegrees");
MakeNameEx(0x00013CA4, "SPARK_ADVANCE_KE_HVS_TEST_RPM_HI", nameFlags);
MakeRptCmt(0x00013CA4, "HVS position monitoring and limit adjusting logic is performed below this RPM.\nRPM");
MakeNameEx(0x00013CA6, "SPARK_ADVANCE_KE_HVS_TEST_RPM_LO", nameFlags);
MakeRptCmt(0x00013CA6, "HVS position monitoring and limit adjusting logic is performed above this RPM.\nRPM");
MakeNameEx(0x00013CA8, "SPARK_ADVANCE_KE_HVS_MAX_RETARD", nameFlags);
MakeRptCmt(0x00013CA8, "Maximum spark retard permitted by the HVS.\nDegrees");
MakeNameEx(0x00013CAA, "SPARK_ADVANCE_KE_HVS_DEGREE_OFFSET_DEFAULT", nameFlags);
MakeRptCmt(0x00013CAA, "Default HVS offset when no CAM falling edge is detected.\nDegrees");
MakeNameEx(0x00013CAC, "SPARK_ADVANCE_KE_CRANK_BLEND_STEP_OT", nameFlags);
MakeRptCmt(0x00013CAC, "Open throttle crank to run spark blending step size.\nDegrees");
MakeNameEx(0x00013CAE, "SPARK_ADVANCE_KE_CRANK_BLEND_TPS", nameFlags);
MakeRptCmt(0x00013CAE, "If throttle position is less than this value use Kx_TPS_Blend_Step otherwise use Kx_Spark_Blend_Step.\nPercent");
MakeNameEx(0x00013CB0, "SPARK_ADVANCE_KE_CRANK_BLEND_STEP_CT", nameFlags);
MakeRptCmt(0x00013CB0, "Closed throttle crank to run spark blending step size.\nDegrees");
MakeNameEx(0x00013CB2, "SPARK_ADVANCE_KE_CAT_LIGHTOFF_REENABLE_REFS", nameFlags);
MakeRptCmt(0x00013CB2, "Number of ref pulses over which lightoff retard is ramped back in after disable from vacuum or lauch spark.\nCARDINAL");
MakeNameEx(0x00013CB4, "SPARK_ADVANCE_KE_CAT_LIGHTOFF_SPARK_VACUUM_DIS", nameFlags);
MakeRptCmt(0x00013CB4, "Set Catalyst Lightoff Spark Retard to zero when engine manifold vacuum is greater than this value.\nkPa");
MakeNameEx(0x00013CB6, "SPARK_ADVANCE_KE_CAT_LIGHTOFF_SPARK_VACUUM_ENA", nameFlags);
MakeNameEx(0x00013CB8, "SPARK_ADVANCE_KE_EGR_INCR_SPARK_FILT", nameFlags);
MakeRptCmt(0x00013CB8, "\n");
MakeNameEx(0x00013CBA, "SPARK_ADVANCE_KV_CRANK_AFTERSTART_STEP", nameFlags);
MakeNameEx(0x00013CE0, "SPARK_ADVANCE_KV_CRANK_AFTERSTART_TIME", nameFlags);
MakeRptCmt(0x00013CE0, "Engine run time below which crank to run blend is controlled by either Kx_Afterstart_Blend_Step or Kx_Spark_Blend_Step.\nSeconds");
MakeNameEx(0x00013D06, "SPARK_ADVANCE_KV_CAT_LIGHTOFF_COOLANT_MULT", nameFlags);
MakeRptCmt(0x00013D06, "Powerup coolant multiplier applied to the catalyst lightoffspark retard.\nMultiplier_0_to_2");
MakeNameEx(0x00013D2C, "SPARK_ADVANCE_KV_CAT_LIGHTOFF_THROTTLE_MULT", nameFlags);
MakeRptCmt(0x00013D2C, "Throttle position multiplier applied to the catalyst lightoffspark retard.\nMultiplier_0_to_1");
MakeNameEx(0x00013D42, "SPARK_ADVANCE_KV_CAT_LIGHTOFF_HOLD_TIME", nameFlags);
MakeRptCmt(0x00013D42, "The amount of time catalyst lightoff retard is active.\nSeconds");
MakeNameEx(0x00013D68, "SPARK_ADVANCE_KV_CAT_LIGHTOFF_DECAY_TIME", nameFlags);
MakeRptCmt(0x00013D68, "The time over which catalyst lightoff retard is decayed to 0 after the hold time is satisfied.\nSeconds");
MakeNameEx(0x00013D8E, "SPARK_ADVANCE_KA_PISTON_SLAP_SPARK_RETARD", nameFlags);
MakeRptCmt(0x00013D8E, "This calibration determines the Piston Slap contribution to spark advance.\nDegrees");
MakeNameEx(0x00013ED8, "SPARK_ADVANCE_KV_PISTON_SLAP_COOLANT_MULT", nameFlags);
MakeRptCmt(0x00013ED8, "This calibration is a Piston Slap Spark modifier based on Coolant Temperature.\nUnitless");
MakeNameEx(0x00013EFE, "SPARK_DWELL_KA_MAIN_DWELL_TIME", nameFlags);
MakeRptCmt(0x00013EFE, "This determines the base dwell time.\nMilliseconds");
MakeNameEx(0x0001436C, "SPARK_DWELL_KA_MODIFIER_DWELL_TIME", nameFlags);
MakeNameEx(0x00014588, "SPARK_DWELL_KE_100MS_STEADY_STATE_RPM", nameFlags);
MakeNameEx(0x0001458A, "SPARK_DWELL_KE_CRANK_BOOST_DWELL", nameFlags);
MakeRptCmt(0x0001458A, "Cold start crank mode modifier to the core dwell.\nMultiplier_0_to_4");
MakeNameEx(0x0001458C, "SPARK_DWELL_KE_INITIAL_DWELL", nameFlags);
MakeRptCmt(0x0001458C, "Dwell is initialized to this value at powerup.\nMilliseconds");
MakeNameEx(0x0001458E, "SPARK_DWELL_KE_INITIAL_MAX_DWELL", nameFlags);
MakeRptCmt(0x0001458E, "Initial dwell multiplier to determine max dwell atpowerup.\nMultiplier_1p1_to_1p3");
MakeNameEx(0x0001458F, "SPARK_DWELL_KE_INITIAL_MIN_DWELL", nameFlags);
MakeRptCmt(0x0001458F, "Initial dwell multiplier to determine min dwell atpowerup.\nMultiplier_0_to_1p0");
MakeNameEx(0x00014590, "SPARK_DWELL_KV_HVS_MIN_RUN_DWELL", nameFlags);
MakeRptCmt(0x00014590, "The minimum dwell required at a given RPM in low-res only ignition systems.\nMillisec_vs_RPM_0to8000_Table");
MakeNameEx(0x000145BA, "SPARK_DWELL_KV_MAX_DWELL", nameFlags);
MakeRptCmt(0x000145BA, "This determines the max dwell time .\nMult1p1to1p3_vs_RPM_0to8000_Tbl");
MakeNameEx(0x000145D0, "SPARK_DWELL_KV_DWELL_MAP_MODIFIER", nameFlags);
MakeRptCmt(0x000145D0, "Modifier applied to the calculated dwell to adjust the value as a function of manifold pressure.\nMult_0to2_vs_kPa_20to100_Table");
MakeNameEx(0x000145F2, "SPARK_DWELL_KV_MIN_DWELL", nameFlags);
MakeRptCmt(0x000145F2, "This determines the min dwell time .\nMult0to1p0_vs_RPM_0to8000_Table");
MakeNameEx(0x00014608, "SPARK_DWELL_KE_HVS_MAX_CRANK_DWELL", nameFlags);
MakeRptCmt(0x00014608, "EST will be forced off after this amount of time to prevent coil damage.\nSeconds");
MakeNameEx(0x0001460A, "SPARK_KNOCK_KE_NUMBER_OF_SENSORS", nameFlags);
MakeRptCmt(0x0001460A, "This is the number of ESC sensors used to determine if ESC sensors should be multiplexed in diagnostics.\nNumber");
MakeNameEx(0x0001460C, "SPARK_KNOCK_KE_DELTA_TPS_ABSOLUTE_MAD_DIS", nameFlags);
MakeRptCmt(0x0001460C, "If TPS changes more than this in 200 ms MAD learning will be disabled\nPercent");
MakeNameEx(0x0001460E, "SPARK_KNOCK_KE_DELTA_RPM_ABSOLUTE_MAD_DIS", nameFlags);
MakeRptCmt(0x0001460E, "If RPM changes more than this in 200 ms MAD learning will be disabled\nRPM");
MakeNameEx(0x00014610, "SPARK_KNOCK_KE_DELTA_MAP_ABSOLUTE_MAD_DIS", nameFlags);
MakeRptCmt(0x00014610, "If 12p5_ms_Filtered_MAP has changed more than this MAD learning will be disabled\nRPM");
MakeNameEx(0x00014612, "SPARK_KNOCK_KE_MAP_12P5_MS_FILT_COEFFICIENT", nameFlags);
MakeRptCmt(0x00014612, "Filter coefficient for 12.5 ms MAP readings\nCoef.");
MakeNameEx(0x00014613, "SPARK_KNOCK_KE_ADAPTIVE_BPF_GAIN_ADJ_RATE", nameFlags);
MakeRptCmt(0x00014613, "This controls the number of 200 ms loops betweenadaptive BPF gain calculations\nCounts");
MakeNameEx(0x00014614, "SPARK_KNOCK_KE_INITIAL_ADAPTIVE_BPF_GAIN", nameFlags);
MakeRptCmt(0x00014614, "This is the initial value for the BPF Gain.\nGain_dB");
MakeNameEx(0x00014615, "SPARK_KNOCK_KE_MIN_ADAPTIVE_BPF_GAIN", nameFlags);
MakeRptCmt(0x00014615, "This is the minimum value for the BPF Gain.\nGain_dB");
MakeNameEx(0x00014616, "SPARK_KNOCK_KE_MAX_ADAPTIVE_BPF_GAIN", nameFlags);
MakeRptCmt(0x00014616, "This is the maximum value for the BPF Gain.\nGain_dB");
MakeNameEx(0x00014617, "SPARK_KNOCK_KE_DIAG_IRIC_DB_GAIN", nameFlags);
MakeRptCmt(0x00014617, "This is the value for the BPF Gain in diagnostic mode.\nGain_dB");
MakeNameEx(0x00014618, "SPARK_KNOCK_KE_RPM_KNOCK_LOW", nameFlags);
MakeRptCmt(0x00014618, "RPM value below this level will not enable Delta RPM detection logic.\nRPM");
MakeNameEx(0x0001461A, "SPARK_KNOCK_KE_RPM_KNOCK_HIGH", nameFlags);
MakeRptCmt(0x0001461A, "RPM value above this level will not enable Delta RPM detection logic.\nRPM");
MakeNameEx(0x0001461C, "SPARK_KNOCK_KE_RPM_KNOCK_DELTA", nameFlags);
MakeRptCmt(0x0001461C, "An RPM increase greater than this over a 25 msec time period will enable the Delta RPM detection logic.\nRPM");
MakeNameEx(0x0001461E, "SPARK_KNOCK_KE_RPM_KNOCK_TIME", nameFlags);
MakeRptCmt(0x0001461E, "Duration of time to modify knock thresholds due to an engine speed increase.\nSecond");
MakeNameEx(0x00014620, "SPARK_KNOCK_KA_OCTANE_INIT_MODIFIER", nameFlags);
MakeRptCmt(0x00014620, "Octane adaptive scaler is modified by this calibrated amount every powerup when KE_Octane_Scaler_Modify_On_Init is TRUE.\nScaler -1 to 1");
MakeNameEx(0x000148F2, "SPARK_KNOCK_KE_ADAPT_BPF_HIGH_AVG_NOISE_THRE", nameFlags);
MakeRptCmt(0x000148F2, "If the average noise is greater than this value the adaptive gain will be decreased.\nVolts");
MakeNameEx(0x000148F4, "SPARK_KNOCK_KE_ADAPT_BPF_LOW_AVG_NOISE_THRES", nameFlags);
MakeRptCmt(0x000148F4, "If the average noise is less than this value the adaptive gain will be increased.\nVolts");
MakeNameEx(0x000148F6, "SPARK_KNOCK_KE_KNOCK_DETECTOR_MAD_INIT", nameFlags);
MakeRptCmt(0x000148F6, "Initialization value for Knock_Detector_MAD value invoked during powerup.\nMillivolts");
MakeNameEx(0x000148FA, "SPARK_KNOCK_KE_KNOCK_DETECTOR_MAD_MAX", nameFlags);
MakeRptCmt(0x000148FA, "Maximum allowable knock detector mean absolute deviation (MAD) for any sensor.\nMillivolts");
MakeNameEx(0x000148FE, "SPARK_KNOCK_KE_KNOCK_DETECTOR_MAD_MIN", nameFlags);
MakeRptCmt(0x000148FE, "Minimum allowable knock detector mean absolute deviation (MAD) for any sensor.\nMillivolts");
MakeNameEx(0x00014902, "SPARK_KNOCK_KE_KNOCK_MAD_MAP_THRESH", nameFlags);
MakeRptCmt(0x00014902, "Above this manifold pressure, threshold Knock_Detector_MAD can be updated.\nkPa");
MakeNameEx(0x00014904, "SPARK_KNOCK_KE_KNOCK_MAD_RPM_THRESH", nameFlags);
MakeRptCmt(0x00014904, "Above this engine speed, threshold Knock_Detector_MAD can be updated.\nRPM");
MakeNameEx(0x00014906, "SPARK_KNOCK_KE_MAD_COEFFICIENT_SAMPLES", nameFlags);
MakeRptCmt(0x00014906, "Determines the number of samples used in computing Knock_Detector_MAD.\nCounts");
MakeNameEx(0x00014908, "SPARK_KNOCK_KE_IR_AVERAGE_NOISE_INITIAL", nameFlags);
MakeRptCmt(0x00014908, "If KE_IR_Avg_Noise_Modify_Init is TRUE then all IR average noise levels will be set to this calibration upon initialization.\nVolts");
MakeNameEx(0x0001490A, "SPARK_KNOCK_KE_IR_AVG_NOISE_MODIFY_INIT", nameFlags);
MakeRptCmt(0x0001490A, "When set to TRUE, all IR average noise levels will be set to a calibration upon initialization.\nBoolean");
MakeNameEx(0x0001490C, "SPARK_KNOCK_KE_OCTANE_SCALER_DIAG_DEFAULT", nameFlags);
MakeRptCmt(0x0001490C, "This is the octane scaler value if a knock sensor group fault is active.\nMultiplier_0_To_1");
MakeNameEx(0x0001490E, "SPARK_KNOCK_KE_OCTANE_SCALER_MODIFY_ON_INIT", nameFlags);
MakeRptCmt(0x0001490E, "When set to TRUE the octane adaptive scaler will be modified on every powerup.\nBoolean");
MakeNameEx(0x0001490F, "SPARK_KNOCK_KE_SPEED_CHANGE_HIGH_COUNTER_A", nameFlags);
MakeRptCmt(0x0001490F, "When this calibration is exceeded, the slow sample number will be used for determining the average noise level.\nCounts");
MakeNameEx(0x00014910, "SPARK_KNOCK_KV_KNOCK_FAST_ATTACK_COOL_GAIN", nameFlags);
MakeRptCmt(0x00014910, "An attack rate coolant gain table that allows the detector to be disabled below an engine temperature.\nScaler");
MakeNameEx(0x00014936, "SPARK_KNOCK_KV_KNOCK_FAST_ATTACK_BARO_GAIN", nameFlags);
MakeRptCmt(0x00014936, "An attack rate baro gain table that adjusts the detector's sensitivity for changes in altitude.\nScaler");
MakeNameEx(0x00014942, "SPARK_KNOCK_KV_KNOCK_FAST_IR_ATTACK_RATE", nameFlags);
MakeRptCmt(0x00014942, "This calibration is a knock retard fast multiplier based on engine speed for Integrate and Read Modes.\nDegrees/V");
MakeNameEx(0x0001496C, "SPARK_KNOCK_KV_KNOCK_RETARD_LIMIT_LOAD", nameFlags);
MakeRptCmt(0x0001496C, "This calibration is the total maximum knock retard authority allowed when Power Enrichment is not active.\nDegrees");
MakeNameEx(0x0001498E, "SPARK_KNOCK_KV_KNOCK_RETARD_LIMIT_SPEED", nameFlags);
MakeRptCmt(0x0001498E, "This calibration is the total maximum knock retard authority allowed when Power Enrichment is active.\nDegrees");
MakeNameEx(0x000149B8, "SPARK_KNOCK_KV_KNOCK_RETARD_DEFAULT_LOAD", nameFlags);
MakeRptCmt(0x000149B8, "This calibration is the default value for knock retard fast when Knock System faults exist.\nDegrees");
MakeNameEx(0x000149CA, "SPARK_KNOCK_KV_KNOCK_FAST_RECOVER_RATE", nameFlags);
MakeNameEx(0x000149F4, "SPARK_KNOCK_KE_LRN_GAIN_MIN_MAP", nameFlags);
MakeRptCmt(0x000149F4, "Manifold Pressure value below which Learn Gain is set to zero.\nkPa");
MakeNameEx(0x000149F6, "SPARK_KNOCK_KE_LRN_GAIN_MAX_RPM", nameFlags);
MakeRptCmt(0x000149F6, "Engine Speed value above which Learn Gain is set to zero.\nRPM");
MakeNameEx(0x000149F8, "SPARK_KNOCK_KE_LRN_GAIN_MIN_RPM", nameFlags);
MakeRptCmt(0x000149F8, "Engine Speed value below which Learn Gain is set to zero.\nRPM");
MakeNameEx(0x000149FA, "SPARK_KNOCK_KE_LRN_GAIN_MIN_COOL", nameFlags);
MakeRptCmt(0x000149FA, "Coolant Temperature value below which Learn Gain is set to zero.\nDegrees_C");
MakeNameEx(0x000149FC, "SPARK_KNOCK_KE_LRN_GAIN_MIN_IAT", nameFlags);
MakeRptCmt(0x000149FC, "Induction Air Temperature value below which Learn Gain is set to zero.\nDegrees_C");
MakeNameEx(0x000149FE, "SPARK_KNOCK_KE_LRN_GAIN_TOTAL_RTD", nameFlags);
MakeRptCmt(0x000149FE, "Total retard value above which Learn Gain is set to zero.\nDegrees");
MakeNameEx(0x00014A00, "SPARK_KNOCK_KE_MAP_WEIGHT_FACTOR", nameFlags);
MakeRptCmt(0x00014A00, "Weighted Multiplier for MAP contribution to Learn Gain.\nMultiplier");
MakeNameEx(0x00014A02, "SPARK_KNOCK_KE_RPM_WEIGHT_FACTOR", nameFlags);
MakeRptCmt(0x00014A02, "Weighted Multiplier for RPM contribution to Learn Gain.\nMultiplier");
MakeNameEx(0x00014A04, "SPARK_KNOCK_KE_COOL_WEIGHT_FACTOR", nameFlags);
MakeRptCmt(0x00014A04, "Weighted Multiplier for coolant temperature contribution to Learn Gain.\nMultiplier");
MakeNameEx(0x00014A06, "SPARK_KNOCK_KE_DELTA_TIP_IN_TPS", nameFlags);
MakeRptCmt(0x00014A06, "Delta TPS to activate transient condition check.\nPercent");
MakeNameEx(0x00014A08, "SPARK_KNOCK_KE_IAT_WEIGHT_FACTOR", nameFlags);
MakeRptCmt(0x00014A08, "Weighted Multiplier for Induction Air Temperature contribution to Learn Gain.\nMultiplier");
MakeNameEx(0x00014A0A, "SPARK_KNOCK_KE_TOTAL_RTD_WEIGHT_FACTOR", nameFlags);
MakeRptCmt(0x00014A0A, "Weighted Multiplier for Total Retard contribution to Learn Gain.\nMultiplier");
MakeNameEx(0x00014A0C, "SPARK_KNOCK_KE_TIP_IN_KNOCK_TIME", nameFlags);
MakeRptCmt(0x00014A0C, "Time that the transient calibrations to modify the knock detection criteria are enabled.\nSeconds");
MakeNameEx(0x00014A0E, "SPARK_KNOCK_KE_TPS_KNOCK_HIGH", nameFlags);
MakeRptCmt(0x00014A0E, "Maximum TPS to activate transient condition check.\nPercent");
MakeNameEx(0x00014A10, "SPARK_KNOCK_KE_TPS_KNOCK_LOW", nameFlags);
MakeRptCmt(0x00014A10, "Minimum TPS to activate transient condition check.\nPercent");
MakeNameEx(0x00014A12, "SPARK_KNOCK_KV_KNOCK_MAP_LEARN_GAIN", nameFlags);
MakeRptCmt(0x00014A12, "Manifold Pressure contribution to engine's propensity to knock.\nMultiplier");
MakeNameEx(0x00014A24, "SPARK_KNOCK_KV_KNOCK_RPM_LEARN_GAIN", nameFlags);
MakeRptCmt(0x00014A24, "Engine Speed contribution to engine's propensity to knock.\nMultiplier");
MakeNameEx(0x00014A3A, "SPARK_KNOCK_KV_KNOCK_COOL_LEARN_GAIN", nameFlags);
MakeRptCmt(0x00014A3A, "Coolant Temperature contribution to engine's propensity to knock.\nMultiplier");
MakeNameEx(0x00014A4E, "SPARK_KNOCK_KV_KNOCK_IAT_LEARN_GAIN", nameFlags);
MakeRptCmt(0x00014A4E, "Induction Air Temperature contribution to engine's propensity to knock.\nMultiplier");
MakeNameEx(0x00014A62, "SPARK_KNOCK_KV_KNOCK_TOTAL_RTD_LEARN_GAIN", nameFlags);
MakeRptCmt(0x00014A62, "Total Spark Retard contribution to engine's propensity to knock.\nMultiplier");
MakeNameEx(0x00014A78, "SPARK_KNOCK_KE_OCTANE_INIT_SCALER", nameFlags);
MakeRptCmt(0x00014A78, "This calibration is the initial value for Octane Scaler.\nMultiplier");
MakeNameEx(0x00014A7A, "SPARK_KNOCK_KV_DELTA_OCTANE_MULT", nameFlags);
MakeNameEx(0x00014AB8, "SPARK_KNOCK_KE_OCTANE_SCALER_INCREMENT", nameFlags);
MakeRptCmt(0x00014AB8, "This is the rate to increment the Octane Scaler when conditions are met.\nMultiplier");
MakeNameEx(0x00014ABA, "SPARK_KNOCK_KE_OCT_KNOCK_FAST_THRESH", nameFlags);
MakeRptCmt(0x00014ABA, "Learn down octane scaler only if Knock_Retard_Fast exceeds this minimum threshold.\nDegrees");
MakeNameEx(0x00014ABC, "SPARK_KNOCK_KE_OCTANE_SCALER_DECREMENT", nameFlags);
MakeRptCmt(0x00014ABC, "This is the rate to decrement the Octane Scaler when conditions are met.\nMultiplier");
MakeNameEx(0x00014ABE, "SPARK_KNOCK_KE_KNOCK_DETECTION_MODE", nameFlags);
MakeRptCmt(0x00014ABE, "This calibration selects the knock detection configuration.\nIRIC Mode");
MakeNameEx(0x00014AC0, "SPARK_KNOCK_KE_BANK_HOLD_TIME", nameFlags);
MakeRptCmt(0x00014AC0, "This is the amount of time between toggling the ESC Select line when in diagnostics mode.\nMillisecs.");
MakeNameEx(0x00014AC2, "SPARK_KNOCK_KE_MUX_PATTERN_CONTROL", nameFlags);
MakeNameEx(0x00014AC3, "SPARK_KNOCK_KE_TDC_OFFSET", nameFlags);
MakeNameEx(0x00014AC4, "SPARK_KNOCK_KV_BPF1_FC", nameFlags);
MakeRptCmt(0x00014AC4, "This is the center frequency for bandpass filter 1.\nKHz");
MakeNameEx(0x00014ADA, "SPARK_KNOCK_KV_BPF1_Q", nameFlags);
MakeRptCmt(0x00014ADA, "This is the quality factor for bandpass filter 1.\nQ");
MakeNameEx(0x00014AF0, "SPARK_KNOCK_KA_INTEGRATION_TIME", nameFlags);
MakeRptCmt(0x00014AF0, "This sets the integration time constant for the Integrate and Read mode.\nMicrosecs.");
MakeNameEx(0x00014B8A, "SPARK_KNOCK_KE_SPEED_CHANGE_HIGH", nameFlags);
MakeRptCmt(0x00014B8A, "When delta engine speed is above this threshold use the high noise channel time constants.\nRPM");
MakeNameEx(0x00014B8C, "SPARK_KNOCK_KE_DIAG1_MODE", nameFlags);
MakeRptCmt(0x00014B8C, "This calibration selects the output for diagnostics mux 1.\nMode");
MakeNameEx(0x00014B8D, "SPARK_KNOCK_KE_DIAG2_MODE", nameFlags);
MakeRptCmt(0x00014B8D, "This calibration selects the output for diagnostics mux 2.\nMode");
MakeNameEx(0x00014B8E, "SPARK_KNOCK_KV_ESC_SELECTION_TIME", nameFlags);
MakeRptCmt(0x00014B8E, "Time delay from the TDC_Reference -MEDRES- to wherethe ESC Bank Select line will change.\nMillisecs.");
MakeNameEx(0x00014BB8, "SPARK_KNOCK_KA_GATE_DELAY", nameFlags);
MakeRptCmt(0x00014BB8, "Time delay from the TDC_Reference -MEDRES- to wherethe WINGATE goes high - start of integration.\nMicrosecs.");
MakeNameEx(0x00014CDE, "SPARK_KNOCK_KA_GATE_ACTIVE", nameFlags);
MakeRptCmt(0x00014CDE, "Integration time - duration of WINGATE.\nMicrosecs.");
MakeNameEx(0x00014E04, "SPARK_KNOCK_KE_MINIMUM_AVERAGE_NOISE_LEVEL", nameFlags);
MakeRptCmt(0x00014E04, "This calibration establishes a minimum learned average noise level for the Integrate and Read detector threshold calculation.\nVolts");
MakeNameEx(0x00014E06, "SPARK_KNOCK_KE_IR_OFFSET_CANCEL", nameFlags);
MakeRptCmt(0x00014E06, "This calibration controls offset cancellation in the IRIC when in Integrate and Read modes.\nBOOLEAN");
MakeNameEx(0x00014E07, "SPARK_KNOCK_KE_CYLINDER_DETECTION_MODE", nameFlags);
MakeRptCmt(0x00014E07, "Determines for Integrate and Read Modes only if the cylinder detection strategy will be Global or Individual\nMode");
MakeNameEx(0x00014E08, "SPARK_KNOCK_KE_KNOCK_PORTION", nameFlags);
MakeRptCmt(0x00014E08, "The portion of the knock A/D reading used in the calculation of the average noise level knock event.\nMultiplier");
MakeNameEx(0x00014E0A, "SPARK_KNOCK_KV_DELTA_RPM_KNOCK_ENERGY_MAD", nameFlags);
MakeRptCmt(0x00014E0A, "This calibration is used to establish the knock limit if Delta RPM knock detection is true.\nMultiplier");
MakeNameEx(0x00014E34, "SPARK_KNOCK_KV_KNOCK_ENERGY_MAD", nameFlags);
MakeRptCmt(0x00014E34, "This calibration is used with the Integrated energy read to determine if knock occurred.\nMultiplier");
MakeNameEx(0x00014E5E, "SPARK_KNOCK_KV_TIP_IN_KNOCK_ENERGY_MAD", nameFlags);
MakeRptCmt(0x00014E5E, "This calibration is used to establish the knock limit if Tip_In_Knock_Detection is TRUE.\nMultiplier");
MakeNameEx(0x00014E88, "SPARK_KNOCK_KA_KNOCK_ENERGY_MAD", nameFlags);
MakeRptCmt(0x00014E88, "This calibration is used with the Integrated energy read to determine if knock occurred.\nMultiplier");
MakeNameEx(0x00014FD8, "SPARK_KNOCK_KV_KNOCK_ENERGY_MAD_GAIN", nameFlags);
MakeRptCmt(0x00014FD8, "This calibration is used with the Integrated energy read to establish a knock threshold.\nMultiplier");
MakeNameEx(0x00014FFA, "SPARK_KNOCK_KA_KNOCK_ENERGY_MAD_GAIN", nameFlags);
MakeRptCmt(0x00014FFA, "This calibration is used with the Integrated energy read to establish a knock threshold.\nMultiplier");
MakeNameEx(0x000152C4, "SPARK_KNOCK_KE_SAMPLE_NUMBER_SLOW", nameFlags);
MakeNameEx(0x000152C5, "SPARK_KNOCK_KE_SAMPLE_NUMBER_FAST", nameFlags);
MakeNameEx(0x000152C6, "SPARK_IO_KE_MIN_BURN_TIME", nameFlags);
MakeRptCmt(0x000152C6, "EST must remain low for at least this amount of time to complete a burn.\nMilliseconds");
MakeNameEx(0x000152C8, "SPARK_IO_KE_SENSOR_LAG", nameFlags);
MakeRptCmt(0x000152C8, "This is the angular lag of the ignition crank sensor data.\nDegrees");
MakeNameEx(0x000152CA, "SPARK_IO_KV_SENSOR_PROPAGATION_LAG", nameFlags);
MakeRptCmt(0x000152CA, "This is the angular lag due to the medium resolution signal processing.\nDegrees_vs_RPM_0to8000_Table");
MakeNameEx(0x000152F4, "STARTER_MOTOR_CONTROL_KE_EXTENDED_CRANK_FUEL_LEVEL", nameFlags);
MakeRptCmt(0x000152F4, "If the primary tank fuel level falls below this threshold, disable the extended crank function.\nLiters");
MakeNameEx(0x000152F6, "STARTER_MOTOR_CONTROL_KE_STARTER_ENABLE_TYPE", nameFlags);
MakeNameEx(0x000152F8, "STARTER_MOTOR_CONTROL_KE_LOW_VOLTAGE_CRANK_THRESH", nameFlags);
MakeRptCmt(0x000152F8, "If the ignition voltage falls below this value, allow the low voltage crank timer to accumulate.\nVolts");
MakeNameEx(0x000152FA, "STARTER_MOTOR_CONTROL_KE_LOW_VOLTAGE_CRANK_TIME", nameFlags);
MakeRptCmt(0x000152FA, "If the timer exceeds this value, set low voltage flag and disable the extended crank function.\nSeconds");
MakeNameEx(0x000152FC, "STARTER_MOTOR_CONTROL_KE_STARTER_ENABLE_SPEED", nameFlags);
MakeRptCmt(0x000152FC, "The engine speed below which the starter will be re-enabled.\nRPM");
MakeNameEx(0x000152FE, "STARTER_MOTOR_CONTROL_KE_STARTER_GEAR_MILL_PROT_TIME", nameFlags);
MakeRptCmt(0x000152FE, "Disable starter motor if Engine is not rotating within this time.\nSeconds");
MakeNameEx(0x00015300, "STARTER_MOTOR_CONTROL_KE_STARTER_INHIBIT_SPEED", nameFlags);
MakeRptCmt(0x00015300, "The engine speed above which the starter will be disabled, after KE_Starter_Inhibit_Delay seconds.\nRPM");
MakeNameEx(0x00015302, "STARTER_MOTOR_CONTROL_KE_STARTER_INHIBIT_DELAY", nameFlags);
MakeRptCmt(0x00015302, "The delay after which the starter will be disabled, when engine speed is above KE_Starter_Inhibit_Speed RPM.\nSeconds");
MakeNameEx(0x00015304, "STARTER_MOTOR_CONTROL_KE_STARTER_MAX_CRANK_TIME", nameFlags);
MakeRptCmt(0x00015304, "Maximum time starter is allowed to crank continuously.\nSeconds");
MakeNameEx(0x00015306, "STARTER_MOTOR_CONTROL_KE_CRANK_RELAY_PROTECT_TIME", nameFlags);
MakeRptCmt(0x00015306, "Minimum time a crank event must be maintained for protection of the starter relay contacts.\nSeconds");
MakeNameEx(0x00015308, "STARTER_MOTOR_CONTROL_KE_STARTER_ACTIVATION_DELAY", nameFlags);
MakeRptCmt(0x00015308, "Time delay after starter motor active transitions from FALSE to TRUE that the starter relay will be energized.\nSeconds");
MakeNameEx(0x0001530A, "STARTER_MOTOR_CONTROL_KV_STARTER_REF_PULSES", nameFlags);
MakeRptCmt(0x0001530A, "Number of consecutive low resolution reference pulses above KV_Starter_RPM_Thresh required to recognise engine as started.\nPulses");
MakeNameEx(0x0001532A, "STARTER_MOTOR_CONTROL_KV_STARTER_RPM_THRESH", nameFlags);
MakeRptCmt(0x0001532A, "Engine speed threshold for recognising engine as started.  See KV_Starter_Ref_Pulses for more information.\nRPM");
MakeNameEx(0x0001534A, "STARTER_MOTOR_CONTROL_KV_EXTENDED_CRANK_ENABLE_TIME", nameFlags);
MakeRptCmt(0x0001534A, "The crank request must be active for this time to enable the extended crank function.\nSeconds");
MakeNameEx(0x00015370, "STARTER_MOTOR_CONTROL_KV_EXTENDED_CRANK_TIME_MAX", nameFlags);
MakeRptCmt(0x00015370, "The maximum duration of an extended crank event.\nSeconds");
MakeNameEx(0x00015396, "THROTTLE_KE_INITIAL_TPS_OFFSET", nameFlags);
MakeRptCmt(0x00015396, "Initial estimate of the zero position TPS offset.\nAD_Counts");
MakeNameEx(0x00015398, "THROTTLE_KE_AIRFLOW_LEAK_AROUND_BLADE", nameFlags);
MakeRptCmt(0x00015398, "This defines the amount of airflow that flows around the throttle blade when the throttle and IAC are fully closed.\nGrams/Sec");
MakeNameEx(0x0001539A, "THROTTLE_KE_THROTTLE_POSITION_DEFAULT", nameFlags);
MakeRptCmt(0x0001539A, "Default throttle position used when throttle sensor fails.\nPercent");
MakeNameEx(0x0001539C, "THROTTLE_KE_TPS_SCALE_FACTOR", nameFlags);
MakeRptCmt(0x0001539C, "Throttle position sensor scaling factor.\n%/AD Cnts");
MakeNameEx(0x0001539E, "THROTTLE_KE_TPS_OFFSET_FILTER_COEF", nameFlags);
MakeRptCmt(0x0001539E, "First order filter coefficient used to reduce zero positon TPS offset.\nFilter_Coef");
MakeNameEx(0x000153A0, "THROTTLE_KE_THROTTLE_STOMP_LO_THRESHOLD", nameFlags);
MakeRptCmt(0x000153A0, "Minimum value through which the throttle/pedal position must travel in order to detect a throttle stomp.\nPercent Position");
MakeNameEx(0x000153A2, "THROTTLE_KE_THROTTLE_STOMP_HI_THRESHOLD", nameFlags);
MakeRptCmt(0x000153A2, "Maximum value through which the throttle/pedal position must travel in order to detect a throttle stomp.\nPercent Position");
MakeNameEx(0x000153A4, "THROTTLE_KE_THROTTLE_STOMPS_TO_ACTIVATE", nameFlags);
MakeRptCmt(0x000153A4, "Number of throttle stomps required to arm functions which are armed based on throttle stomps.\nCount");
MakeNameEx(0x000153A6, "THROTTLE_KE_THROTTLE_STOMP_DETECT_TIME", nameFlags);
MakeRptCmt(0x000153A6, "The elapsed time in which the number of throttle stomps, KE_Throttle_Stomps_To_Activate, must occur.\nSeconds");
MakeNameEx(0x000153A8, "THROTTLE_KE_CURRENT_POSITION_AT_ZERO", nameFlags);
MakeRptCmt(0x000153A8, "The consecutive time interval for a throttle position or pedal rotation of zero, to reinitialize the throttle stomp sequence.\nSeconds");
MakeNameEx(0x000153AA, "TRACTION_KE_USE_IAT_MIN", nameFlags);
MakeRptCmt(0x000153AA, "Use to determine which Induction Air Temperature to select.\nBoolean");
MakeNameEx(0x000153AC, "TRACTION_KA_SPARK_RETARD_FOR_TORQUE_LOSS", nameFlags);
MakeRptCmt(0x000153AC, "MBT spark retard as a function  of a given torque loss value\nDegrees");
MakeNameEx(0x000154F6, "TRACTION_KE_AWD_FRONT_SCALER", nameFlags);
MakeRptCmt(0x000154F6, "Fraction of torque that is transferred to front when AWD\nScaler 0-1");
MakeNameEx(0x000154F8, "TRACTION_KE_AWD_REAR_SCALER", nameFlags);
MakeRptCmt(0x000154F8, "Fraction of torque that is transferred to rear when AWD\nScaler 0-1");
MakeNameEx(0x000154FA, "TRACTION_KE_AXLE_ABUSE_LIMITING_ENABLE", nameFlags);
MakeRptCmt(0x000154FA, "Enabling cal for axle abuse torque limiting algorithm.\nTRUE/FALSE");
MakeNameEx(0x000154FC, "TRACTION_KE_DELTA_MANIFOLD_PRESSURE_100MS", nameFlags);
MakeRptCmt(0x000154FC, "Delta Manifold Pressure threshold over a 100ms time interval to enable transient torque overshoot spark control.\nkPa");
MakeNameEx(0x000154FE, "TRACTION_KE_ETC_MGT_DELTA_TORQUE_INITIAL", nameFlags);
MakeNameEx(0x00015500, "TRACTION_KE_ETC_MGT_DELTA_TORQUE_FINAL", nameFlags);
MakeRptCmt(0x00015500, "Maximum allowable delta torque value allowed, signifying the completion of the spark retard authority ramp out.\nFoot_Pounds_S");
MakeNameEx(0x00015502, "TRACTION_KE_ETC_MGT_SPARK_RETARD_DURATION", nameFlags);
MakeRptCmt(0x00015502, "Time period before ramp out of transient torque overshoot spark control begins.\nSeconds");
MakeNameEx(0x00015504, "TRACTION_KE_ETC_MGT_DELTA_TRQ_INCREMENT", nameFlags);
MakeRptCmt(0x00015504, "Rate at which transient torque overshoot spark control is ramped out.\nFoot_Pounds_S");
MakeNameEx(0x00015506, "TRACTION_KE_DESIRED_TORQUE_FAILURE_LIMIT", nameFlags);
MakeRptCmt(0x00015506, "Number of invalid desired torque reads out ofKE_Desired_Torque_Pass_Limit reads which will set a fault.\nCounts 0-255");
MakeNameEx(0x00015507, "TRACTION_KE_DESIRED_TORQUE_PASS_LIMIT", nameFlags);
MakeRptCmt(0x00015507, "Number of desired torque reads which will set a pass ifKE_Desired_Torque_Failure_Limit invalid reads have notbeen reached\nCounts 0-255");
MakeNameEx(0x00015508, "TRACTION_KE_ENABLE_ETC_AIRFLOW_AXLE_ABUSE", nameFlags);
MakeRptCmt(0x00015508, "Option selection to use ETC airflow in combination with spark for axle abuse.\nBoolean");
MakeNameEx(0x00015509, "TRACTION_KE_ENABLE_POWER_HOP_CONTROL", nameFlags);
MakeRptCmt(0x00015509, "Option selection to manage torque for Power Hop control using fuel and spark.\nBoolean");
MakeNameEx(0x0001550A, "TRACTION_KE_FAULTD_LCT_SPD_RATIO_FLT_COEF", nameFlags);
MakeNameEx(0x0001550C, "TRACTION_KE_LCT_SPD_RATIO_FLT_COEF", nameFlags);
MakeRptCmt(0x0001550C, "Lag filter coefficient used to filter Allison transmission torque converter speed ratio.\n0 to 1");
MakeNameEx(0x0001550E, "TRACTION_KE_LCT_DFCO_EXIT_DUTY_CYCLE_HI", nameFlags);
MakeRptCmt(0x0001550E, "Upper bound on requested torque duty cycle for Allison TCM DFCO exit request.\nPercent");
MakeNameEx(0x00015510, "TRACTION_KE_LCT_DFCO_EXIT_DUTY_CYCLE_LO", nameFlags);
MakeRptCmt(0x00015510, "Lower bound on requested torque duty cycle for Allison TCM DFCO exit request.\nPercent");
MakeNameEx(0x00015512, "TRACTION_KE_REQ_TRQ_FAIL_DUTY_CYCLE_HI", nameFlags);
MakeRptCmt(0x00015512, "Upper bound on duty cycle for the requested torque PWM line. Above this is a failure region.\nPercent");
MakeNameEx(0x00015514, "TRACTION_KE_REQ_TRQ_FAIL_DUTY_CYCLE_LO", nameFlags);
MakeRptCmt(0x00015514, "Lower bound on duty cycle for the requested torque PWM line. Below this is a failure region.\nPercent");
MakeNameEx(0x00015516, "TRACTION_KE_LCT_XMSN_PWM_ENABLE", nameFlags);
MakeRptCmt(0x00015516, "Option selection to use the TCS PWM input to control the LCTAllison transmission.\nBoolean");
MakeNameEx(0x00015518, "TRACTION_KV_CONVERTER_TORQUE_RATIO_LCT", nameFlags);
MakeRptCmt(0x00015518, "Ratio used to determine gearbox torque for LCT.\nRatio");
MakeNameEx(0x0001553A, "TRACTION_KE_DRAG_CONTROL_EQUIPPED", nameFlags);
MakeRptCmt(0x0001553A, "Allow selection of Drag Control\nBoolean");
MakeNameEx(0x0001553C, "TRACTION_KE_DELTA_THR_AREA_TRQ_MGT_ACTIVE", nameFlags);
MakeRptCmt(0x0001553C, "Threshold used to compare difference between Transmission Area and Desired Throttle Area to set ETC_Trq_Mgt_Active.\nPercent_S");
MakeNameEx(0x0001553E, "TRACTION_KE_TCS_PREVENT_DOWNSHIFT_OPTION", nameFlags);
MakeRptCmt(0x0001553E, "This is an option selection to prevent downshiftsduring traction control\nBoolean");
MakeNameEx(0x0001553F, "TRACTION_KE_TCS_FREEZE_GEAR_OPTION", nameFlags);
MakeNameEx(0x00015540, "TRACTION_KE_TCS_DOWNSHIFT_DELAY", nameFlags);
MakeRptCmt(0x00015540, "Amount of time to delay each downshift (except forthe first one) after exiting traction.\nSeconds");
MakeNameEx(0x00015542, "TRACTION_KE_TCS_DOWNSHIFT_PEDAL", nameFlags);
MakeRptCmt(0x00015542, "Downshift will not be delayed when exiting tractionif pedal is below this value.\nPercent");
MakeNameEx(0x00015544, "TRACTION_KE_TCS_DOWNSHIFT_PEDAL_DELTA", nameFlags);
MakeRptCmt(0x00015544, "Downshift will not be delayed when exiting tractionif pedal increases by this amount over 100mS.\nPercent");
MakeNameEx(0x00015546, "TRACTION_KE_TCS_NORMAL_REGION_DEADBAND", nameFlags);
MakeRptCmt(0x00015546, "The deadband on duty cycle for traction control normal range\nPercent");
MakeNameEx(0x00015548, "TRACTION_KE_TCS_PWM_DIAG_RUNTIME_DELAY", nameFlags);
MakeRptCmt(0x00015548, "Don't enable Desired Torque PWM AND MFD Delivered Torque PWM diagnostics until the engine has run this long.\nSeconds");
MakeNameEx(0x0001554A, "TRACTION_KE_TORQUE_ERROR_DEADBAND", nameFlags);
MakeRptCmt(0x0001554A, "Prevent proportional adjustments for small errors\nFoot_Pounds");
MakeNameEx(0x0001554C, "TRACTION_KE_PERCENT_TRQ_IND_DESIRED", nameFlags);
MakeRptCmt(0x0001554C, "Desired percentage of maximum available torque when utilizing the calibration development aid.\nPercent");
MakeNameEx(0x0001554E, "TRACTION_KE_PERCENT_TRQ_IND_ENABLE", nameFlags);
MakeRptCmt(0x0001554E, "Enabling bit to turn on or off the calibration development aid feature.\nBoolean");
MakeNameEx(0x00015550, "TRACTION_KE_PROP_ERROR_MAX_POSITIVE", nameFlags);
MakeRptCmt(0x00015550, "Limits the error to be used for the proportional term\nFoot_Pounds");
MakeNameEx(0x00015552, "TRACTION_KE_PROP_ERROR_MAX_NEGATIVE", nameFlags);
MakeRptCmt(0x00015552, "Limits the error to be used for the proportional term\nFoot_Pounds");
MakeNameEx(0x00015554, "TRACTION_KE_PROPORTIONAL_GAIN", nameFlags);
MakeRptCmt(0x00015554, "Proportional gain for torque errors for traction control\nMultiplier_0_to_1");
MakeNameEx(0x00015556, "TRACTION_KE_INTEGRAL_ERROR_MAX_POSITIVE", nameFlags);
MakeRptCmt(0x00015556, "Limits the error to be used for the integral term\nFoot_Pounds");
MakeNameEx(0x00015558, "TRACTION_KE_INTEGRAL_ERROR_MAX_NEGATIVE", nameFlags);
MakeRptCmt(0x00015558, "Limits the error to be used for the Integral term\nFoot_Pounds");
MakeNameEx(0x0001555A, "TRACTION_KE_INTEGRAL_GAIN", nameFlags);
MakeRptCmt(0x0001555A, "Integral gain for torque errors for traction/drag control\nMultiplier_0_to_1");
MakeNameEx(0x0001555C, "TRACTION_KE_INTEGRAL_POSITIVE_LIMIT", nameFlags);
MakeRptCmt(0x0001555C, "Limits magnitued of the integral term for positive torque errors\nFoot_Pounds");
MakeNameEx(0x0001555E, "TRACTION_KE_INTEGRAL_NEGATIVE_LIMIT", nameFlags);
MakeRptCmt(0x0001555E, "Limits magnitude of the integral term for negative torque errors\nFoot_Pounds");
MakeNameEx(0x00015560, "TRACTION_KE_TCS_INTEGRAL_DELAY", nameFlags);
MakeRptCmt(0x00015560, "Delay TCS integrator updates to account for system dynamics\nSeconds");
MakeNameEx(0x00015562, "TRACTION_KE_PI_FINAL_POSITIVE_LIMIT", nameFlags);
MakeRptCmt(0x00015562, "Limits the final TCS torque PI feedback term for positive errors\nFoot_Pounds");
MakeNameEx(0x00015564, "TRACTION_KE_PI_FINAL_NEGATIVE_LIMIT", nameFlags);
MakeRptCmt(0x00015564, "Limits the final TCS torque PI feedback term for negative errors\nFoot_Pounds");
MakeNameEx(0x00015566, "TRACTION_KE_TRACTION_DRAG_HYST_ZONE", nameFlags);
MakeRptCmt(0x00015566, "Hysteresis zone width between drag control and traction control.\nPercent");
MakeNameEx(0x00015568, "TRACTION_KE_TRACTION_TORQUE_AREA_HYST", nameFlags);
MakeRptCmt(0x00015568, "Hysteresis to avoid throttle vibration during traction control.\nPercent");
MakeNameEx(0x0001556A, "TRACTION_KE_TRACTION_TORQUE_AREA_RAMP", nameFlags);
MakeRptCmt(0x0001556A, "Ramp out rate for traction area when traction is no longer active or in the case of an input fault.\nPercent");
MakeNameEx(0x0001556C, "TRACTION_KE_TRACTION_DUTY_CYCLE_BOUND", nameFlags);
MakeRptCmt(0x0001556C, "lower bound on duty cycle for traction control range.\nPercent");
MakeNameEx(0x0001556E, "TRACTION_KE_TCS_INPUT_PERIOD_BAND", nameFlags);
MakeRptCmt(0x0001556E, "Tolerence band for traction control input period.\nMicroseconds");
MakeNameEx(0x00015572, "TRACTION_KE_FRICTION_TORQUE_BUFFER", nameFlags);
MakeRptCmt(0x00015572, "Amount of torque above engine friction torque used as the AllisonTrans_Low_Limit for engine torque LCT Desired.\nFoot_Pounds");
MakeNameEx(0x00015574, "TRACTION_KE_TORQUE_AREA_XMSN_EXIT_RAMP", nameFlags);
MakeNameEx(0x00015576, "TRACTION_KE_TRACTION_RETARD_RAMP", nameFlags);
MakeRptCmt(0x00015576, "Step reduction rate of ramp out of non-zero traction spark retard\nDegrees");
MakeNameEx(0x00015578, "TRACTION_KE_TRACTION_RETARD_MAX_TIME", nameFlags);
MakeRptCmt(0x00015578, "Maximum traction spare retard event duration time.\nSeconds");
MakeNameEx(0x0001557A, "TRACTION_KE_TRACTION_RETARD_MIN_TIME", nameFlags);
MakeRptCmt(0x0001557A, "Minimum traction spare retard event duration time.\nSeconds");
MakeNameEx(0x0001557C, "TRACTION_KE_4WDHI_FRONT_SCALER", nameFlags);
MakeRptCmt(0x0001557C, "Fraction of torque that is transferred to front when 4WD HI\nScaler 0-1");
MakeNameEx(0x0001557E, "TRACTION_KE_4WDHI_REAR_SCALER", nameFlags);
MakeRptCmt(0x0001557E, "Fraction of torque that is transferred to rear when 4WD HI\nScaler 0-1");
MakeNameEx(0x00015580, "TRACTION_KE_4WDLO_FRONT_SCALER", nameFlags);
MakeRptCmt(0x00015580, "Fraction of torque that is transferred to front when 4WD LO\nScaler 0-1");
MakeNameEx(0x00015582, "TRACTION_KE_4WDLO_REAR_SCALER", nameFlags);
MakeRptCmt(0x00015582, "Fraction of torque that is transferred to rear when 4WD LO\nScaler 0-1");
MakeNameEx(0x00015584, "TRACTION_KE_MANUAL_1ST_GEAR_MPH_HI", nameFlags);
MakeRptCmt(0x00015584, "Vehicle speed below which a manual trans. assumes 1st gear.\nMPH");
MakeNameEx(0x00015586, "TRACTION_KE_MANUAL_1ST_GEAR_MPH_LO", nameFlags);
MakeRptCmt(0x00015586, "Vehicle speed above which a manual trans. assumes 1st gear.\nMPH");
MakeNameEx(0x00015588, "TRACTION_KE_TRANSFER_CASE_EFFICIENCY", nameFlags);
MakeRptCmt(0x00015588, "Efficiency of transfer case for torque transfer\nMultiplier_0_to_1");
MakeNameEx(0x0001558A, "TRACTION_KE_ALLISON_FAULTED_GEAR_RATIO", nameFlags);
MakeNameEx(0x0001558C, "TRACTION_KE_AXLE_EFFICIENCY", nameFlags);
MakeRptCmt(0x0001558C, "Efficiency of axle for torque transfer\nMultiplier 0 to 1");
MakeNameEx(0x0001558E, "TRACTION_KE_TRANS_INPUT_LIMIT", nameFlags);
MakeRptCmt(0x0001558E, "Transmission input torque limit for protection from failure\nFoot Pounds");
MakeNameEx(0x00015592, "TRACTION_KE_TRANS_OUTPUT_LIMIT", nameFlags);
MakeRptCmt(0x00015592, "Transmission output torque limit for protection from failure\nFoot Pounds");
MakeNameEx(0x00015596, "TRACTION_KE_FRONT_AXLE_LIMIT", nameFlags);
MakeRptCmt(0x00015596, "Front axle torque limit for protection from failure\nFoot Pounds");
MakeNameEx(0x0001559A, "TRACTION_KE_FRONT_PROP_LIMIT", nameFlags);
MakeRptCmt(0x0001559A, "Front prop torque limit for protection from failure\nFoot Pounds");
MakeNameEx(0x0001559E, "TRACTION_KE_REAR_AXLE_LIMIT", nameFlags);
MakeRptCmt(0x0001559E, "Rear axle torque limit for protection from failure\nFoot Pounds");
MakeNameEx(0x000155A2, "TRACTION_KE_REAR_PROP_LIMIT", nameFlags);
MakeRptCmt(0x000155A2, "Rear prop torque limit for protection from failure\nFoot Pounds");
MakeNameEx(0x000155A6, "TRACTION_KE_1_2_RPM_LO_MU", nameFlags);
MakeNameEx(0x000155A8, "TRACTION_KE_1_2_RPM_HI_MU", nameFlags);
MakeNameEx(0x000155AA, "TRACTION_KE_2_3_RPM_LO_MU", nameFlags);
MakeNameEx(0x000155AC, "TRACTION_KE_2_3_RPM_HI_MU", nameFlags);
MakeNameEx(0x000155AE, "TRACTION_KE_3_4_RPM_LO_MU", nameFlags);
MakeNameEx(0x000155B0, "TRACTION_KE_3_4_RPM_HI_MU", nameFlags);
MakeNameEx(0x000155B2, "TRACTION_KE_1_2_WHEEL_SPD_LO_MU", nameFlags);
MakeNameEx(0x000155B4, "TRACTION_KE_1_2_WHEEL_SPD_HI_MU", nameFlags);
MakeNameEx(0x000155B6, "TRACTION_KE_2_3_WHEEL_SPD_LO_MU", nameFlags);
MakeNameEx(0x000155B8, "TRACTION_KE_2_3_WHEEL_SPD_HI_MU", nameFlags);
MakeNameEx(0x000155BA, "TRACTION_KE_3_4_WHEEL_SPD_LO_MU", nameFlags);
MakeNameEx(0x000155BC, "TRACTION_KE_3_4_WHEEL_SPD_HI_MU", nameFlags);
MakeNameEx(0x000155BE, "TRACTION_KE_DES_TRQ_LO_MU_1ST", nameFlags);
MakeRptCmt(0x000155BE, "Desired torque value below which the low friction surfacecalibrations will be used for traction control 1-2 shift.\nFt_Lb");
MakeNameEx(0x000155C0, "TRACTION_KE_DES_TRQ_LO_MU_2ND", nameFlags);
MakeRptCmt(0x000155C0, "Desired torque value below which the low friction surfacecalibrations will be used for traction control 2-3 shift.\nFt_Lb");
MakeNameEx(0x000155C2, "TRACTION_KE_DES_TRQ_LO_MU_3RD", nameFlags);
MakeRptCmt(0x000155C2, "Desired torque value below which the low friction surfacecalibrations will be used for traction control 3-4 shift.\nFt_Lb");
MakeNameEx(0x000155C4, "TRACTION_KE_1_2_DES_TRQ_MAX", nameFlags);
MakeRptCmt(0x000155C4, "Desired torque value above which a 1-2 traction shift will beprevented.\nFt_Lb");
MakeNameEx(0x000155C6, "TRACTION_KE_2_3_DES_TRQ_MAX", nameFlags);
MakeRptCmt(0x000155C6, "Desired torque value above which a 2-3 traction shift will beprevented.\nFt_Lb");
MakeNameEx(0x000155C8, "TRACTION_KE_3_4_DES_TRQ_MAX", nameFlags);
MakeRptCmt(0x000155C8, "Desired torque value above which a 3-4 traction shift will beprevented.\nFt_Lb");
MakeNameEx(0x000155CA, "TRACTION_KE_TCS_UPSHIFT_DELAY", nameFlags);
MakeRptCmt(0x000155CA, "Minimum amount of time between traction forced upshifts.\nSeconds");
MakeNameEx(0x000155CC, "TRACTION_KE_TCS_MAX_SHIFT_TIME", nameFlags);
MakeRptCmt(0x000155CC, "Maximum duration of a traction control shift.\nSeconds");
MakeNameEx(0x000155CE, "TRACTION_KE_TCC_CRUISE_DISENGAGE_TIME", nameFlags);
MakeRptCmt(0x000155CE, "Minimum length of a TCS or Drag event that will disengage TCC ANDcruise control.\nSeconds");
MakeNameEx(0x000155D0, "TRACTION_KE_TCC_REENABLE_TIME", nameFlags);
MakeRptCmt(0x000155D0, "Length of time after TCS or Drag event is completed that TCC willreturn to normal control.\nSeconds");
MakeNameEx(0x000155D2, "TRACTION_KE_BRAKE_TRAC_CC_DISENGAGE_TIME", nameFlags);
MakeRptCmt(0x000155D2, "Minimum length of a Brake Traction (Active Handling) event thatwill disengage Cruise control.\nSeconds");
MakeNameEx(0x000155D4, "TRACTION_KE_TORQUE_AREA_XMSN_RAMP_DOWN", nameFlags);
MakeRptCmt(0x000155D4, "Ramp down rate for torque throttle area when desired transmission torque is lower than the current engine torque.\nPercent");
MakeNameEx(0x000155D6, "TRACTION_KE_TORQUE_AREA_XMSN_RAMP_UP", nameFlags);
MakeRptCmt(0x000155D6, "Ramp up rate for torque throttle area when desired transmission torque is greater than the current engine torque.\nPercent");
MakeNameEx(0x000155D8, "TRACTION_KE_TIP_IN_TRQ_MAX", nameFlags);
MakeRptCmt(0x000155D8, "Maximum torque value that will allow tip in torque rate limiting.\nFoot_Pounds_S");
MakeNameEx(0x000155DA, "TRACTION_KE_TIP_IN_MPH_MIN", nameFlags);
MakeRptCmt(0x000155DA, "Minimum vehicle speed that will allow tip in torque rate limiting.\nMPH");
MakeNameEx(0x000155DC, "TRACTION_KE_TIP_OUT_MIN_ENGINE_SPEED", nameFlags);
MakeRptCmt(0x000155DC, "Minimum engine speed that will enable tip out torque rate limiting.\nRPM");
MakeNameEx(0x000155DE, "TRACTION_KE_TIP_OUT_TRQ_MANAGEMENT_ENABLE", nameFlags);
MakeRptCmt(0x000155DE, "Enabling cal for Tip out torque management algorithm.\nBOOLEAN");
MakeNameEx(0x000155E0, "TRACTION_KE_STALL_SPEED_DEFAULT", nameFlags);
MakeNameEx(0x000155E2, "TRACTION_KE_TRANSMISSION_EFFICIENCY", nameFlags);
MakeRptCmt(0x000155E2, "Efficiency of the transmission including torque converter for torque transfer.\nMultiplier_0_to_1");
MakeNameEx(0x000155E4, "TRACTION_KA_MAX_ENG_TRQ_IND_STOICH", nameFlags);
MakeRptCmt(0x000155E4, "Max torque available as a function of Engine Speed assuming an equivalence ratio of 1.0\nFoot_Pounds_S");
MakeNameEx(0x000156B6, "TRACTION_KV_TRQ_MGMT_GEAR_RATIO", nameFlags);
MakeRptCmt(0x000156B6, "Gear ratio for automatic transmission applications as a function of transmission gear.\nMultiplier_0_to_8");
MakeNameEx(0x000156CA, "TRACTION_KV_TIP_IN_DELTA_TRQ_LIMIT", nameFlags);
MakeRptCmt(0x000156CA, "Maximum allowable rate of torque increase when below a calibratedtorque level and above a calibrated vehicle speed.\nFoot_Pounds_S");
MakeNameEx(0x000156DE, "TRACTION_KV_TIP_OUT_RAMP_RATE", nameFlags);
MakeRptCmt(0x000156DE, "Maximum allowable rate of torque decrease when tip-out torque algorithm is active.\nFoot_Pounds_S");
MakeNameEx(0x000156F2, "TRACTION_KV_TCS_MIN_DESIRED_TORQUE", nameFlags);
MakeRptCmt(0x000156F2, "Limit desired torque request from EBCM as a function of RPM\nFt_Lb");
MakeNameEx(0x00015724, "TRACTION_KV_TCS_ENGINE_RUN_TIME_MIN", nameFlags);
MakeRptCmt(0x00015724, "The engine must run a minimum amount of time before permitting traction control function\nSeconds");
MakeNameEx(0x0001574A, "TRACTION_KV_TORQUE_BARO_ADJUST", nameFlags);
MakeRptCmt(0x0001574A, "Adjusts the desired TCS torque to compensate for ambient pressure\nScaler_2_Vs_kPa_Table");
MakeNameEx(0x00015754, "TRACTION_KV_TORQUE_IAT_ADJUST", nameFlags);
MakeRptCmt(0x00015754, "Adjusts desired TCS torque to compensate for Induction Air Temp\nScaler_2_Vs_Deg_C_Table");
MakeNameEx(0x00015774, "TRACTION_KA_PERCENT_THROTTLE_AREA", nameFlags);
MakeRptCmt(0x00015774, "Throttle area limit looked up based onPercent of max available torque and Engine Speed.\nPercent");
MakeNameEx(0x00015A3E, "TRACTION_KV_SPARK_RETARD_TCS", nameFlags);
MakeRptCmt(0x00015A3E, "Adjusts the desired TCS torque to compensate for ambient pressure\nDegrees_Vs_RPM_Table");
MakeNameEx(0x00015A66, "TRACTION_KV_SPARK_RETARD_TCS_AGGRESSIVE", nameFlags);
MakeRptCmt(0x00015A66, "Adjusts the desired TCS torque to compensate for ambientpressure, first retard cycle only.\nDegrees_Vs_RPM_Table");
MakeNameEx(0x00015A8E, "TRACTION_KA_ENG_TORQUE_ETC_DESIRED_XMSN", nameFlags);
MakeRptCmt(0x00015A8E, "Desired engine torque for transmission protection.\nFt_Lbs_S");
MakeNameEx(0x00015C32, "TRACTION_KA_ENG_TRQ_ETC_DES_XMSN_MULT", nameFlags);
MakeRptCmt(0x00015C32, "Desired engine torque multiplier.\nScaler 2");
MakeNameEx(0x00015DAE, "TRACTION_KA_TIP_OUT_INITIAL_TORQUE", nameFlags);
MakeRptCmt(0x00015DAE, "Starting torque level for tip out management algorithm.\nFt_Lbs_S");
MakeNameEx(0x00015F52, "TRACTION_KA_TIP_OUT_THROTTLE_AREA", nameFlags);
MakeRptCmt(0x00015F52, "Delivers the throttle area for the tip out torque managment algorithm desired engine torque.\nPercent_Vs_Ft_Lbs_And_RPM_Table");
MakeNameEx(0x000162D0, "ENGDIAGNOSTICS_HEADER", nameFlags);
MakeRptCmt(0x000162D0, "Use this cal to identify the engine diagnostic calibration\nCal_ID_Record");
MakeNameEx(0x000162EC, "OBD2_CONTROL_KE_MISFIRE_DIAG_RPM_LIMIT", nameFlags);
MakeRptCmt(0x000162EC, "Engine speed below which the misfire diagnostic data collection is enabled.\nRPM");
MakeNameEx(0x000162EE, "OBD2_CONTROL_KE_MISFIRE_DIAG_RPM_HYSTERESIS", nameFlags);
MakeRptCmt(0x000162EE, "This plus KE_Misfire_Diag_RPM_Limit is the engine speed above which the misfire diagnostic data collection is disabled.\nRPM");
MakeNameEx(0x000162F0, "OBD2_CONTROL_KV_DIAGNOSTIC_ENABLE", nameFlags);
MakeRptCmt(0x000162F0, "Boolean flags for enabling the OBD II diagnostics\nBOOLEAN");
MakeNameEx(0x00016344, "OBD2_CONTROL_KV_DIAGNOSTIC_DISABLE_FOR_PTO", nameFlags);
MakeRptCmt(0x00016344, "Boolean flags for disabling the OBD II diagnostics when PTO is enabled\nBOOLEAN");
MakeNameEx(0x00016398, "OBD2_CONTROL_KE_MIL_TIME", nameFlags);
MakeRptCmt(0x00016398, "Time that the MIL should be on or off during MIL flashing\nSeconds");
MakeNameEx(0x0001639A, "BRAKE_IO_KE_EXTENDED_TRAVEL_BRAKE_FAIL_CO", nameFlags);
MakeRptCmt(0x0001639A, "If the fail count exceeds this value,extended travel brake diagnostic fails.\nCounts");
MakeNameEx(0x0001639B, "BRAKE_IO_KE_EXTENDED_TRAVEL_BRAKE_SAMPLE_", nameFlags);
MakeRptCmt(0x0001639B, "If the sample count exceeds this value,extended travel brake diagnostic is passed.\nCounts");
MakeNameEx(0x0001639C, "BRAKE_IO_KE_BRAKE_ETM_FAIL_COUNT", nameFlags);
MakeRptCmt(0x0001639C, "If the fail count exceeds this value, ETM brake diagnostic fails.\nCounts");
MakeNameEx(0x0001639D, "BRAKE_IO_KE_BRAKE_ETM_SAMPLE_COUNT", nameFlags);
MakeRptCmt(0x0001639D, "If the sample count exceeds this value, ETM brake diagnostic is passed.\nCounts");
MakeNameEx(0x0001639E, "BRAKE_IO_KE_BRAKE_CRZ_FAIL_COUNT", nameFlags);
MakeRptCmt(0x0001639E, "If the fail count exceeds this value, TCC brake diagnostic fails.\nCounts");
MakeNameEx(0x0001639F, "BRAKE_IO_KE_BRAKE_CRZ_SAMPLE_COUNT", nameFlags);
MakeRptCmt(0x0001639F, "If the sample count exceeds this value, TCC brake diagnostic is passed.\nCounts");
MakeNameEx(0x000163A0, "BRAKE_IO_KE_BRAKE_DIAG_SPEED_DELTA", nameFlags);
MakeRptCmt(0x000163A0, "Check brake inputs if vehicle speed is decelerating more than this value over a 250 msec. period.\nMPH");
MakeNameEx(0x000163A2, "BRAKE_IO_KE_BRAKE_TEST_ENGINE_SPEED", nameFlags);
MakeRptCmt(0x000163A2, "Engine speed above which for a continuous time period, the brake monitoring is allowed to begin.\nRPM");
MakeNameEx(0x000163A4, "BRAKE_IO_KE_BRAKE_TEST_RUN_TIME", nameFlags);
MakeRptCmt(0x000163A4, "Time with engine speed KE_Brake_Test_Engine_Speed to allow brake switch monitoring to begin.\nSeconds");
MakeNameEx(0x000163A6, "BRAKE_IO_KE_BRAKE_ENABLE_WHEEL_SPD", nameFlags);
MakeRptCmt(0x000163A6, "Wheel speed at or above which the brake switch monitoring cycle begins.\nMPH");
MakeNameEx(0x000163A8, "BRAKE_IO_KE_BRAKE_DISABLE_WHEEL_SPD", nameFlags);
MakeRptCmt(0x000163A8, "Wheel speed at or below which the brake switch monitoring cycle ends.\nMPH");
MakeNameEx(0x000163AA, "C2_J1979_MSGS_KE_OBD_01_20_TEST_SUPPORT", nameFlags);
MakeRptCmt(0x000163AA, "Bit encoded calibration which indicates which mode 6 tests are supported.\nBOOLEAN");
MakeNameEx(0x000163AE, "C2_J1979_MSGS_KE_MODE_06_COMP_ID_SUPPORTED_1", nameFlags);
MakeRptCmt(0x000163AE, "Bit encoded calibration which indicates support or non-support for a particular mode 6 comp ID.\nBOOLEAN");
MakeNameEx(0x000163AF, "C2_J1979_MSGS_KE_MODE_06_COMP_ID_SUPPORTED_2", nameFlags);
MakeRptCmt(0x000163AF, "Bit encoded calibration which indicates support or non-support for a particular mode 6 comp ID.\nBOOLEAN");
MakeNameEx(0x000163B0, "C2_J1979_MSGS_KE_MODE_06_COMP_ID_SUPPORTED_3", nameFlags);
MakeRptCmt(0x000163B0, "Bit encoded calibration which indicates support or non-support for a particular mode 6 comp ID.\nBOOLEAN");
MakeNameEx(0x000163B1, "C2_J1979_MSGS_KE_MODE_06_COMP_ID_SUPPORTED_4", nameFlags);
MakeRptCmt(0x000163B1, "Bit encoded calibration which indicates support or non-support for a particular mode 6 comp ID.\nBOOLEAN");
MakeNameEx(0x000163B2, "C2_J1979_MSGS_KE_MODE_06_COMP_ID_SUPPORTED_5", nameFlags);
MakeRptCmt(0x000163B2, "Bit encoded calibration which indicates support or non-support for a particular mode 6 comp ID.\nBOOLEAN");
MakeNameEx(0x000163B3, "C2_J1979_MSGS_KE_MODE_06_COMP_ID_SUPPORTED_6", nameFlags);
MakeRptCmt(0x000163B3, "Bit encoded calibration which indicates support or non-support for a particular mode 6 comp ID.\nBOOLEAN");
MakeNameEx(0x000163B4, "C2_J1979_MSGS_KE_MODE_8_01_20_TEST_SUPPORT", nameFlags);
MakeRptCmt(0x000163B4, "Bit encoded calibration which indicates which mode 8 tests in this range are supported.\nBOOLEAN");
MakeNameEx(0x000163B8, "C2_J1979_MSGS_KE_MODE9_01_08_SUPPORT", nameFlags);
MakeRptCmt(0x000163B8, "Bit encoded calibration which indicates support or non-support for a particular mode 9 info type.\nBOOLEAN");
MakeNameEx(0x000163B9, "INSTRUMENTATION_KE_ENABLE_MALF_DISPLAY", nameFlags);
MakeRptCmt(0x000163B9, "Enables the storing of data used to display malf codes.\nBOOLEAN");
MakeNameEx(0x000163BA, "C2_M5_DEFINITION_KE_LOCATIONS_WITH_O2_SENSORS", nameFlags);
MakeRptCmt(0x000163BA, "Bit encoded calibration which indicates which O2 Sensors are supported.\nBOOLEAN");
MakeNameEx(0x000163BC, "C2_M5_DEFINITION_KE_MODE_5_01_20_TEST_SUPPORT", nameFlags);
MakeRptCmt(0x000163BC, "Bit encoded calibration which indicates which mode 5 tests are supported.\nBOOLEAN");
MakeNameEx(0x000163DC, "C2_M5_DEFINITION_KE_MODE_5_21_40_TEST_SUPPORT", nameFlags);
MakeRptCmt(0x000163DC, "Bit encoded calibration which indicates which mode 5 tests are supported.\nBOOLEAN");
MakeNameEx(0x000163FC, "C2_M5_DEFINITION_KE_MODE_5_41_60_TEST_SUPPORT", nameFlags);
MakeRptCmt(0x000163FC, "Bit encoded calibration which indicates which mode 5 tests are supported.\nBOOLEAN");
MakeNameEx(0x0001641C, "C2_M5_DEFINITION_KE_MODE_5_61_80_TEST_SUPPORT", nameFlags);
MakeRptCmt(0x0001641C, "Bit encoded calibration which indicates which mode 5 tests are supported.\nBOOLEAN");
MakeNameEx(0x0001643C, "C2_M5_DEFINITION_KE_MODE_5_81_A0_TEST_SUPPORT", nameFlags);
MakeRptCmt(0x0001643C, "Bit encoded calibration which indicates which mode 5 tests are supported.\nBOOLEAN");
MakeNameEx(0x0001645C, "C2_M5_DEFINITION_KE_MODE_5_A1_C0_TEST_SUPPORT", nameFlags);
MakeRptCmt(0x0001645C, "Bit encoded calibration which indicates which mode 5 tests are supported.\nBOOLEAN");
MakeNameEx(0x0001647C, "C2_M5_DEFINITION_KE_MODE_5_C1_E0_TEST_SUPPORT", nameFlags);
MakeRptCmt(0x0001647C, "Bit encoded calibration which indicates which mode 5 tests are supported.\nBOOLEAN");
MakeNameEx(0x0001649C, "C2_M5_DEFINITION_KE_MODE_5_E1_FF_TEST_SUPPORT", nameFlags);
MakeRptCmt(0x0001649C, "Bit encoded calibration which indicates which mode 5 tests are supported.\nBOOLEAN");
MakeNameEx(0x000164BC, "C2_PIDS_KE_MODE_1_PID_01_08_SUPPORT", nameFlags);
MakeRptCmt(0x000164BC, "This calibration indicates support or non-support  of a PID by the PCM.\nPID_Support_Type");
MakeNameEx(0x000164BD, "C2_PIDS_KE_MODE_1_PID_09_10_SUPPORT", nameFlags);
MakeRptCmt(0x000164BD, "This calibration indicates support or non-support  of a PID by the PCM.\nPID_Support_Type");
MakeNameEx(0x000164BE, "C2_PIDS_KE_MODE_1_PID_11_18_SUPPORT", nameFlags);
MakeRptCmt(0x000164BE, "This calibration indicates support or non-support  of a PID by the PCM.\nPID_Support_Type");
MakeNameEx(0x000164BF, "C2_PIDS_KE_MODE_1_PID_19_20_SUPPORT", nameFlags);
MakeRptCmt(0x000164BF, "This calibration indicates support or non-support  of a PID by the PCM.\nPID_Support_Type");
MakeNameEx(0x000164C0, "C2_PIDS_KE_MODE_1_PID_21_28_SUPPORT", nameFlags);
MakeRptCmt(0x000164C0, "This calibration indicates support or non-support  of a PID by the PCM.\nPID_Support_Type");
MakeNameEx(0x000164C1, "C2_PIDS_KE_MODE_1_PID_29_30_SUPPORT", nameFlags);
MakeRptCmt(0x000164C1, "This calibration indicates support or non-support  of a PID by the PCM.\nPID_Support_Type");
MakeNameEx(0x000164C2, "C2_PIDS_KE_MODE_1_PID_31_38_SUPPORT", nameFlags);
MakeRptCmt(0x000164C2, "This calibration indicates support or non-support  of a PID by the PCM.\nPID_Support_Type");
MakeNameEx(0x000164C3, "C2_PIDS_KE_MODE_1_PID_39_40_SUPPORT", nameFlags);
MakeRptCmt(0x000164C3, "This calibration indicates support or non-support  of a PID by the PCM.\nPID_Support_Type");
MakeNameEx(0x000164C4, "C2_PIDS_KE_MODE_2_PID_01_08_SUPPORT", nameFlags);
MakeRptCmt(0x000164C4, "This calibration indicates support or non-support  of a PID by the PCM.\nPID_Support_Type");
MakeNameEx(0x000164C5, "C2_PIDS_KE_MODE_2_PID_09_10_SUPPORT", nameFlags);
MakeRptCmt(0x000164C5, "This calibration indicates support or non-support  of a PID by the PCM.\nPID_Support_Type");
MakeNameEx(0x000164C6, "C2_PIDS_KE_MODE_2_PID_11_18_SUPPORT", nameFlags);
MakeRptCmt(0x000164C6, "This calibration indicates support or non-support  of a PID by the PCM.\nPID_Support_Type");
MakeNameEx(0x000164C7, "C2_PIDS_KE_MODE_2_PID_19_20_SUPPORT", nameFlags);
MakeRptCmt(0x000164C7, "This calibration indicates support or non-support  of a PID by the PCM.\nPID_Support_Type");
MakeNameEx(0x000164C8, "C2_PIDS_KE_PEAK_AIRFLOW_SEALEVEL", nameFlags);
MakeRptCmt(0x000164C8, "This calibration indicates the mass air flow corrected corrected to sealevel.\nGrams_per_Second");
MakeNameEx(0x000164CA, "C2_PIDS_KE_SEALEVEL_BAROMETER", nameFlags);
MakeRptCmt(0x000164CA, "It indicates the barometric pressure corrected corrected to sealevel.\nkPa");
MakeNameEx(0x000164CC, "C2_PIDS_KE_OBD2_SYSTEM_TYPE", nameFlags);
MakeRptCmt(0x000164CC, "This Calibration indicates which on_board diagnostic system is used.\nSHORTCARD");
MakeNameEx(0x000164CE, "COOLANT_KE_INITIAL_COOLANT_DEFAULT", nameFlags);
MakeRptCmt(0x000164CE, "Initial coolant default, used if IAT failed on powerup.\nDegrees C");
MakeNameEx(0x000164D0, "COOLANT_KE_WARM_ENGINE_DEFAULT_COOLANT_M", nameFlags);
MakeRptCmt(0x000164D0, "Maximum value allowed for default coolant temperature.\nDegrees C");
MakeNameEx(0x000164D2, "COOLANT_KV_DEFAULT_COOLANT", nameFlags);
MakeRptCmt(0x000164D2, "This is added to what the ambient air temperature was at powerup to determine what the default coolant temperature should be.\nDegrees C");
MakeNameEx(0x00016510, "CYLINDER_NUMBER_KV_CYLINDER_AT_CAM", nameFlags);
MakeRptCmt(0x00016510, "The cylinder number present when CAM has just transitionedto the indicated state.\nCam_Transition");
MakeNameEx(0x00016512, "CYLINDER_NUMBER_KV_SYNC_REFERENCES", nameFlags);
MakeRptCmt(0x00016512, "Number of low-resolution reference pulses that must occur before a change in cam signal is assumed.\nSHORTCARD");
MakeNameEx(0x00016526, "DG_AC_KE_AC_CLUTCH_HIGH_FAIL_THRESHOLD", nameFlags);
MakeRptCmt(0x00016526, "The number of failures required to set P1539\nCounts");
MakeNameEx(0x00016527, "DG_AC_KE_AC_CLUTCH_HIGH_PASS_THRESHOLD", nameFlags);
MakeRptCmt(0x00016527, "The number of passes required to pass P1539\nCounts");
MakeNameEx(0x00016528, "DG_AC_KE_AC_CLUTCH_LOW_FAIL_THRESHOLD", nameFlags);
MakeRptCmt(0x00016528, "The number of failures required to set P1546\nCounts");
MakeNameEx(0x00016529, "DG_AC_KE_AC_CLUTCH_LOW_PASS_THRESHOLD", nameFlags);
MakeRptCmt(0x00016529, "The number of passes required to pass P1546\nCounts");
MakeNameEx(0x0001652A, "DG_AC_KE_AC_PRESSURE_IN_FLT_TMR", nameFlags);
MakeRptCmt(0x0001652A, "The time that a failure must exsist to cause a fault to be displayed for AC pressure.\nSeconds");
MakeNameEx(0x0001652C, "DG_AC_KE_P0531_AC_PRESSURE_DELTA", nameFlags);
MakeRptCmt(0x0001652C, "The amount of PSI rise after AC compressor engagement, at all ambient temperatures, that indicates the sensor is not stuck.\nPSI");
MakeNameEx(0x0001652E, "DG_AC_KE_P0531_STARTUP_AC_PRESS_DELTA", nameFlags);
MakeNameEx(0x00016530, "DG_AC_KE_P0531_AC_PRESS_ENABLE_TEST", nameFlags);
MakeRptCmt(0x00016530, "When AC pressure is greater than this or when KE_P0531_IAT_Enable_Test is met, allow P0531 test to run.\nPSI");
MakeNameEx(0x00016532, "DG_AC_KE_P0531_IAT_ENABLE_TEST", nameFlags);
MakeRptCmt(0x00016532, "When IAT is greater than this or when KE_P0531_AC_Press_Enable_Test is met, allow P0531 test to run\nDegrees_C");
MakeNameEx(0x00016534, "DG_AC_KE_P0531_AC_HOLD_OFF_IAT", nameFlags);
MakeRptCmt(0x00016534, "Hold AC compressor off for KE_P0531_AC_Off_Time when compressor turns off when IAT less than this.\nDegrees_C");
MakeNameEx(0x00016536, "DG_AC_KE_P0531_AC_ON_TIME", nameFlags);
MakeRptCmt(0x00016536, "The amount of time allowed for the AC pressure to rise the required delta before failing the P0531 diagnostic.\nSeconds");
MakeNameEx(0x00016538, "DG_AC_KE_P0531_AC_OFF_TIME", nameFlags);
MakeRptCmt(0x00016538, "The delay time after the clutch is turned off before the diagnostic is enabled. This allows the pressure to decay.\nSeconds");
MakeNameEx(0x0001653A, "DG_AC_KV_AC_PRES_AD_CNT", nameFlags);
MakeRptCmt(0x0001653A, "When AC pressure is outside the window, then it is considered invalid.\nCounts");
MakeNameEx(0x0001653C, "DG_AIR_KE_AIRD_ENGINE_RUN_TIME_MIN", nameFlags);
MakeRptCmt(0x0001653C, "The minimum engine run time required to start the AIR diagnostic\nSeconds");
MakeNameEx(0x0001653E, "DG_AIR_KE_AIRD_ACTIVE_CONTROL_WAIT_TIME", nameFlags);
MakeRptCmt(0x0001653E, "Minimum length of time before stopping the air induction request.\nSeconds");
MakeNameEx(0x0001653F, "DG_AIR_KE_AIRD_ACTIVE_ENABLE_TIME_MIN", nameFlags);
MakeRptCmt(0x0001653F, "Minimum length of time the enable conditions for the active test shall be met.\nSeconds");
MakeNameEx(0x00016540, "DG_AIR_KE_AIRD_ACTIVE_ENG_AIRFLOW_MAX", nameFlags);
MakeRptCmt(0x00016540, "The maximum amount of engine airflow allowed during the active test.\nGrams");
MakeNameEx(0x00016542, "DG_AIR_KE_AIRD_ACTIVE_ENGINE_LOAD_MAX", nameFlags);
MakeRptCmt(0x00016542, "The maximum engine load allowed during the active test.\nPercent");
MakeNameEx(0x00016544, "DG_AIR_KE_AIRD_ACTIVE_ENGINE_SPEED_MIN", nameFlags);
MakeRptCmt(0x00016544, "The minimum engine speed required to run the active test.\nSpeed");
MakeNameEx(0x00016546, "DG_AIR_KE_AIRD_ACTIVE_LEAN_VOLT_MAX", nameFlags);
MakeRptCmt(0x00016546, "Maximum O2 sensor voltage to update the lean timer during the active test.\nMillivolts");
MakeNameEx(0x00016548, "DG_AIR_KE_AIRD_ACTIVE_TEST_TIME_LIMIT", nameFlags);
MakeRptCmt(0x00016548, "Maximum amount of time allowed in the active test.\nSeconds");
MakeNameEx(0x0001654A, "DG_AIR_KE_AIRD_ACTIVE_VEH_SPEED_MIN", nameFlags);
MakeRptCmt(0x0001654A, "The minimum vehicle speed required to run the active test.\nMiles per Hour");
MakeNameEx(0x0001654C, "DG_AIR_KE_AIRD_ENGINE_VACUUM_MIN", nameFlags);
MakeRptCmt(0x0001654C, "The minimum engine vacuum threshold to enable the passive and active tests.\nKilopascals");
MakeNameEx(0x0001654E, "DG_AIR_KE_AIRD_PASV_AIRFUEL_RATIO_MIN", nameFlags);
MakeRptCmt(0x0001654E, "The commanded engine air/fuel control ratio shall be above this value for the passive test to run.\nRatio");
MakeNameEx(0x00016550, "DG_AIR_KE_AIRD_PASV_COLD_START_TEMP_LIM", nameFlags);
MakeRptCmt(0x00016550, "Determines the powerup coolant temperature below which the passive test will be considered a cold start passive test.\nDegrees");
MakeNameEx(0x00016552, "DG_AIR_KE_AIRD_PASV_ENG_AIRFLOW_MAX", nameFlags);
MakeRptCmt(0x00016552, "Maximum engine airflow allowed during the passive test.\nGrams");
MakeNameEx(0x00016554, "DG_AIR_KE_AIRD_PASV_EXH_BACKPRES_MAX", nameFlags);
MakeRptCmt(0x00016554, "Maximum engine load allowed during the passive test.\nPercent");
MakeNameEx(0x00016556, "DG_AIR_KE_AIRD_PASV_PART2_RICH_SAMP_MIN", nameFlags);
MakeRptCmt(0x00016556, "Minimum number of rich samples required to pass part 2 of the passive test.\nCount");
MakeNameEx(0x00016558, "DG_AIR_KE_AIRD_PASV_PART2_RICH_VOLT_MIN", nameFlags);
MakeRptCmt(0x00016558, "Minimum O2 sensor voltage during part 2 of the passive test to consider the O2 sensor sample rich.\nMillivolts");
MakeNameEx(0x0001655A, "DG_AIR_KE_AIRD_PASV_PART2_TIME_MIN", nameFlags);
MakeRptCmt(0x0001655A, "Minimum amount of time required for passive test part 2 to complete.\nSeconds");
MakeNameEx(0x0001655C, "DG_AIR_KE_AIRD_PASV_TEMP_THRESHOLD", nameFlags);
MakeRptCmt(0x0001655C, "Threshold to determine whether to use the cold or hot passive test logic.\nDegrees");
MakeNameEx(0x0001655E, "DG_AIR_KE_AIRD_PASV_TPS_DELTA_MAX", nameFlags);
MakeRptCmt(0x0001655E, "The maximum change in TPS values over 100ms interval allowed during the passive test.\nPercent");
MakeNameEx(0x00016560, "DG_AIR_KE_AIRD_PRETEST_DELAY_TIME", nameFlags);
MakeRptCmt(0x00016560, "Amount of time necessary to complete the pretest delay.\nSeconds");
MakeNameEx(0x00016561, "DG_AIR_KE_AIRD_PRETEST_FUEL_TRIM_MAX", nameFlags);
MakeRptCmt(0x00016561, "The short term fuel trim variable shall be below this value to start the active test.\nValue");
MakeNameEx(0x00016562, "DG_AIR_KE_AIRD_PRETEST_FUEL_TRIM_MIN", nameFlags);
MakeRptCmt(0x00016562, "The short term fuel trim variable shall be above this value to start the active test.\nUnitless");
MakeNameEx(0x00016564, "DG_CAM_KV_CAM_INITIAL_FIRST_CYCLE", nameFlags);
MakeNameEx(0x000165F4, "DG_CAM_KV_CAM_INITIAL_SECOND_CYCLE", nameFlags);
MakeNameEx(0x00016684, "DG_CAM_KE_CAM_X_SHORTED_HIGH_CRANK", nameFlags);
MakeRptCmt(0x00016684, "Limit of allowable high transitions when a hightransition should not have occured during crank state.\nNONE 0-255");
MakeNameEx(0x00016686, "DG_CAM_KE_CAM_X_SHORTED_HIGH_RUN", nameFlags);
MakeRptCmt(0x00016686, "Limit of allowable high transitions when a hightransition should not have occured during engine run.\nNONE 0-255");
MakeNameEx(0x00016688, "DG_CAM_KE_CAM_X_SHORTED_LOW_CRANK", nameFlags);
MakeRptCmt(0x00016688, "Limit of allowable low transitions when a lowtransition should not have occured during crank state.\nNONE 0-255");
MakeNameEx(0x0001668A, "DG_CAM_KE_CAM_X_SHORTED_LOW_RUN", nameFlags);
MakeRptCmt(0x0001668A, "Limit of allowable low transitions when a lowtransition should not have occured during engine run.\nNONE 0-255");
MakeNameEx(0x0001668C, "DG_CAM_KE_CAM_X_PERFORMANCE_CRANK", nameFlags);
MakeRptCmt(0x0001668C, "Limit of number of too many transitions occuringwhen only one transition should have occured duringcrank state.\nNONE 0-255");
MakeNameEx(0x0001668E, "DG_CAM_KE_CAM_X_PERFORMANCE_RUN", nameFlags);
MakeRptCmt(0x0001668E, "Limit of number of too many transitions occuringwhen only one transition should have occured.\nNONE 0-255");
MakeNameEx(0x00016690, "DG_CAM_KE_CAM_X_SAMPLES_CRANK", nameFlags);
MakeRptCmt(0x00016690, "Limit of number of samples for cranking.\nNONE 0-255");
MakeNameEx(0x00016692, "DG_CAM_KE_CAM_X_SAMPLES_RUN", nameFlags);
MakeRptCmt(0x00016692, "Limit of number of samples for engine run.\nNONE 0-255");
MakeNameEx(0x00016694, "DG_CAM_KE_CAM_MISSING_SAMPLES", nameFlags);
MakeRptCmt(0x00016694, "This many seconds of CAM transitions must be seen before reporting a Pass for the missing CAM signal diagnostic. Gen 1E only.\nSamples");
MakeNameEx(0x00016695, "DG_CAM_KE_CAM_MISSING_FAIL_LIMIT", nameFlags);
MakeRptCmt(0x00016695, "If no CAM transitions are detected for this many seconds, report a Fail for the missing CAM signal diagnostic. Gen 1E only.\nCounts");
MakeNameEx(0x00016696, "DG_CAM_KE_CAM_SYNC_FAILURE_LIMIT", nameFlags);
MakeRptCmt(0x00016696, "The number of failed tests within a sample size that will report a failure for the cam sync test. Gen 1E only.\nFailures");
MakeNameEx(0x00016698, "DG_CAM_KE_CAM_SYNC_SAMPLE_LIMIT", nameFlags);
MakeRptCmt(0x00016698, "The number of tests that make up a sample size for the cam sync test. Gen 1E only.\nSamples");
MakeNameEx(0x0001669A, "DG_CAM_KE_CAM_MAX_TEST_COUNTER", nameFlags);
MakeRptCmt(0x0001669A, "The number of times (engine cycles) to run the position test after the engine running flag is active. Gen 1E only.\nCounts");
MakeNameEx(0x0001669B, "DG_CAM_KE_CAM_POSITION_MAX_DIAG_COUNT", nameFlags);
MakeRptCmt(0x0001669B, "The number of continuous position errors to qualify as a fault. Gen 1E only.\nCounts");
MakeNameEx(0x0001669C, "DG_CAM_KE_CAM_POSITION_ERROR_MAX", nameFlags);
MakeRptCmt(0x0001669C, "Lower boundry multiplier for crank-cam pulse timing window. Gen 1E only.\n0_to_4");
MakeNameEx(0x0001669E, "DG_CAM_KE_CAM_POSITION_ERROR_MIN", nameFlags);
MakeRptCmt(0x0001669E, "Upper boundry multiplier for crank-cam pulse timing window. Gen 1E only.\n0_to_4");
MakeNameEx(0x000166A0, "DG_CASE_KE_CASE_COLLECT_CAM_DATA", nameFlags);
MakeNameEx(0x000166A2, "DG_CASE_KE_CASE_FACTOR_MAX", nameFlags);
MakeRptCmt(0x000166A2, "Defines the threshold above which a cylinder compensation factor is considered to be too large.\nunitless");
MakeNameEx(0x000166A4, "DG_CASE_KE_CASE_FACTOR_MIN", nameFlags);
MakeRptCmt(0x000166A4, "Defines the threshold below which a cylinder compensation factor is considered out of range.\nunitless");
MakeNameEx(0x000166A6, "DG_CASE_KE_CASE_FACTOR_SUM_MAX", nameFlags);
MakeRptCmt(0x000166A6, "Defines the threshold beyond which the sum of the opposing cylinder pair compensation factors is considered to be out of range.\nunitless");
MakeNameEx(0x000166AA, "DG_CASE_KE_CASE_FACTOR_SUM_MIN", nameFlags);
MakeRptCmt(0x000166AA, "Defines the threshold below which the sum of the opposing cylinder pair compensation factors is considered to be out of range.\nunitless");
MakeNameEx(0x000166AE, "DG_CASE_KE_CASE_FAIL_TIMER_MAX", nameFlags);
MakeRptCmt(0x000166AE, "Defines the diagnostic failure threshold according to the activation rate specified herein for the owner process.\nseconds");
MakeNameEx(0x000166AF, "DG_CASE_KE_CASE_OPP_CYL_DIFF_MAX", nameFlags);
MakeRptCmt(0x000166AF, "Defines the threshold above which the opposing cylinder factors are considered to be too far apart.\nunitless");
MakeNameEx(0x000166B0, "DG_CASE_KE_DSBL_MFR_ENBL_CTR_FOR_CASE", nameFlags);
MakeNameEx(0x000166B2, "DG_CRANK_KE_LOSS_OF_MATCH_FAIL_LIMIT", nameFlags);
MakeRptCmt(0x000166B2, "Number of Loss of Match events required to report a Crank Sync Lost failure.\nMatch Loss");
MakeNameEx(0x000166B4, "DG_CRANK_KE_LOW_RES_REF_LOM_THRESHOLD", nameFlags);
MakeRptCmt(0x000166B4, "Number of low res ref pulses that must occur before Loss Of Match density is evaluated.\nLo-Res Ref");
MakeNameEx(0x000166B6, "DG_CRANK_KE_CRANK_SYNC_LOST_RATIO_LIMIT", nameFlags);
MakeRptCmt(0x000166B6, "Loss Of Match density (ratio of Loss OF Match events to low res ref pulses) that will report a Crank Sync Lost failure.\nNONE 0-1");
MakeNameEx(0x000166B8, "DG_CRANK_KE_CRANK_SYNC_TEST_SAMPLE_LIMIT", nameFlags);
MakeRptCmt(0x000166B8, "Number of crank synch not achieved samples required to report test passed.\nSamples");
MakeNameEx(0x000166B9, "DG_CRANK_KE_CRANK_SYNC_TEST_FAIL_LIMIT", nameFlags);
MakeRptCmt(0x000166B9, "Number of crank synch not achieved failures within a sample sample size required to report a crank synch not achieved failure.\nFailures");
MakeNameEx(0x000166BA, "DG_CRANK_KE_MATCH_HAS_OCCURRED_THRESHOLD", nameFlags);
MakeRptCmt(0x000166BA, "This many matches in a single sample register as one crank synch not achieved failure.\nmatches");
MakeNameEx(0x000166BC, "DG_CRANK_KE_MIN_CRANKING_MASS_AIRFLOW", nameFlags);
MakeRptCmt(0x000166BC, "Level of airflow when engine is cranking.\ngm/S");
MakeNameEx(0x000166BE, "DG_CRANK_KE_START_CRANK_SAMPLE_SIZE", nameFlags);
MakeNameEx(0x000166BF, "DG_CRANK_KE_START_CRANK_FAILURE_LIMIT", nameFlags);
MakeNameEx(0x000166C0, "DG_CRANK_KE_ACCELERATION_LIMIT_VALUE", nameFlags);
MakeRptCmt(0x000166C0, "RPM changes greater than this value over a 12.5ms interval must be faulty. Gen 1E only.\nRPM");
MakeNameEx(0x000166C2, "DG_CRANK_KE_MIN_RUNNING_MASS_AIRFLOW", nameFlags);
MakeRptCmt(0x000166C2, "Minimum airflow that indicates the engine is rotating and should be running. Gen 1E only.\nGrams_Per_Second");
MakeNameEx(0x000166C4, "DG_CRANK_KE_CRANK_INTERMITTENT_FAIL_LIMIT", nameFlags);
MakeRptCmt(0x000166C4, "Number of failed crank sensor tests for high acceleration out of a sample size that will report a failure. Gen 1E only.\nFailures");
MakeNameEx(0x000166C6, "DG_CRANK_KE_LONG_INTERMITTENT_FAIL_LIMIT", nameFlags);
MakeNameEx(0x000166C8, "DG_CRANK_KE_CRANK_INTERMITTENT_SAMPLES_LI", nameFlags);
MakeRptCmt(0x000166C8, "Number of samples that make up a sample size for the crank sensor test. Gen 1E only.\nSamples");
MakeNameEx(0x000166CA, "DG_CRANK_KE_MIN_CAM_EDGES_AFTER_CRK_LOSS", nameFlags);
MakeRptCmt(0x000166CA, "If the crank sensor fails on a running engine, atleast this many cam edges must occur before setting a code. Gen IE only.\nCounts");
MakeNameEx(0x000166CC, "DG_ECTR_KE_ECTR_ENGINE_AIRFLOW_MAX", nameFlags);
MakeRptCmt(0x000166CC, "Limit the value of engine airflow at this maximum.\nGmsPerSec");
MakeNameEx(0x000166CE, "DG_ECTR_KE_ECTR_ENGINE_AIRFLOW_MIN", nameFlags);
MakeRptCmt(0x000166CE, "Airflow is set to zero, so that no airflow is accumulated below the mimimum.\nGmsPerSec");
MakeNameEx(0x000166D0, "DG_ECTR_KE_ECTR_MAX_AMBIENT_TEMP", nameFlags);
MakeRptCmt(0x000166D0, "The maximum value that can be assigned to OBD_Intake_Air_ Temperature to represent ambient temperature.\nDegrees_C");
MakeNameEx(0x000166D2, "DG_ECTR_KE_ECTR_MAX_ENGINE_RUN_TIME", nameFlags);
MakeRptCmt(0x000166D2, "Maximum engine run time that will enable the test.\nSeconds");
MakeNameEx(0x000166D4, "DG_ECTR_KE_ECTR_MIN_ENGINE_RUN_TIME", nameFlags);
MakeRptCmt(0x000166D4, "Minimum engine run time that will enable the test.\nSeconds");
MakeNameEx(0x000166D6, "DG_ECTR_KE_ECTR_MIN_REQUIRED_IAT", nameFlags);
MakeRptCmt(0x000166D6, "Minimum intake air temperature value to enable the rationality test(s).\nDegrees_C");
MakeNameEx(0x000166D8, "DG_ECTR_KE_ECTR_MIN_VEHICLE_SPEED", nameFlags);
MakeRptCmt(0x000166D8, "Minimum vehicle speed value to update the distance measurement.\nMPH");
MakeNameEx(0x000166DA, "DG_ECTR_KE_ECTR_MAX_ETH_PERCENT", nameFlags);
MakeRptCmt(0x000166DA, "The maximum fuel ethanol composition allowed to enable the test.\nPercent");
MakeNameEx(0x000166DC, "DG_ECTR_KE_ECTR_TEST_FAIL_LIM", nameFlags);
MakeRptCmt(0x000166DC, "Number of consecutive failures without a pass to report a failed rationality test.\nFailures");
MakeNameEx(0x000166DE, "DG_ECTS_KE_ECTS_ENG_RUN_TIME_HIGH_MIN", nameFlags);
MakeRptCmt(0x000166DE, "Minimum engine run time threshold to record a short to high fault.\nSeconds");
MakeNameEx(0x000166DF, "DG_ECTS_KE_ECTS_ENG_RUN_TIME_LOW_MIN", nameFlags);
MakeRptCmt(0x000166DF, "Minimum engine run time threshold to record a short to low fault.\nSeconds");
MakeNameEx(0x000166E0, "DG_ECTS_KE_ECTS_INT_SHORT_HIGH_FAIL_LIM", nameFlags);
MakeRptCmt(0x000166E0, "Number of failed intermittent short to high tests that will report an intermittent failure.\nFailures");
MakeNameEx(0x000166E2, "DG_ECTS_KE_ECTS_INT_SHORT_HIGH_SMPL_LIM", nameFlags);
MakeRptCmt(0x000166E2, "Number of intermittent short high tests that make up a sample size.\nSamples");
MakeNameEx(0x000166E4, "DG_ECTS_KE_ECTS_INT_SHORT_LOW_FAIL_LIM", nameFlags);
MakeRptCmt(0x000166E4, "Number of failed intermittent short to low tests that will report an intermittent failure.\nFailures");
MakeNameEx(0x000166E6, "DG_ECTS_KE_ECTS_INT_SHORT_LOW_SMPL_LIM", nameFlags);
MakeRptCmt(0x000166E6, "Number of intermittent short low tests that make up a sample size.\nSamples");
MakeNameEx(0x000166E8, "DG_ECTS_KE_ECTS_SHORT_HIGH_FAIL_LIM", nameFlags);
MakeRptCmt(0x000166E8, "Number of failed short to high tests that will report a failure.\nFailures");
MakeNameEx(0x000166EA, "DG_ECTS_KE_ECTS_SHORT_HIGH_SMPL_LIM", nameFlags);
MakeRptCmt(0x000166EA, "Number of short high tests that make up a sample size.\nSamples");
MakeNameEx(0x000166EC, "DG_ECTS_KE_ECTS_SHORT_LOW_FAIL_LIM", nameFlags);
MakeRptCmt(0x000166EC, "Number of failed short to low tests that will report a failure.\nFailures");
MakeNameEx(0x000166EE, "DG_ECTS_KE_ECTS_SHORT_LOW_SMPL_LIM", nameFlags);
MakeRptCmt(0x000166EE, "Number of short low tests that make up a sample size.\nSamples");
MakeNameEx(0x000166F0, "DG_ECTS_KE_ECTS_SHORTED_HIGH_IAT_MIN", nameFlags);
MakeRptCmt(0x000166F0, "Minimum IAT to enable an ECT shorted high failure prior to achieving sufficient engine run time.\nDegrees C");
MakeNameEx(0x000166F2, "DG_ECTS_KE_ECTS_SHORTED_LOW_IAT_MAX", nameFlags);
MakeRptCmt(0x000166F2, "Maximum IAT to enable an ECT shorted low failure prior to achieving sufficient engine run time.\nDegrees C");
MakeNameEx(0x000166F4, "DG_ECTS_KV_ECTS_SHORTED_HIGH_THRESH", nameFlags);
MakeRptCmt(0x000166F4, "The threshold above which the coolant sensor is considered shorted to a positive voltage.\nPercent");
MakeNameEx(0x000166F8, "DG_ECTS_KV_ECTS_SHORTED_LOW_THRESH", nameFlags);
MakeRptCmt(0x000166F8, "The threshold below which the coolant sensor is considered opened or shorted to ground.\nPercent");
MakeNameEx(0x000166FC, "DG_EGRQ_KV_EGRF_ACHIEVED_POS_COMP", nameFlags);
MakeRptCmt(0x000166FC, "Compensation factor to reduce the delta MAP for high achieved positions.\nUnitless");
MakeNameEx(0x00016716, "DG_EGRQ_KV_EGRF_EWMA_COMPENSATION", nameFlags);
MakeRptCmt(0x00016716, "Compensation factor to reduce the delta MAP for various restriction amounts.\nUnitless");
MakeNameEx(0x00016720, "DG_EGRQ_KV_EGRF_ON_TIME_COMPENSATION", nameFlags);
MakeRptCmt(0x00016720, "Compensation factor to reduce the delta MAP for long on-times.\nUnitless");
MakeNameEx(0x00016732, "DG_EGRQ_KE_EGRF_ABORT_INTERVAL", nameFlags);
MakeRptCmt(0x00016732, "Interval between test control assertions when the previous test was aborted during the intrusive period.\nSeconds");
MakeNameEx(0x00016734, "DG_EGRQ_KE_EGRF_AIRFLOW_DIFFERENCE", nameFlags);
MakeRptCmt(0x00016734, "Maximum allowable difference between commanded and actual airflow during the TEST_STARTED mode.\nGrams/Sec");
MakeNameEx(0x00016736, "DG_EGRQ_KE_EGRF_ALTITUDE_COMP_MAP_HIGH", nameFlags);
MakeRptCmt(0x00016736, "Upper limit of range above which flow test is not run.\nkPa");
MakeNameEx(0x00016738, "DG_EGRQ_KE_EGRF_ALTITUDE_COMP_MAP_LOW", nameFlags);
MakeRptCmt(0x00016738, "Lower limit of range below which flow test is not run.\nkPa");
MakeNameEx(0x0001673A, "DG_EGRQ_KE_EGRF_BARO_MINIMUM", nameFlags);
MakeRptCmt(0x0001673A, "Minimum barometric pressure below which test may is not run.\nkPa");
MakeNameEx(0x0001673C, "DG_EGRQ_KE_EGRF_BASE_ON_TIME_COUNTER", nameFlags);
MakeRptCmt(0x0001673C, "Initial number of execution loops that the valve will be commanded open, after a powerup or a non-volatile init.\nCounts");
MakeNameEx(0x0001673D, "DG_EGRQ_KE_EGRF_CODE_CLEAR_ON_TIME_CTR", nameFlags);
MakeRptCmt(0x0001673D, "Initial number of execution loops that the valve will be commanded open, after an ALDL code clear.\nCounts");
MakeNameEx(0x0001673E, "DG_EGRQ_KE_EGRF_COMPLETE_INTERVAL", nameFlags);
MakeRptCmt(0x0001673E, "Interval between test control assertions, when the previous test was completed.\nSeconds");
MakeNameEx(0x00016740, "DG_EGRQ_KE_EGRF_DFCO_ENABLE", nameFlags);
MakeRptCmt(0x00016740, "Condition for enabling flow mode test based on decel fuel cut off state.\nEnum");
MakeNameEx(0x00016742, "DG_EGRQ_KE_EGRF_EWMA_FAIL_THRESHOLD", nameFlags);
MakeRptCmt(0x00016742, "Threshold above which the diagnostic is considered failing,if the diagnostic is currently indicating a failure.\nkPa");
MakeNameEx(0x00016744, "DG_EGRQ_KE_EGRF_EWMA_FAIL_COEF", nameFlags);
MakeRptCmt(0x00016744, "Filter coefficient for EWMA calculation when test is indicating a failure.\nCoef");
MakeNameEx(0x00016746, "DG_EGRQ_KE_EGRF_EWMA_NONFAIL_THRESH", nameFlags);
MakeRptCmt(0x00016746, "Threshold above which the diagnostic is considered  failing if the diagnostic is currently not indicating a failure.\nkPa");
MakeNameEx(0x00016748, "DG_EGRQ_KE_EGRF_EWMA_NONFAIL_COEF", nameFlags);
MakeRptCmt(0x00016748, "Filter coefficient for EWMA calculation when test is not indicating a failure.\nCoef");
MakeNameEx(0x0001674A, "DG_EGRQ_KE_EGRF_EWMA_PASS_SAMPLES", nameFlags);
MakeRptCmt(0x0001674A, "Number of test samples required before the diagnostic can be considered passing.\nCounts");
MakeNameEx(0x0001674C, "DG_EGRQ_KE_EGRF_MAX_DELTA_MAP", nameFlags);
MakeRptCmt(0x0001674C, "Maximum range that MAP can fluctuate during test start period.\nkPa");
MakeNameEx(0x0001674E, "DG_EGRQ_KE_EGRF_MAX_DELTA_MPH", nameFlags);
MakeRptCmt(0x0001674E, "Max range that vehicle speed can fluctuate during the intrusive portions of the test\nMPH");
MakeNameEx(0x00016750, "DG_EGRQ_KE_EGRF_MAX_NEG_RPM_CHANGE", nameFlags);
MakeRptCmt(0x00016750, "Max negative change in engine speed allowed during the intrusive portions of the test.\nRPM");
MakeNameEx(0x00016752, "DG_EGRQ_KE_EGRF_MAX_ON_TIME_COUNTER", nameFlags);
MakeRptCmt(0x00016752, "Maximum number of execution loops the valve will be commanded open.\nCounts");
MakeNameEx(0x00016754, "DG_EGRQ_KE_EGRF_MAX_POS_RPM_CHANGE", nameFlags);
MakeRptCmt(0x00016754, "Max positive change in engine speed allowed during the intrusive portions of the test\nRPM");
MakeNameEx(0x00016756, "DG_EGRQ_KE_EGRF_MAXIMUM_RPM", nameFlags);
MakeRptCmt(0x00016756, "High limit of engine speed range to enable the flow test.\nRPM");
MakeNameEx(0x00016758, "DG_EGRQ_KE_EGRF_MAXIMUM_TPS", nameFlags);
MakeRptCmt(0x00016758, "TPS must be below this value to enable the flow test.\nPercent");
MakeNameEx(0x0001675A, "DG_EGRQ_KE_EGRF_MINIMUM_RPM", nameFlags);
MakeRptCmt(0x0001675A, "Low limit of engine speed range to enable the flow test.\nRPM");
MakeNameEx(0x0001675C, "DG_EGRQ_KE_EGRF_MIN_ON_TIME_COUNTER", nameFlags);
MakeRptCmt(0x0001675C, "Minimum number of execution loops that the valve will be commanded open,\nCounts");
MakeNameEx(0x0001675D, "DG_EGRQ_KE_EGRF_OVER_UNDER_COUNT", nameFlags);
MakeRptCmt(0x0001675D, "Number of consecutive overshoot or undershoot events necessary to modify the duty cycle on-time.\nCounts");
MakeNameEx(0x0001675E, "DG_EGRQ_KE_EGRF_OVERSHOOT_POSITION", nameFlags);
MakeRptCmt(0x0001675E, "Position above which the test will decrement the duty cycle on-time.\nPercent");
MakeNameEx(0x00016760, "DG_EGRQ_KE_EGRF_RPM_COMPENSATION", nameFlags);
MakeRptCmt(0x00016760, "Used to choose desired RPM compensation method. START_RPM = Starting RPM, MINIMUM_RPM = Minimum RPM during test\nENUM");
MakeNameEx(0x00016761, "DG_EGRQ_KE_EGRF_SAMPLE_TIME", nameFlags);
MakeRptCmt(0x00016761, "Amount of time the test is in the SAMPLE_CALCULATION mode.\nSeconds");
MakeNameEx(0x00016762, "DG_EGRQ_KE_EGRF_SAMPLES_AFTER_RESET", nameFlags);
MakeNameEx(0x00016763, "DG_EGRQ_KE_EGRF_SAMPLES_AFTER_STEP", nameFlags);
MakeNameEx(0x00016764, "DG_EGRQ_KE_EGRF_SAMPLES_PER_TRIP", nameFlags);
MakeRptCmt(0x00016764, "Maximum number of samples per trip.\nCounts");
MakeNameEx(0x00016766, "DG_EGRQ_KE_EGRF_START_MAX_POSITION", nameFlags);
MakeRptCmt(0x00016766, "Maximum EGR starting position below which the valve is considered closed.\nPercent");
MakeNameEx(0x00016768, "DG_EGRQ_KE_EGRF_STEP_DELTA", nameFlags);
MakeRptCmt(0x00016768, "Minimum difference between MAPDIFF and EWMA to trigger multiple tests for step change\nkPa");
MakeNameEx(0x0001676A, "DG_EGRQ_KE_EGRF_STEP_MAPDIFF", nameFlags);
MakeRptCmt(0x0001676A, "Minimum value of MAPDIFF to trigger multiple tests for step change\nkPa");
MakeNameEx(0x0001676C, "DG_EGRQ_KE_EGRF_STEP_SAMPLES_PER_TRIP", nameFlags);
MakeRptCmt(0x0001676C, "Maximum number of samples per trip after a step change.\nCounts");
MakeNameEx(0x0001676E, "DG_EGRQ_KE_EGRF_TEST_ENABLE_DELAY", nameFlags);
MakeRptCmt(0x0001676E, "Length of time the throttle must be virtually closed before a flow test is allowed.\nSeconds");
MakeNameEx(0x00016770, "DG_EGRQ_KE_EGRF_UNDERSHOOT_POSITION", nameFlags);
MakeRptCmt(0x00016770, "Position below which the test will increment the duty cycle on-time.\nPercent");
MakeNameEx(0x00016772, "DG_ESC_KE_ESC_NOISE_RPM_HIGH", nameFlags);
MakeRptCmt(0x00016772, "One condition to run the diagnostic is that engine speed be less than this cal.\nRPM");
MakeNameEx(0x00016774, "DG_ESC_KE_ESC_CIRCUIT_ENG_RUN_TIME", nameFlags);
MakeRptCmt(0x00016774, "If the engine run time is less than this value, then the test is to be bypassed.\nSeconds");
MakeNameEx(0x00016776, "DG_ESC_KE_ESC_CIRCUIT_FAIL_SAMPLES", nameFlags);
MakeRptCmt(0x00016776, "Number of fail samples needed to report a fail in a sample period less than KE_ESC_Samples total.\nCounts");
MakeNameEx(0x00016777, "DG_ESC_KE_ESC_CIRCUIT_SAMPLES", nameFlags);
MakeRptCmt(0x00016777, "Number of samples needed before a pass can be reported.\nCounts");
MakeNameEx(0x00016778, "DG_ESC_KE_ESC_COOLANT_TEMP_MIN", nameFlags);
MakeRptCmt(0x00016778, "Minimum coolant temperature required to learn minimum noise.\nDegrees C");
MakeNameEx(0x0001677A, "DG_ESC_KE_ESC_FILTER_COEFF", nameFlags);
MakeRptCmt(0x0001677A, "Lag filter coefficient used in filtering the ESC noise channel.\nScaler_0_to_1");
MakeNameEx(0x0001677C, "DG_ESC_KE_ESC_INITIAL_NOISE", nameFlags);
MakeRptCmt(0x0001677C, "An initial startup value for filter purposes.\nA/D Counts");
MakeNameEx(0x0001677E, "DG_ESC_KE_ESC_NOISE_ENGINE_RUN_TIME", nameFlags);
MakeRptCmt(0x0001677E, "Minimum engine run time before test can be enabled.\nSeconds");
MakeNameEx(0x00016780, "DG_ESC_KE_ESC_NOISE_LOW_COUNT", nameFlags);
MakeRptCmt(0x00016780, "Number of successive low noise level conditions necessary to report a fail condition.\nCounts");
MakeNameEx(0x00016781, "DG_ESC_KE_ESC_NOISE_LOW_LEVEL", nameFlags);
MakeRptCmt(0x00016781, "Low noise level threshold which must be exceeded a calibratable number of times to report a fail.\nA/D Counts");
MakeNameEx(0x00016782, "DG_ESC_KE_ESC_NOISE_LOW_SAMPLE_COUNT", nameFlags);
MakeRptCmt(0x00016782, "Number of samples before a low noise pass can be reported.\nCounts");
MakeNameEx(0x00016783, "DG_ESC_KE_ESC_NOISE_HIGH_COUNT", nameFlags);
MakeRptCmt(0x00016783, "Number of high noise level conditions per sample size necessary to report a fail condition.\nCounts");
MakeNameEx(0x00016784, "DG_ESC_KE_ESC_NOISE_HIGH_LEVEL", nameFlags);
MakeRptCmt(0x00016784, "High noise level threshold which must be exceeded a calibratable number of times to report a failure.\nA/D Counts");
MakeNameEx(0x00016785, "DG_ESC_KE_ESC_NOISE_HIGH_SAMPLE_COUNT", nameFlags);
MakeRptCmt(0x00016785, "Number of passes needed before a high noise pass can be reported.\nCounts");
MakeNameEx(0x00016786, "DG_ESC_KE_ESC_NOISE_RPM_LOW", nameFlags);
MakeRptCmt(0x00016786, "One condition to run the diagnostic is that engine speed be greater than this cal.\nRPM");
MakeNameEx(0x00016788, "DG_ESC_KE_ESC_NOISE_TPS_MIN", nameFlags);
MakeRptCmt(0x00016788, "One condition to run the diagnostic is that Throttle position be greater than this cal.\nPercent");
MakeNameEx(0x0001678A, "DG_ESC_KE_ESC_RPM_MAX", nameFlags);
MakeRptCmt(0x0001678A, "Maximum engine speed to enable minimum noise learning.\nRPM");
MakeNameEx(0x0001678C, "DG_ESC_KE_ESC_RPM_MIN", nameFlags);
MakeRptCmt(0x0001678C, "Minimum engine speed to enable minimum noise learning.\nRPM");
MakeNameEx(0x0001678E, "DG_ESC_KE_ESC_RUN_TIME_MIN", nameFlags);
MakeRptCmt(0x0001678E, "Minimum engine run time to enable minimum noise learning.\nSeconds");
MakeNameEx(0x00016790, "DG_ESC_KE_ESC_SENSOR_INITIAL_NOISE", nameFlags);
MakeNameEx(0x00016792, "DG_ESC_KE_ESC_SYSTEM_VOLTAGE_MIN", nameFlags);
MakeRptCmt(0x00016792, "Minimum system voltage required to enable the circuit test.\nVolts");
MakeNameEx(0x00016794, "DG_ESC_KE_IR_INSTANT_MAX", nameFlags);
MakeRptCmt(0x00016794, "Any IR instant knock exceeding this threshold is considered too long.\nA/D Counts");
MakeNameEx(0x00016795, "DG_ESC_KE_IR_KNOCK_MAX", nameFlags);
MakeRptCmt(0x00016795, "Number of fail samples needed to report a fail in a sample period less than KE_IR_Test_Max.\nCounts");
MakeNameEx(0x00016796, "DG_ESC_KE_IR_TEST_MAX", nameFlags);
MakeRptCmt(0x00016796, "Number of samples needed before the IR counters will be reset for the next test cycle.\nCounts");
MakeNameEx(0x00016798, "DI_FAN_KE_FAND_DELTA_FAN_SPEED_COEF", nameFlags);
MakeRptCmt(0x00016798, "The filter coefficient for the delta fan speed variable used by the system performance test.\n0-1");
MakeNameEx(0x0001679A, "DI_FAN_KE_FAND_IAT_MIN", nameFlags);
MakeRptCmt(0x0001679A, "The minimum allowable intake air temperature to enable the tests.\nDegrees C");
MakeNameEx(0x0001679C, "DI_FAN_KE_FAND_PUMP_OUT_RPM_MIN", nameFlags);
MakeRptCmt(0x0001679C, "The minimum RPM required to pump oil out of the working chamber.\nRPM");
MakeNameEx(0x0001679E, "DI_FAN_KE_FAND_PUMP_OUT_TIME", nameFlags);
MakeRptCmt(0x0001679E, "Length of time above which the fan clutch oil should have completed being pumped out.\nSeconds");
MakeNameEx(0x000167A0, "DI_FAN_KE_FAND_SYS_VOLTAGE_MIN", nameFlags);
MakeRptCmt(0x000167A0, "The minimum allowable system voltage to enable the tests.\nVolts");
MakeNameEx(0x000167A2, "DG_FAN_KE_FAND_DELTA_FAN_SPEED_LIM", nameFlags);
MakeRptCmt(0x000167A2, "Maximum error allowed before incrementing the fail counter.\nRPM");
MakeNameEx(0x000167A4, "DG_FAN_KE_FAND_ENGINE_SPEED_DELTA_MAX", nameFlags);
MakeRptCmt(0x000167A4, "Maximum allowable change in the engine speed to enable the performance test.\nRPM");
MakeNameEx(0x000167A6, "DG_FAN_KE_FAND_FAN_SPEED_MAX", nameFlags);
MakeRptCmt(0x000167A6, "Threshold of fan speed above which is considered high.\nRPM");
MakeNameEx(0x000167A8, "DG_FAN_KE_FAND_OVERSPEED_FAIL_LIM", nameFlags);
MakeRptCmt(0x000167A8, "Number of fails counts required to fail the overspeed test.\nUnitless");
MakeNameEx(0x000167AA, "DG_FAN_KE_FAND_OVERSPEED_SMPL_LIM", nameFlags);
MakeRptCmt(0x000167AA, "Number of samples required to pass the overspeed test.\nUnitless");
MakeNameEx(0x000167AC, "DG_FAN_KE_FAND_OVERSPEED_THRESHOLD", nameFlags);
MakeRptCmt(0x000167AC, "Threshold of fan speed above which is unsafe.\nHertz");
MakeNameEx(0x000167AE, "DG_FAN_KE_FAND_SENSOR_FAIL_LIM", nameFlags);
MakeRptCmt(0x000167AE, "Number of fails counts required to fail the fan speed sensor circuit test.\nUnitless");
MakeNameEx(0x000167B0, "DG_FAN_KE_FAND_SENSOR_FREQ_MIN", nameFlags);
MakeRptCmt(0x000167B0, "Minimum fan speed frequency below which the speed input is considered missing.\nHertz");
MakeNameEx(0x000167B2, "DG_FAN_KE_FAND_SENSOR_SMPL_LIM", nameFlags);
MakeRptCmt(0x000167B2, "Number of samples required to pass the fan speed sensor circuit test.\nUnitless");
MakeNameEx(0x000167B4, "DG_FAN_KE_FAND_SPEEDHI_FAIL_LIM", nameFlags);
MakeRptCmt(0x000167B4, "Number of fail counts required to fail the test.\nUnitless");
MakeNameEx(0x000167B6, "DG_FAN_KE_FAND_SPEEDHI_RPM_MAX", nameFlags);
MakeRptCmt(0x000167B6, "Maximum engine speed that will allow evaluation of the fan speed.\nRPM");
MakeNameEx(0x000167B8, "DG_FAN_KE_FAND_SPEEDHI_RPM_MIN", nameFlags);
MakeRptCmt(0x000167B8, "Minimum engine speed that will allow evaluation of  the fan speed.\nRPM");
MakeNameEx(0x000167BA, "DG_FAN_KE_FAND_SPEEDHI_SMPL_LIM", nameFlags);
MakeRptCmt(0x000167BA, "Number of samples required to pass the fan speed too high test.\nUnitless");
MakeNameEx(0x000167BC, "DG_FAN_KE_FAND_STABLE_SPEED_TIME", nameFlags);
MakeRptCmt(0x000167BC, "Amount of time that the speed command must remain stable to perform the system performance test.\nSeconds");
MakeNameEx(0x000167BE, "DG_FAN_KE_FAND_SYSPERF_FAIL_LIM", nameFlags);
MakeRptCmt(0x000167BE, "Number of fails counts required to fail the system performance test.\nUnitless");
MakeNameEx(0x000167C0, "DG_FAN_KE_FAND_SYSPERF_RPM_MAX", nameFlags);
MakeRptCmt(0x000167C0, "Maximum allowable engine speed to enable the system  performance test.\nRPM");
MakeNameEx(0x000167C2, "DG_FAN_KE_FAND_SYS_SMPL_LIM", nameFlags);
MakeRptCmt(0x000167C2, "Number of samples required to pass the system performance test.\nUnitless");
MakeNameEx(0x000167C4, "DG_FASD_KEFADD_B_FASD_DIAGNOSTICENABLED", nameFlags);
MakeRptCmt(0x000167C4, "Global Diagnostic Enabling flag.\nBOOLEAN");
MakeNameEx(0x000167C6, "DG_FASD_KEFADD_CNT_FASD_ABORTTIMEMAX", nameFlags);
MakeRptCmt(0x000167C6, "Maximum number of samples between intrusive test segments when an abort of a test segment occurs.\nUnitless");
MakeNameEx(0x000167C8, "DG_FASD_KEFADD_CNT_FASD_ACCUMLEARNMIN", nameFlags);
MakeRptCmt(0x000167C8, "Min data count of accumulator learning before first report is allowed to prevent premature first report.\nUnitless");
MakeNameEx(0x000167CA, "DG_FASD_KEFADD_CNT_FASD_MAXPURGECOUNT", nameFlags);
MakeNameEx(0x000167CC, "DG_FASD_KEFADD_CNT_FASD_MAXSEGMENTFAILS", nameFlags);
MakeRptCmt(0x000167CC, "An intrusive test failure is reported if the number of failing segments reaches this threshold.\nUnitless");
MakeNameEx(0x000167CD, "DG_FASD_KEFADD_CNT_FASD_MAXTESTSEGMENTS", nameFlags);
MakeRptCmt(0x000167CD, "The intrusive test is stopped if this number of segments occurs without a passing or failing result.\nUnitless");
MakeNameEx(0x000167CE, "DG_FASD_KEFADD_CNT_FASD_READYTOREPORTMIN", nameFlags);
MakeRptCmt(0x000167CE, "The number of continuously accumulated sample counts required before allowing a report to the data manager.\nUnitless");
MakeNameEx(0x000167CF, "DG_FASD_KEFADD_CNT_FASD_STABLESMPLCNTMIN", nameFlags);
MakeRptCmt(0x000167CF, "This number of samples are not counted when a cell change occurs during the intrusive test segment.\nUnitless");
MakeNameEx(0x000167D0, "DG_FASD_KEFADD_CNT_FASD_STALEACCUMMAX", nameFlags);
MakeNameEx(0x000167D2, "DG_FASD_KEFADD_CNT_FASD_WAITTIMEMAX", nameFlags);
MakeRptCmt(0x000167D2, "Maximum number of samples between intrusive test segments when a normal completion of a test segment occurs.\nUnitless");
MakeNameEx(0x000167D4, "DG_FASD_KEFADD_CNT_MAXINTRUSVATTEMPT", nameFlags);
MakeRptCmt(0x000167D4, "Data will be discarded if the the purge valve is open above this threshold and the vent valve is closed.\nUnitless");
MakeNameEx(0x000167D5, "DG_FASD_KEFADD_CNT_MAXSEGMENTPASSES", nameFlags);
MakeNameEx(0x000167D6, "DG_FASD_KEFADD_CNT_OVERALLSAMPLESMIN", nameFlags);
MakeRptCmt(0x000167D6, "The number of samples required (after the minimum cell learning) before a passive result can be used.\nUnitless");
MakeNameEx(0x000167D8, "DG_FASD_KEFADD_CNT_SEGMENTSMPLCNTMIN", nameFlags);
MakeRptCmt(0x000167D8, "This number of accumulated samples is required before the intrusive segment is considered complete.\nUnitless");
MakeNameEx(0x000167DA, "DG_FASD_KEFADD_CNT_STABILITYSAMPLMIN", nameFlags);
MakeRptCmt(0x000167DA, "Calibration used to record the number of samples since the fuel trim cell number has changed.\nUnitless");
MakeNameEx(0x000167DC, "DG_FASD_KEFADD_CNT_STALEACCUMINITMAX", nameFlags);
MakeNameEx(0x000167DE, "DG_FASD_KEFADD_CNT_STALENONPGINITMAX", nameFlags);
MakeNameEx(0x000167E0, "DG_FASD_KEFADD_CNT_STALENONPURGEDEC", nameFlags);
MakeRptCmt(0x000167E0, "Amount the non-purge accumulator stale data counter is decremented if a sample is used (not discarded).\nUnitless");
MakeNameEx(0x000167E2, "DG_FASD_KEFADD_CNT_STALENONPURGEMAX", nameFlags);
MakeNameEx(0x000167E4, "DG_FASD_KEFADD_CNT_WARMCOOLSAMPLEMIN", nameFlags);
MakeNameEx(0x000167E6, "DG_FASD_KEFADD_DM_FASD_ENGAIRFLOWHIGH", nameFlags);
MakeRptCmt(0x000167E6, "Data will be discarded if the air flow is above this threshold.\nGrams/Sec");
MakeNameEx(0x000167E8, "DG_FASD_KEFADD_DM_FASD_PGENGAIRFLOWHIGH", nameFlags);
MakeRptCmt(0x000167E8, "An airflow value above this threshold will cause the intrusive diagnostic to be disabled.\nGrams/Sec");
MakeNameEx(0x000167EA, "DG_FASD_KEFADD_DM_PURGENGAIRFLOWLOW", nameFlags);
MakeRptCmt(0x000167EA, "An airflow value below this threshold will cause the intrusive diagnostic to be disabled.\nGrams/Sec");
MakeNameEx(0x000167EC, "DG_FASD_KEFADD_K_FASD_ACCUMNOMINAL", nameFlags);
MakeRptCmt(0x000167EC, "The center or nominal value of the accumulator that is not rich and not lean.\nUnitless");
MakeNameEx(0x000167EE, "DG_FASD_KEFADD_K_FASD_ACTIVEACCUMGAIN", nameFlags);
MakeRptCmt(0x000167EE, "EWMA gain used to filter the currently active long term fuel trim cell data.\nUnitless");
MakeNameEx(0x000167F0, "DG_FASD_KEFADD_K_FASD_FUELCTRLOVERRIDE", nameFlags);
MakeNameEx(0x000167F2, "DG_FASD_KEFADD_K_FASD_NONPURGEACCUMGAIN", nameFlags);
MakeRptCmt(0x000167F2, "EWMA gain used to filter the non-purge long term fuel trim cell data during both the passive and intrusive vapor tests.\nUnitless");
MakeNameEx(0x000167F4, "DG_FASD_KEFADD_K_FASD_SHORTTERMGAIN", nameFlags);
MakeRptCmt(0x000167F4, "EWMA gain used to filter the short term integrator data.\nUnitless");
MakeNameEx(0x000167F6, "DG_FASD_KEFADD_K_FASD_SHORTTERMLEANLIM", nameFlags);
MakeRptCmt(0x000167F6, "Failure threshold for the short term accumulator while non-intrusive purge activity is occurring.\nUnitless");
MakeNameEx(0x000167F8, "DG_FASD_KEFADD_K_FASD_SHORTTERMRICHLIM", nameFlags);
MakeRptCmt(0x000167F8, "Short term accumulator threshold, while non-intrusive purge activity is occurring, to determine an excess vapor test is needed.\nUnitless");
MakeNameEx(0x000167FA, "DG_FASD_KEFADD_K_FASD_SHRTNONPRGRICHLIM", nameFlags);
MakeRptCmt(0x000167FA, "Short term accumulator threshold, while intrusive purge activity is occurring, to determine if excess vapor test is failing.\nUnitless");
MakeNameEx(0x000167FC, "DG_FASD_KEFADD_M_FASD_ACCUMPURGETHRSHLD", nameFlags);
MakeRptCmt(0x000167FC, "Threshold of accumulated purge flow required to reduce the excess purge vapor condition before continuing intrusive testing.\nGrams");
MakeNameEx(0x00016800, "DG_FASD_KEFADD_N_FASD_PURGERPMMIN", nameFlags);
MakeRptCmt(0x00016800, "An engine speed value below this threshold will cause the intrusive diagnostic to be disabled.\nRPM");
MakeNameEx(0x00016802, "DG_FASD_KEFADD_N_FASD_RPM_HIGH", nameFlags);
MakeRptCmt(0x00016802, "Data will be discarded if the engine speed is above this threshold.\nRPM");
MakeNameEx(0x00016804, "DG_FASD_KEFADD_N_FASD_RPM_LOW", nameFlags);
MakeRptCmt(0x00016804, "Data will be discarded if the engine speed is below this threshold.\nRPM");
MakeNameEx(0x00016806, "DG_FASD_KEFADD_P_FASD_BAROMETERLOW", nameFlags);
MakeRptCmt(0x00016806, "Data will be discarded if the barometric pressure is below this threshold.\nkPa");
MakeNameEx(0x00016808, "DG_FASD_KEFADD_P_FASD_PURGE_MAP_HIGH", nameFlags);
MakeRptCmt(0x00016808, "An manifold pressure value above this threshold will cause the intrusive diagnostic to be disabled.\nkPa");
MakeNameEx(0x0001680A, "DG_FASD_KEFADD_P_MANIFOLDPRESSUREHIGH", nameFlags);
MakeRptCmt(0x0001680A, "Data will be discarded if the manifold pressure is above this threshold.\nkPa");
MakeNameEx(0x0001680C, "DG_FASD_KEFADD_P_MANIFOLDPRESSURELOW", nameFlags);
MakeRptCmt(0x0001680C, "Data will be discarded if the manifold pressure is below this threshold.\nkPa");
MakeNameEx(0x0001680E, "DG_FASD_KEFADD_PCT_FASD_PURGEOPENMIN", nameFlags);
MakeRptCmt(0x0001680E, "Data will be discarded if the purge valve is open above this threshold and the vent valve is closed.\nPercent");
MakeNameEx(0x00016810, "DG_FASD_KEFADD_PCT_PGOVERRIDEMINLIM", nameFlags);
MakeRptCmt(0x00016810, "During intrusive test, purge valve is closed to less than or equal to this limit.\nPercent");
MakeNameEx(0x00016812, "DG_FASD_KEFADD_T_BLENDINGOPENMAX", nameFlags);
MakeNameEx(0x00016813, "DG_FASD_KEFADD_T_FASD_BLENDDURATIONMAX", nameFlags);
MakeNameEx(0x00016814, "DG_FASD_KEFADD_T_FASD_COOLANTTEMPHIGH", nameFlags);
MakeRptCmt(0x00016814, "Data will be discarded if the coolant temperature is above this threshold.\nDeg C");
MakeNameEx(0x00016816, "DG_FASD_KEFADD_T_FASD_COOLANTTEMPLOW", nameFlags);
MakeRptCmt(0x00016816, "Data will be discarded if the coolant temperature is below this threshold.\nDeg C");
MakeNameEx(0x00016818, "DG_FASD_KEFADD_T_FASD_COOLANTTEMPMIN", nameFlags);
MakeRptCmt(0x00016818, "A calibrated number of samples above this minimum are required before a passive vapor test is allowed.\nDeg C");
MakeNameEx(0x0001681A, "DG_FASD_KEFADD_T_FASD_CTLREQDURATIONMAX", nameFlags);
MakeNameEx(0x0001681B, "DG_FASD_KEFADD_T_FASD_DECIMALTIMESTEP", nameFlags);
MakeRptCmt(0x0001681B, "The minor time increment used by the timers. Equals the execution loop time interval.\nSeconds");
MakeNameEx(0x0001681C, "DG_FASD_KEFADD_T_FASD_EXTENDPGDURATION", nameFlags);
MakeNameEx(0x0001681E, "DG_FASD_KEFADD_T_FASD_IAT_HIGH", nameFlags);
MakeRptCmt(0x0001681E, "Data will be discarded if the intake air temperature is above this threshold.\nDeg C");
MakeNameEx(0x00016820, "DG_FASD_KEFADD_T_FASD_IAT_LOW", nameFlags);
MakeRptCmt(0x00016820, "Data will be discarded if the intake air temperature is below this threshold.\nDeg C");
MakeNameEx(0x00016822, "DG_FASD_KEFADD_T_FASD_NONSELDURATIONMAX", nameFlags);
MakeNameEx(0x00016824, "DG_FASD_KEFADD_T_FASD_PASSVONLYDURATION", nameFlags);
MakeRptCmt(0x00016824, "The amount of time the diagnostic will remain in the extended purging state after a passive only vapor test has occurred.\nSeconds");
MakeNameEx(0x00016826, "DG_FASD_KEFADD_T_FASD_SEGMNTDURATIONMAX", nameFlags);
MakeRptCmt(0x00016826, "The maximum time allowed for an intrusive segment. The intrusive segment will abort if this threshold is reached.\nSeconds");
MakeNameEx(0x00016828, "DG_FASD_KEFADD_T_FASD_VALVCLSDDURATION", nameFlags);
MakeRptCmt(0x00016828, "The intrusive segment will abort if this threshold is reached before the purge valve closes to a non-purging level.\nSeconds");
MakeNameEx(0x0001682A, "DG_FASD_KEFADD_V_FASD_VEHSPEEDHIGH", nameFlags);
MakeRptCmt(0x0001682A, "Data will be discarded if the vehicle speed is above this threshold.\nMPH");
MakeNameEx(0x0001682C, "DG_FASD_KEFADD_CNT_EXTENDPASSCNTMIN", nameFlags);
MakeRptCmt(0x0001682C, "Number of continuous passing report attempts required before allowing an actual pass report during the extended purging period.\nUnitless");
MakeNameEx(0x0001682E, "DG_FASD_KEFADD_CNT_FASD_STALEACCUMDEC", nameFlags);
MakeRptCmt(0x0001682E, "Amount the active accumulator stale data counter is decremented if a sample is used (not discarded).\nUnitless");
MakeNameEx(0x00016830, "DG_FASD_KEFADD_DM_FASD_ENGAIRFLOWLOW", nameFlags);
MakeRptCmt(0x00016830, "Data will be discarded if the air flow is below this threshold.\nGrams/Sec");
MakeNameEx(0x00016832, "DG_FASD_KEFADD_P_FASD_PURGE_MAP_LOW", nameFlags);
MakeRptCmt(0x00016832, "An manifold pressure value below this threshold will cause the intrusive diagnostic to be disabled.\nkPa");
MakeNameEx(0x00016834, "DG_FASD_KTFADD_K_FASD_NONPURGERICHLIM", nameFlags);
MakeRptCmt(0x00016834, "Vector table for the rich failure threshold for non-purging cells relative to the fuel ethanol percentage.\nUnitless");
MakeNameEx(0x0001684A, "DG_FASD_KTFADD_K_FASD_LONGTERMTRIMRICH", nameFlags);
MakeRptCmt(0x0001684A, "Vector table for the rich threshold to run a vapor test relative to the fuel ethanol percentage.\nUnitless");
MakeNameEx(0x00016860, "DG_FASD_KTFADD_K_FASD_LONGTERMTRIMLEAN", nameFlags);
MakeRptCmt(0x00016860, "Vector table for the lean failure threshold relative to the fuel ethanol percentage.\nUnitless");
MakeNameEx(0x00016876, "DG_FASD_KTFADD_PCT_FASD_VALVERAMPSTEP", nameFlags);
MakeRptCmt(0x00016876, "Step size, based on the starting valve position, used while closing the purge valve during the intrusive test.\nPercent");
MakeNameEx(0x0001688C, "DG_FASD_KTFADD_DM_FASD_MAXPURGEFLOW", nameFlags);
MakeNameEx(0x00016896, "DG_FASD_KTFADD_K_FASD_THRESHLDTEMPMULT", nameFlags);
MakeRptCmt(0x00016896, "Used to compensate the accumulated purge flow threshold for the variation of excess purge vapor generation due to temperature.\nUnitless");
MakeNameEx(0x000168A6, "DI_FASD_KE_FASD_NUMBER_OF_BANKS", nameFlags);
MakeRptCmt(0x000168A6, "The number of engineBanks that have independant fuel control.\nUnitless");
MakeNameEx(0x000168A8, "DI_FASD_KAFADD_CNT_FASD_MINSMPLSINSTART", nameFlags);
MakeRptCmt(0x000168A8, "Number of samples required to ensure the fuel trim value represents the current conditions for that cell.\nCounts");
MakeNameEx(0x000168D6, "DI_FASD_KAFADD_B_FASD_INTRUSIVECELLSET", nameFlags);
MakeRptCmt(0x000168D6, "An intrusive test will not be enabled if the table is FALSE for that cell.\nBOOLEAN");
MakeNameEx(0x000168EE, "DI_FASD_KAFADD_E_FASD_SELECTCELLSET", nameFlags);
MakeRptCmt(0x000168EE, "Use of thecell in the FASD diagnostic. 0 = Not Selected,  1 = Selected Purge Cell 2 = Selected Non Purge Cell\n0_1_2");
MakeNameEx(0x00016906, "DI_FASD_KAFADD_I_FASD_MATCHNONPURGE", nameFlags);
MakeRptCmt(0x00016906, "Translate from the current cell number to the cell number after the  purge valve is closed.\nSHORTCARD");
MakeNameEx(0x0001691E, "DI_FASD_KAFADD_K_FASD_NORMALIZELEAN", nameFlags);
MakeNameEx(0x0001697A, "DI_FASD_KAFADD_K_FASD_NORMALIZERICH", nameFlags);
MakeNameEx(0x000169D6, "DI_FASD_KEFADD_T_FASD_MINIATENABLE", nameFlags);
MakeRptCmt(0x000169D6, "FASD will be disabled if the min IAT is below this threshold.\nDegrees C");
MakeNameEx(0x000169D8, "DI_FASD_KEFADD_FASD_FUELLEVELMIN", nameFlags);
MakeRptCmt(0x000169D8, "Minimum fuel level at which the FASD will allow lean system diagnostic to continue.\nPercent");
MakeNameEx(0x000169DA, "DI_FASD_KEFADD_FUELLEVELLOWTIME", nameFlags);
MakeRptCmt(0x000169DA, "Determines how long the fuel level has to be below its minimum threshold before the diagnostic will be disabled.\nSeconds");
MakeNameEx(0x000169DC, "DI_FASD_KEFADD_MINIAT_MAF_CTR_MIN", nameFlags);
MakeRptCmt(0x000169DC, "MAF must be greater than KeFADD_MAF_To_Update_MinIAT  for at least this many 100msec samples for Min IAT to  update.\nCounts");
MakeNameEx(0x000169DE, "DI_FASD_KEFADD_MAF_TO_UPDATE_MINIAT", nameFlags);
MakeRptCmt(0x000169DE, "Min IAT will be updated when MAF is greater than this threshold and Long Soak is FALSE.\nGrams/Sec");
MakeNameEx(0x000169E0, "DI_FASD_KEFADD_LONG_SOAK_TIME_MIN", nameFlags);
MakeRptCmt(0x000169E0, "Soak time less than this will intialize FASD min IAT to  NVMEM min IAT from previous trip.\nSeconds");
MakeNameEx(0x000169E4, "DI_FASD_KEFADD_TIME_SINCE_PWRUP_MAX", nameFlags);
MakeRptCmt(0x000169E4, "Time since PCM powerup must be less than or equal to this to initialize FASD min IAT.\nSeconds");
MakeNameEx(0x000169E8, "DI_FASD_KEFADD_IAT_RATE_LIMIT", nameFlags);
MakeRptCmt(0x000169E8, "Max amount that raw IAT is allowed to change per 100msec. for use in min IAT.\nDegrees_C");
MakeNameEx(0x000169EA, "DG_FFS_KE_FFSD_COMP_FAIL_LIM", nameFlags);
MakeRptCmt(0x000169EA, "Maximum number of failure counts required to fail the test.\nUnitless");
MakeNameEx(0x000169EC, "DG_FFS_KE_FFSD_COMP_SHORTED_HI_THRESH", nameFlags);
MakeRptCmt(0x000169EC, "The threshold above which the flex fuel composition sensor frequency is considered out of range high.\nHertz");
MakeNameEx(0x000169ED, "DG_FFS_KE_FFSD_COMP_SHORTED_LO_THRESH", nameFlags);
MakeRptCmt(0x000169ED, "The threshold below which the flex fuel composition sensor frequency is considered out of range low.\nHertz");
MakeNameEx(0x000169EE, "DG_FFS_KE_FFSD_COMP_SHRTHI_FAIL_LIM", nameFlags);
MakeRptCmt(0x000169EE, "Number of failed out of range high tests within a sample size that will report a failure.\nUnitless");
MakeNameEx(0x000169F0, "DG_FFS_KE_FFSD_COMP_SHRTHI_SMPL_LIM", nameFlags);
MakeRptCmt(0x000169F0, "Number of out of range high tests that make up a sample size.\nUnitless");
MakeNameEx(0x000169F2, "DG_FFS_KE_FFSD_COMP_SHRTLO_FAIL_LIM", nameFlags);
MakeRptCmt(0x000169F2, "Number of failed out of range low tests within a sample size that will report a failure.\nUnitless");
MakeNameEx(0x000169F4, "DG_FFS_KE_FFSD_COMP_SHRTLO_SMPL_LIM", nameFlags);
MakeRptCmt(0x000169F4, "Number of out of range low tests that make up a sample size.\nUnitless");
MakeNameEx(0x000169F6, "DG_FFS_KE_FFSD_COMP_SMPL_LIM", nameFlags);
MakeRptCmt(0x000169F6, "Total number of sample counts required to pass the composition test.\nUnitless");
MakeNameEx(0x000169F8, "DG_FFS_KE_FFSD_RAT_TEMP_DIFF", nameFlags);
MakeRptCmt(0x000169F8, "Maximum temperature difference allowed for enabling the FFSD rationality test.\nDegrees");
MakeNameEx(0x000169FA, "DG_FFS_KE_FFSD_TEMP_SHORTED_HI_THRESH", nameFlags);
MakeRptCmt(0x000169FA, "The threshold above which the flex fuel temperature sensor active time is considered out of range high.\nMilliseconds");
MakeNameEx(0x000169FC, "DG_FFS_KE_FFSD_TEMP_SHORTED_LO_THRESH", nameFlags);
MakeRptCmt(0x000169FC, "The threshold below which the flex fuel temperature sensor active time is considered out of range low.\nMilliseconds");
MakeNameEx(0x000169FE, "DG_FFS_KE_FFSD_TEMP_SHRTHI_FAIL_LIM", nameFlags);
MakeRptCmt(0x000169FE, "Number of failed out of range high tests within a sample size that will report a failure.\nUnitless");
MakeNameEx(0x00016A00, "DG_FFS_KE_FFSD_TEMP_SHRTHI_SMPL_LIM", nameFlags);
MakeRptCmt(0x00016A00, "Number of out of range high tests that make up a sample size.\nUnitless");
MakeNameEx(0x00016A02, "DG_FFS_KE_FFSD_TEMP_SHRTLO_FAIL_LIM", nameFlags);
MakeRptCmt(0x00016A02, "Number of failed out of range low tests within a sample size that will report a failure.\nUnitless");
MakeNameEx(0x00016A04, "DG_FFS_KE_FFSD_TEMP_SHRTLO_SMPL_LIM", nameFlags);
MakeRptCmt(0x00016A04, "Number of out of range low tests that make up a sample size.\nUnitless");
MakeNameEx(0x00016A06, "DG_FFS_KV_FFSD_FUEL_COMPOSITION", nameFlags);
MakeRptCmt(0x00016A06, "The maximum upper limit allowed for the flex fuel sensor frequency value based on intake air temperature.\nHertz");
MakeNameEx(0x00016A26, "DI_FFS_KE_FFSD_TIME_SINCE_ENG_RUN", nameFlags);
MakeNameEx(0x00016A28, "DI_FFS_KE_FFSD_MIN_ENG_RUN_TIME", nameFlags);
MakeRptCmt(0x00016A28, "Minimum amount of time that the engine must be running before the FFSD will be enabled.\nSeconds");
MakeNameEx(0x00016A2C, "DI_FFS_KE_FFSD_SYSTEM_VOLT_MIN", nameFlags);
MakeRptCmt(0x00016A2C, "Lower limit for the system voltage below which the FFSD is not enabled.\nVolts");
MakeNameEx(0x00016A2D, "DI_FFS_KE_FFSD_SYSTEM_VOLT_MAX", nameFlags);
MakeRptCmt(0x00016A2D, "Upper limit for the system voltage above which the FFSD is not enabled.\nVolts");
MakeNameEx(0x00016A2E, "DG_FUEL_TRIM_KE_FTRM_EXCESS_PURGE_PRESENT_LIM", nameFlags);
MakeRptCmt(0x00016A2E, "Limits the number of purge tests per trip by limiting the number of tests that have indicated an excess amount of purge.\nUnitless");
MakeNameEx(0x00016A2F, "DG_FUEL_TRIM_KE_FTRM_LEAN_TEST_FAIL_LIMIT", nameFlags);
MakeRptCmt(0x00016A2F, "Determines how long the system can be lean before a lean failure is reported to the Diagnostic Executive.\nUnitless");
MakeNameEx(0x00016A30, "DG_FUEL_TRIM_KE_FTRM_NORMAL_PURGE_PRESENT_LIM", nameFlags);
MakeRptCmt(0x00016A30, "Limits the number of purge tests per trip by limiting the number of tests that have indicated normal amounts of purge.\nUnitless");
MakeNameEx(0x00016A31, "DG_FUEL_TRIM_KE_FTRM_PURGE_TEST_REQUEST_LIM", nameFlags);
MakeRptCmt(0x00016A31, "Limits the number of purge tests per trip by limiting the number of purge test requests.\nUnitless");
MakeNameEx(0x00016A32, "DG_FUEL_TRIM_KE_FTRM_RICH_TEST_FAIL_LIMIT", nameFlags);
MakeRptCmt(0x00016A32, "Determines how long the system can be rich before a rich failure is reported to the Diagnostic Executive.\nUnitless");
MakeNameEx(0x00016A33, "DG_FUEL_TRIM_KE_FTRM_SHORT_TERM_SAMPLE_COUNT", nameFlags);
MakeRptCmt(0x00016A33, "Determines how many samples will be collected and used in the short term fuel trim average calculations.\nUnitless");
MakeNameEx(0x00016A34, "DG_FUEL_TRIM_KE_FTRM_SHORT_TERM_TRIM_LEAN", nameFlags);
MakeRptCmt(0x00016A34, "Determines at what point the short term fuel trim average is considered to be lean.\nUnitless");
MakeNameEx(0x00016A35, "DG_FUEL_TRIM_KE_FTRM_SHORT_TERM_TRIM_RICH", nameFlags);
MakeRptCmt(0x00016A35, "Determines at what point the short term fuel trim average is considered to be rich.\nUnitless");
MakeNameEx(0x00016A36, "DG_FUEL_TRIM_KE_FTRM_WAIT_TIME_MAX", nameFlags);
MakeRptCmt(0x00016A36, "Maximum time the diagnostic will wait before executing after excess purge has been detected.\nSeconds");
MakeNameEx(0x00016A38, "DG_HSCR_KE_HSCR_STARTUP_TEMP_DIFF", nameFlags);
MakeNameEx(0x00016A3A, "DG_HSCR_KE_HSCR_IAT_ENABLE", nameFlags);
MakeRptCmt(0x00016A3A, "The threshold above which the intake air temperature must be,to enable the HSCR diagnostic.\nDegrees_C");
MakeNameEx(0x00016A3C, "DG_HSCR_KE_HSCR_VEHICLE_SPEED_MIN", nameFlags);
MakeRptCmt(0x00016A3C, "The threshold above which the vehicle speed must be to increment the HSCR vehicle speed time.\nMPH");
MakeNameEx(0x00016A3E, "DG_HSCR_KE_HSCR_VEHICLE_DRIVE_TIME_MIN", nameFlags);
MakeRptCmt(0x00016A3E, "The threshold above which the HSCR vehicle speed time must be to enable the comparison of powerup IAT with min IAT.\nSeconds");
MakeNameEx(0x00016A40, "DG_HSCR_KE_HSCR_IAT_DROP_MAX", nameFlags);
MakeNameEx(0x00016A42, "DI_HSCR_KE_HSCR_TIME_SINCE_ENG_RUN", nameFlags);
MakeRptCmt(0x00016A42, "Minimum amount of time that has passed since the engine was last turned off.\nMinutes");
MakeNameEx(0x00016A44, "DG_IAT_KE_IATD_ENG_RUN_TIME_HIGH_MIN", nameFlags);
MakeRptCmt(0x00016A44, "Minimum engine run time threshold to record a short to high fault\nSeconds");
MakeNameEx(0x00016A45, "DG_IAT_KE_IATD_ENG_RUN_TIME_LOW_MIN", nameFlags);
MakeRptCmt(0x00016A45, "Minimum engine run time threshold to record a short to low fault\nSeconds");
MakeNameEx(0x00016A46, "DG_IAT_KE_IATD_INT_SHORT_HIGH_FAIL_LIM", nameFlags);
MakeRptCmt(0x00016A46, "Number of failed intermittent short to high tests that will report an intermittent failure\nUnitless");
MakeNameEx(0x00016A48, "DG_IAT_KE_IATD_INT_SHORT_HIGH_SMPL_LIM", nameFlags);
MakeRptCmt(0x00016A48, "Number of intermittent short high tests that make up a sample size\nUnitless");
MakeNameEx(0x00016A4A, "DG_IAT_KE_IATD_INT_SHORT_LOW_FAIL_LIM", nameFlags);
MakeRptCmt(0x00016A4A, "Number of failed intermittent short to low tests that will report an intermittent failure\nUnitless");
MakeNameEx(0x00016A4C, "DG_IAT_KE_IATD_INT_SHORT_LOW_SMPL_LIM", nameFlags);
MakeRptCmt(0x00016A4C, "Number of intermittent short low tests that make up a sample size\nUnitless");
MakeNameEx(0x00016A4E, "DG_IAT_KE_IATD_SHORT_HIGH_FAIL_LIM", nameFlags);
MakeRptCmt(0x00016A4E, "Number of failed short to high tests within a sample size that will report a failure\nUnitless");
MakeNameEx(0x00016A50, "DG_IAT_KE_IATD_SHORT_HIGH_SMPL_LIM", nameFlags);
MakeRptCmt(0x00016A50, "Number of IAT short high tests that make up a sample size\nUnitless");
MakeNameEx(0x00016A52, "DG_IAT_KE_IATD_SHORT_LOW_FAIL_LIM", nameFlags);
MakeRptCmt(0x00016A52, "Number of failed short to low tests within a sample size that will report a failure\nUnitless");
MakeNameEx(0x00016A54, "DG_IAT_KE_IATD_SHORT_LOW_SMPL_LIM", nameFlags);
MakeRptCmt(0x00016A54, "Number of IAT short low tests that make up a sample size\nUnitless");
MakeNameEx(0x00016A56, "DG_IAT_KE_IATD_SHORTED_HIGH_THRESH", nameFlags);
MakeRptCmt(0x00016A56, "The threshold above which the IAT sensor is considered shorted high\nPercent");
MakeNameEx(0x00016A58, "DG_IAT_KE_IATD_SHORTED_LOW_THRESH", nameFlags);
MakeRptCmt(0x00016A58, "The threshold below which the IAT sensor is considered opened or shorted to ground\nPercent");
MakeNameEx(0x00016A5A, "DI_IAT_KE_IATD_SHORT_HIGH_ECT_MIN", nameFlags);
MakeRptCmt(0x00016A5A, "Minimum coolant temperature to fail the IAT short to high test.\nDegrees_C");
MakeNameEx(0x00016A5C, "DI_IAT_KE_IATD_SHORT_HIGH_MAF_MAX", nameFlags);
MakeRptCmt(0x00016A5C, "Maximum mass air flow threshold to fail the IAT short to high test.\nGrams/Second");
MakeNameEx(0x00016A5E, "DI_IAT_KE_IATD_SHORT_HIGH_VSS_MAX", nameFlags);
MakeRptCmt(0x00016A5E, "Maximum vehicle speed threshold to fail the IAT short to high test.\nMiles/Hour");
MakeNameEx(0x00016A60, "DI_IAT_KE_IATD_SHORT_LOW_ECT_MAX", nameFlags);
MakeRptCmt(0x00016A60, "Maximum coolant temperature to fail the IAT short to low test.\nDegrees_C");
MakeNameEx(0x00016A62, "DI_IAT_KE_IATD_SHORT_LOW_VSS_MIN", nameFlags);
MakeRptCmt(0x00016A62, "Minimum vehicle speed threshold to fail the IAT short to low test.\nMiles/Hour");
MakeNameEx(0x00016A64, "DG_ICAT_KE_CAT_EWMA_FILTER_COEF", nameFlags);
MakeRptCmt(0x00016A64, "Exponentially weighted moving average filter coefficient.\nCoef");
MakeNameEx(0x00016A66, "DG_ICAT_KE_CAT_AFT1_TRANSITION_TIME_MAX", nameFlags);
MakeRptCmt(0x00016A66, "Maximum allowed duration for Air/Fuel transition 1.\nSeconds");
MakeNameEx(0x00016A68, "DG_ICAT_KE_CAT_AFT2_TRANSITION_TIME_MAX", nameFlags);
MakeRptCmt(0x00016A68, "Maximum allowed duration for Air/Fuel transition 2.\nSeconds");
MakeNameEx(0x00016A6A, "DG_ICAT_KE_CAT_HIGH_OSC_TIME_DEFAULT", nameFlags);
MakeNameEx(0x00016A6C, "DG_ICAT_KE_CAT_POST_O2_LEAN_VOLT_MAX", nameFlags);
MakeRptCmt(0x00016A6C, "Maximum post O2 voltage to be considered saturated lean while in AFT1.\nMillivolts");
MakeNameEx(0x00016A6E, "DG_ICAT_KE_CAT_PRE_O2_LEAN_VOLT_MAX", nameFlags);
MakeRptCmt(0x00016A6E, "Maximum pre O2 voltage to be considered saturated lean while in AFT1.\nMillivolts");
MakeNameEx(0x00016A70, "DG_ICAT_KE_CAT_POST_O2_RICH_VOLT_MIN", nameFlags);
MakeRptCmt(0x00016A70, "Minimum post O2 voltage to be considered saturated rich while in AFT1.\nMillivolts");
MakeNameEx(0x00016A72, "DG_ICAT_KE_CAT_PRE_O2_RICH_VOLT_MIN", nameFlags);
MakeRptCmt(0x00016A72, "Minimum pre O2 voltage to be considered saturated rich while in AFT1.\nMillivolts");
MakeNameEx(0x00016A74, "DG_ICAT_KE_CAT_MAX_RSR_TESTS", nameFlags);
MakeRptCmt(0x00016A74, "The maximum number of tests to run once the rapid step response is activated.\nUnitless");
MakeNameEx(0x00016A75, "DG_ICAT_KE_CAT_MAX_TESTS_PER_TRIP", nameFlags);
MakeRptCmt(0x00016A75, "The maximum number of tests to run each trip once the rapid step response is activated.\nUnitless");
MakeNameEx(0x00016A76, "DG_ICAT_KE_CAT_MIN_SAMPLES_TO_RPT_PASS", nameFlags);
MakeRptCmt(0x00016A76, "Minimum number of tests run before reporting a pass.\nUnitless");
MakeNameEx(0x00016A78, "DG_ICAT_KE_CAT_POST_O2_LEAN_VOLTAGE", nameFlags);
MakeRptCmt(0x00016A78, "Maximum post O2 voltage to be considered lean.\nMillivolts");
MakeNameEx(0x00016A7A, "DG_ICAT_KE_CAT_POST_O2_RICH_VOLTAGE", nameFlags);
MakeRptCmt(0x00016A7A, "Minimum post O2 voltage to be considered rich.\nMillivolts");
MakeNameEx(0x00016A7C, "DG_ICAT_KE_CAT_STOICH_REFERENCE_VOLT", nameFlags);
MakeRptCmt(0x00016A7C, "Theoretical O2 voltage for a stoichiometric A/F ratio.\nMillivolts");
MakeNameEx(0x00016A7E, "DG_IDLE_KE_IAC_INTRUSIVE_TEST_OPTION", nameFlags);
MakeRptCmt(0x00016A7E, "This calibration option determines whether or not the valvetest should be allowed to execute.\nBOOLEAN");
MakeNameEx(0x00016A80, "DG_IDLE_KE_IAC_RPM_DELTA_LIMIT", nameFlags);
MakeRptCmt(0x00016A80, "RPM delta threshold to disable the valve test.\nRPM");
MakeNameEx(0x00016A82, "DG_IDLE_KE_IAC_TPS_DELTA_LIMIT", nameFlags);
MakeRptCmt(0x00016A82, "TPS delta threshold to disable the valve test.\nPercent");
MakeNameEx(0x00016A84, "DG_IDLE_KE_IAC_VALVE_TEST_AIRFLOW_MAX", nameFlags);
MakeRptCmt(0x00016A84, "Upper threshold airflow value to disable the valve test.\nGrams/Sec");
MakeNameEx(0x00016A86, "DG_IDLE_KE_IAC_VALVE_TEST_AIRFLOW_MIN", nameFlags);
MakeRptCmt(0x00016A86, "Lower threshold airflow value to disable the valve test.\nGrams/Sec");
MakeNameEx(0x00016A88, "DG_IDLE_KE_IAC_VALVE_TEST_VEH_SPEED_MAX", nameFlags);
MakeRptCmt(0x00016A88, "Upper threshold vehicle speed value to disable the valve test.\nMPH");
MakeNameEx(0x00016A8A, "DG_IDLE_KE_IAC_VALVE_TEST_VEH_SPEED_MIN", nameFlags);
MakeRptCmt(0x00016A8A, "Lower threshold vehicle speed value to disable the valve test.\nMPH");
MakeNameEx(0x00016A8C, "DG_IDLE_KE_IAC_AIRFLOW_RESPONSE_THRESH", nameFlags);
MakeRptCmt(0x00016A8C, "This calibration determines how much airflow decrease must occur in order to consider the valve functioning properly.\nGrams/Sec");
MakeNameEx(0x00016A8E, "DG_IDLE_KE_IAC_VALVE_TEST_TIME_LIMIT", nameFlags);
MakeRptCmt(0x00016A8E, "This calibration limits how long the valve test will execute.\nSeconds");
MakeNameEx(0x00016A8F, "DG_IDLE_KE_IAC_REPORT_IDLE_RESULTS", nameFlags);
MakeNameEx(0x00016A90, "DG_IDLE_KV_IAC_RPM_ERROR_HIGH_THRESHOLD", nameFlags);
MakeRptCmt(0x00016A90, "Minimum RPM error used to determine if the OBD_Idle_RPM_Error is too high.\nRPM");
MakeNameEx(0x00016AB2, "DG_IDLE_KE_IAC_RPM_HIGH_TIMER_LIMIT", nameFlags);
MakeRptCmt(0x00016AB2, "Minimum amount of time used to indicate that there is a high idle RPM problem.\nSeconds");
MakeNameEx(0x00016AB4, "DG_IDLE_KV_IAC_RPM_ERROR_LOW_THRESHOLD", nameFlags);
MakeRptCmt(0x00016AB4, "Maximum RPM error used to determine if the OBD_Idle_RPM_Error is too low.\nRPM");
MakeNameEx(0x00016AD6, "DG_IDLE_KE_IAC_RPM_LOW_TIMER_LIMIT", nameFlags);
MakeRptCmt(0x00016AD6, "Minimum amount of time used to indicate that there is a low idle RPM error problem.\nSeconds");
MakeNameEx(0x00016AD8, "DG_IDLE_KE_IAC_FILTERED_RPM_ERROR_MAX", nameFlags);
MakeRptCmt(0x00016AD8, "Maximum value for the allowable filtered RPM error.\nRPM");
MakeNameEx(0x00016ADA, "DG_IDLE_KE_IAC_TEST_PASS_TIME", nameFlags);
MakeRptCmt(0x00016ADA, "Minimum time duration for the RPM to be within its allowable filtered RPM error to report that the Idle RPM is passing.\nSeconds");
MakeNameEx(0x00016ADC, "DG_IDLE_KE_IAC_RPM_ERROR_FILTER_COEFF", nameFlags);
MakeRptCmt(0x00016ADC, "This is the coefficient for the first order lag filter of the error.\nCoef");
MakeNameEx(0x00016ADE, "DG_IGNITION_CONTROL_KE_IGN_CONTROL_COUNTER_RPM_THRES", nameFlags);
MakeRptCmt(0x00016ADE, "Samples and failures wih engine speed >= this are twice as significant as those with engine speed < this.\nRPM");
MakeNameEx(0x00016AE0, "DG_IGNITION_CONTROL_KE_IGNITION_CONTROL_FAILURE_LIMI", nameFlags);
MakeRptCmt(0x00016AE0, "Number of failed tests within a sample set that will report an ignition control failure.\nNONE");
MakeNameEx(0x00016AE1, "DG_IGNITION_CONTROL_KE_IGNITION_CONTROL_SAMPLES_LIMI", nameFlags);
MakeRptCmt(0x00016AE1, "Number of tests in a sample SET.\nNONE");
MakeNameEx(0x00016AE2, "DG_IGNITION_CONTROL_KV_EST_TESTED_CYLINDER_XREF", nameFlags);
MakeRptCmt(0x00016AE2, "Map EST channel to cylinder number.\nP_CODE");
MakeNameEx(0x00016AF2, "DG_IOT_KE_IOTD_IGNITION_OFF_DELTA", nameFlags);
MakeRptCmt(0x00016AF2, "The acceptable difference between the previous and current Ignition Off Timer values.\nSeconds");
MakeNameEx(0x00016AF3, "DG_IOT_KE_IOTD_MAX_EXPECTED_TIME", nameFlags);
MakeRptCmt(0x00016AF3, "The maximum time the Ignition Off Timer is expected to be reporting after an ignition off period begins.\nSeconds");
MakeNameEx(0x00016AF4, "DG_IOT_KE_IOTD_MIN_EXPECTED_TIME", nameFlags);
MakeRptCmt(0x00016AF4, "The minimum time the Ignition Off Timer is expected to be reporting after an ignition off period begins.\nSeconds");
MakeNameEx(0x00016AF5, "DG_IOT_KE_IOTD_SAMPLE_COUNTER_MAX", nameFlags);
MakeRptCmt(0x00016AF5, "The maximum number of samples below which the Ignition Off Timer is expected to increment.\nCounts");
MakeNameEx(0x00016AF6, "DG_IOT_KE_IOTD_SAMPLE_COUNTER_MIN", nameFlags);
MakeRptCmt(0x00016AF6, "The minimum number of samples above which the Ignition Off Timer is expected to increment.\nCounts");
MakeNameEx(0x00016AF7, "DG_IOT_KE_IOTD_SMPLS_WITHOUT_CHANGE", nameFlags);
MakeNameEx(0x00016AF8, "DG_IOT_KE_IOTD_TRANSITION_THRESHOLD", nameFlags);
MakeRptCmt(0x00016AF8, "The number of Ingition Off Timer transitions above which the diagnostic may proceed.\nCounts");
MakeNameEx(0x00016AFA, "DG_LEGR_KE_EGRP_SIGNAL_LOW_POS_MAX", nameFlags);
MakeRptCmt(0x00016AFA, "Maximum valid EGR position below which is considered a low signal.\nPercent");
MakeNameEx(0x00016AFC, "DG_LEGR_KE_EGRP_CLOSED_VALVE_FAIL_COUNT", nameFlags);
MakeRptCmt(0x00016AFC, "Maximum number of fail conditions before reporting a fail.\nCounts");
MakeNameEx(0x00016AFD, "DG_LEGR_KE_EGRP_CLOSED_VALVE_OPEN_TIME", nameFlags);
MakeRptCmt(0x00016AFD, "Minimum time the EGR desired position must remain in a stable open position prior to the next closed valve test iteration.\nSeconds");
MakeNameEx(0x00016AFE, "DG_LEGR_KE_EGRP_CV_OPEN_POSITION", nameFlags);
MakeRptCmt(0x00016AFE, "Minimum EGR position to achieve and sustain following a failed closed valve test and prior to the next test iteration.\nPercent");
MakeNameEx(0x00016B00, "DG_LEGR_KE_EGRP_CV_POSITION_OFFSET", nameFlags);
MakeNameEx(0x00016B02, "DG_LEGR_KE_EGRP_CV_POSITION_TIME", nameFlags);
MakeRptCmt(0x00016B02, "Maximun allowable time that a high position offset can exceed a threshold before logging a failure.\nSeconds");
MakeNameEx(0x00016B03, "DG_LEGR_KE_EGRP_OPEN_VALVE_MAX_COUNT", nameFlags);
MakeRptCmt(0x00016B03, "Maximum allowable times the EGR position error can exceed a failure threshold before reporting a failure.\nCounts");
MakeNameEx(0x00016B04, "DG_LEGR_KE_EGRP_SIGNAL_LOW_TIME", nameFlags);
MakeRptCmt(0x00016B04, "Minimum allowable time limit for a low signal to report a failure condition.\nSeconds");
MakeNameEx(0x00016B05, "DG_LEGR_KE_EGRP_CV_DELAY_OPTION", nameFlags);
MakeRptCmt(0x00016B05, "Option to delay closed valve testing for partial valve opening or pintle cleaning routine.\nDelay_Type");
MakeNameEx(0x00016B06, "DG_LEGR_KE_EGRP_POSITION_ERROR_MAX1", nameFlags);
MakeRptCmt(0x00016B06, "Threshold above which the error in EGR position is considered unaccptable (Zone #1 - position error test.)\nPercent");
MakeNameEx(0x00016B08, "DG_LEGR_KE_EGRP_POSITION_ERROR_MAX2", nameFlags);
MakeRptCmt(0x00016B08, "Threshold above which the error in EGR position is considered unaccptable ( Zone #2 - position error test. )\nPercent");
MakeNameEx(0x00016B0A, "DG_LEGR_KE_EGRP_POS_ERR_BOUNDARY_SELECT", nameFlags);
MakeRptCmt(0x00016B0A, "Threshold used to determine if EGR is in Zone 1 and should use KE..Max1 or Zone 2 and use KE..Max2 ( position error test ).\nPercent");
MakeNameEx(0x00016B0C, "DG_LEGR_KE_EGRP_MAX_DESIRED_POS_DELTA", nameFlags);
MakeRptCmt(0x00016B0C, "The maximum allowable difference in desired position to enable the position error test.\nPercent");
MakeNameEx(0x00016B0E, "DG_LEGR_KE_EGRP_TIME_TO_PASS_CV", nameFlags);
MakeRptCmt(0x00016B0E, "The minimum allowable time to elapse before a P1404 pass will be indicated.\nSeconds");
MakeNameEx(0x00016B10, "DG_MAF_KE_MAFD_FREQ_HIGH_FAIL_LIM", nameFlags);
MakeRptCmt(0x00016B10, "Number of failed high tests within a sample size that will report a high frequency failure\nFailures");
MakeNameEx(0x00016B12, "DG_MAF_KE_MAFD_FREQ_HIGH_SMPL_LIM", nameFlags);
MakeRptCmt(0x00016B12, "Minimum number of MAF high frequency tests required to report a pass.\nSamples");
MakeNameEx(0x00016B14, "DG_MAF_KE_MAFD_FREQ_HIGH_THRESH", nameFlags);
MakeRptCmt(0x00016B14, "High frequency threshold above which represents a high frequency failure\nCycles/Sec");
MakeNameEx(0x00016B16, "DG_MAF_KE_MAFD_FREQ_LOW_FAIL_LIM", nameFlags);
MakeRptCmt(0x00016B16, "Number of failed low tests within a sample size that will report a low frequency failure\nFailures");
MakeNameEx(0x00016B18, "DG_MAF_KE_MAFD_FREQ_LOW_SMPL_LIM", nameFlags);
MakeRptCmt(0x00016B18, "Minimum number of MAF low frequency tests required to report a pass.\nSamples");
MakeNameEx(0x00016B1A, "DG_MAF_KE_MAFD_FREQ_LOW_THRESH", nameFlags);
MakeRptCmt(0x00016B1A, "Low frequency threshold above which represents a low frequency failure\nCycles/Sec");
MakeNameEx(0x00016B1C, "DG_MAF_KE_MAFD_RAT_FAIL_LIM", nameFlags);
MakeRptCmt(0x00016B1C, "Number of failed tests within a sample size that will report a MAF Rationality failure\nFailures");
MakeNameEx(0x00016B1E, "DG_MAF_KE_MAFD_RAT_SMPL_LIM", nameFlags);
MakeRptCmt(0x00016B1E, "Number of MAF Rationality tests that make up a sample size.\nSamples");
MakeNameEx(0x00016B20, "DG_MAF_KV_MAFD_PREDICTED_MAF_DELTA_MAX", nameFlags);
MakeRptCmt(0x00016B20, "Maximum predicted mass air flow delta value based on a calculated mass air flow value for the MAF rationality test.\nGPS");
MakeNameEx(0x00016B36, "DI_MAF_KE_MAFD_RAT_EGR_POS_MAX", nameFlags);
MakeRptCmt(0x00016B36, "Maximum allowed EGR pintle position value to run the MAF rationality test.\nPercent");
MakeNameEx(0x00016B38, "DI_MAF_KE_MAFD_RAT_ENG_VACUUM_MAX", nameFlags);
MakeRptCmt(0x00016B38, "Maximum allowed engine vacuum value to run the MAF rationality test.\nkPa");
MakeNameEx(0x00016B3A, "DI_MAF_KE_MAFD_RAT_IGN_VOLT_MIN", nameFlags);
MakeRptCmt(0x00016B3A, "Minimum ignition voltage necessary to run the MAF rationality test.\nVolts");
MakeNameEx(0x00016B3C, "DI_MAF_KE_MAFD_RAT_IGN_VOLT_MAX", nameFlags);
MakeRptCmt(0x00016B3C, "Maximum ignition voltage necessary to run the MAF rationality test.\nVolts");
MakeNameEx(0x00016B3E, "DI_MAF_KE_MAFD_RAT_IGN_VOLT_LOW_THRESH", nameFlags);
MakeRptCmt(0x00016B3E, "Ignition voltage below which it is necessary to compare the mass airflow reading to a threshold.\nVolts");
MakeNameEx(0x00016B40, "DI_MAF_KE_MAFD_RAT_LOW_VOLT_MAF_THRESH", nameFlags);
MakeRptCmt(0x00016B40, "Threshold below which the MAF value must be to run the MAF rationality test.\nGPS");
MakeNameEx(0x00016B42, "DI_MAF_KE_MAFD_RAT_MAP_DELTA_MAX", nameFlags);
MakeRptCmt(0x00016B42, "Maximum allowed manifold pressure delta value to run MAF rationality test.\nkPa");
MakeNameEx(0x00016B44, "DI_MAF_KE_MAFD_RAT_MAF_FILT_COEFF", nameFlags);
MakeRptCmt(0x00016B44, "Filter coefficient for the mass air flow rescaled in the MAF rationality test.\n0-1");
MakeNameEx(0x00016B46, "DI_MAF_KE_MAFD_RAT_PURGE_DC_MAX", nameFlags);
MakeRptCmt(0x00016B46, "Maximum allowed canister purge duty cycle value to run the MAF rationality test.\nPercent");
MakeNameEx(0x00016B48, "DI_MAF_KE_MAFD_RAT_STABLE_TIME_MIN", nameFlags);
MakeRptCmt(0x00016B48, "Minimum stabilization time after conditions have been met to run the MAF rationality test.\nSeconds");
MakeNameEx(0x00016B4A, "DI_MAF_KE_MAFD_RAT_TPS_DELTA_MAX", nameFlags);
MakeRptCmt(0x00016B4A, "Maximum allowed throttle position delta to run the MAF rationality test.\nPercent");
MakeNameEx(0x00016B4C, "DI_MAF_KE_MAFD_RAT_TPS_MAX", nameFlags);
MakeRptCmt(0x00016B4C, "Maximum allowed throttle position value to run the MAF rationality test.\nPercent");
MakeNameEx(0x00016B4E, "DI_MAF_KE_MAFD_FREQ_ENG_RUN_TIME_MIN", nameFlags);
MakeRptCmt(0x00016B4E, "Minimum engine run time necessary to run the MAF frequency test.\nSeconds");
MakeNameEx(0x00016B52, "DI_MAF_KE_MAFD_FREQ_IGN_VOLT_MIN", nameFlags);
MakeRptCmt(0x00016B52, "Minimum ignition voltage necessary to run the MAF frequency test.\nVolts");
MakeNameEx(0x00016B54, "DI_MAF_KE_MAFD_FREQ_RPM_MIN", nameFlags);
MakeRptCmt(0x00016B54, "Minimum engine speed necessary to run the MAF frequency test.\nRPM");
MakeNameEx(0x00016B56, "DI_MAF_KE_MAFD_FREQ_STABLE_TIME_MIN", nameFlags);
MakeRptCmt(0x00016B56, "Minimum stabilization time after conditions have been met to run the MAF frequency test.\nSeconds");
MakeNameEx(0x00016B58, "DG_MAP_KA_MAPD_PREDICTED_MAP_MAX", nameFlags);
MakeRptCmt(0x00016B58, "Upper threshold MAP readings\nKilopascals");
MakeNameEx(0x00016C08, "DG_MAP_KA_MAPD_PREDICTED_MAP_MIN", nameFlags);
MakeRptCmt(0x00016C08, "Lower threshold MAP readings\nKilopascals");
MakeNameEx(0x00016CB8, "DG_MAP_KE_MAPD_INT_SHORT_HIGH_FAIL_LIM", nameFlags);
MakeRptCmt(0x00016CB8, "Number of failed intermittent short to high tests within a sample size that will report a failure.\nUnitless");
MakeNameEx(0x00016CBA, "DG_MAP_KE_MAPD_INT_SHORT_HIGH_SMPL_LIM", nameFlags);
MakeRptCmt(0x00016CBA, "Number of intermittent short to high tests that make up a sample size.\nUnitless");
MakeNameEx(0x00016CBC, "DG_MAP_KE_MAPD_INT_SHORT_LOW_FAIL_LIM", nameFlags);
MakeRptCmt(0x00016CBC, "Number of failed intermittent short to low tests within a sample size that will report a failure.\nUnitless");
MakeNameEx(0x00016CBE, "DG_MAP_KE_MAPD_INT_SHORT_LOW_SMPL_LIM", nameFlags);
MakeRptCmt(0x00016CBE, "Number of intermittent short to low tests that make up a sample size.\nUnitless");
MakeNameEx(0x00016CC0, "DG_MAP_KE_MAPD_RAT_FAIL_LIM", nameFlags);
MakeRptCmt(0x00016CC0, "Number of rationality failed tests within a sample size that will report a failure.\nUnitless");
MakeNameEx(0x00016CC2, "DG_MAP_KE_MAPD_RAT_SMPL_LIM", nameFlags);
MakeRptCmt(0x00016CC2, "Number of rationality tests that make up a sample size.\nUnitless");
MakeNameEx(0x00016CC4, "DG_MAP_KE_MAPD_SHORT_HIGH_FAIL_LIM", nameFlags);
MakeRptCmt(0x00016CC4, "Number of failed short to high tests within a sample size that will report a failure.\nUnitless");
MakeNameEx(0x00016CC6, "DG_MAP_KE_MAPD_SHORT_HIGH_RPM", nameFlags);
MakeNameEx(0x00016CC8, "DG_MAP_KE_MAPD_SHORT_HIGH_SMPL_LIM", nameFlags);
MakeRptCmt(0x00016CC8, "Number of short to high tests that make up a sample size.\nUnitless");
MakeNameEx(0x00016CCA, "DG_MAP_KE_MAPD_SHORT_LOW_FAIL_LIM", nameFlags);
MakeRptCmt(0x00016CCA, "Number of failed short to low tests within a sample size that will report a failure.\nUnitless");
MakeNameEx(0x00016CCC, "DG_MAP_KE_MAPD_SHORT_LOW_RPM", nameFlags);
MakeNameEx(0x00016CCE, "DG_MAP_KE_MAPD_SHORT_LOW_SMPL_LIM", nameFlags);
MakeRptCmt(0x00016CCE, "Number of short to low tests that make up a sample size.\nUnitless");
MakeNameEx(0x00016CD0, "DG_MAP_KE_MAPD_SHORTED_HIGH_THRESH", nameFlags);
MakeRptCmt(0x00016CD0, "The threshold above which the MAP sensor is considered shorted to a positive voltage.\nPercent");
MakeNameEx(0x00016CD2, "DG_MAP_KE_MAPD_SHORTED_LOW_THRESH", nameFlags);
MakeRptCmt(0x00016CD2, "The threshold below which the MAP sensor is considered opened or shorted to ground.\nPercent");
MakeNameEx(0x00016CD4, "DG_MAP_KE_MAPD_TPS_OVER_RPM_THRESH_MAX", nameFlags);
MakeNameEx(0x00016CD6, "DG_MAP_KE_MAPD_TPS_OVER_RPM_THRESH_MIN", nameFlags);
MakeNameEx(0x00016CD8, "DG_MAP_KE_MAPD_TPS_UNDER_RPM_THRESH_MAX", nameFlags);
MakeNameEx(0x00016CDA, "DG_MAP_KE_MAPD_TPS_UNDER_RPM_THRESH_MIN", nameFlags);
MakeNameEx(0x00016CDC, "DI_MAP_KV_MAPD_COLD_START_RUN_TIME", nameFlags);
MakeRptCmt(0x00016CDC, "The MAP Short to High test will be disabled if the engine run time is less than this calibration.\nSeconds");
MakeNameEx(0x00016CE6, "DI_MAP_KE_MAPD_RAT_DELTA_EGR_POS_MAX", nameFlags);
MakeRptCmt(0x00016CE6, "Maximum EGR flow rate change to still consider conditions stable for MAP rationality.\nPercent");
MakeNameEx(0x00016CE8, "DI_MAP_KE_MAPD_RAT_DELTA_IAC_IDLE_MAX", nameFlags);
MakeRptCmt(0x00016CE8, "Maximum idle air value change to still consider conditions stable for MAP rationality.\nGrams/Second");
MakeNameEx(0x00016CEA, "DI_MAP_KE_MAPD_RAT_DELTA_RPM_MAX", nameFlags);
MakeRptCmt(0x00016CEA, "Maximum engine speed change to still consider conditions stable  for MAP rationality.\nPercent");
MakeNameEx(0x00016CEC, "DI_MAP_KE_MAPD_RAT_DELTA_TPS_MAX", nameFlags);
MakeRptCmt(0x00016CEC, "Maximum throttle position change to still consider conditions stable  for MAP rationality.\nPercent");
MakeNameEx(0x00016CEE, "DI_MAP_KE_MAPD_RAT_RPM_HIGH", nameFlags);
MakeRptCmt(0x00016CEE, "Maximum RPM threshold under which the MAP rationality test can proceed.\nRPM");
MakeNameEx(0x00016CF0, "DI_MAP_KE_MAPD_RAT_RPM_LOW", nameFlags);
MakeRptCmt(0x00016CF0, "Minimum RPM value above which the MAP rationality test can proceed.\nRPM");
MakeNameEx(0x00016CF2, "DI_MAP_KE_MAPD_RAT_STABLE_TIME_MIN", nameFlags);
MakeRptCmt(0x00016CF2, "Minimum stabilization time after the conditions have been met necessary to run the MAP rationality test.\nSeconds");
MakeNameEx(0x00016CF4, "DG_MF_ENGINE_CYCLE_KE_MISF_ABNORMAL_SPEED_OPTION", nameFlags);
MakeRptCmt(0x00016CF4, "Indicates when to analyze the abnormal speed data.\nUnitless");
MakeNameEx(0x00016CF6, "PROTECTED_KE_MISF_ASSEMBLY_PLANT_DELAY", nameFlags);
MakeNameEx(0x00016CF8, "PROTECTED_KE_MISF_BALANCED_TIME_OFFSET", nameFlags);
MakeNameEx(0x00016CF9, "PROTECTED_KE_MISF_CALIBRATE_MODE", nameFlags);
MakeRptCmt(0x00016CF9, "Enables the diagnostic to collect data in both cylinder and revolution mode for development purposes.\nFlag");
MakeNameEx(0x00016CFA, "PROTECTED_KE_MISF_CYL_ABNORMAL_ENGINE_SPD", nameFlags);
MakeRptCmt(0x00016CFA, "Threshold for distinguishing abnormal speed in cylinder mode.\nUnitless");
MakeNameEx(0x00016CFC, "PROTECTED_KE_MISF_IDLE_ENGINE_SPEED", nameFlags);
MakeRptCmt(0x00016CFC, "Maximum engine speed necessary to have abnormal speed detected.\nRPM");
MakeNameEx(0x00016CFE, "PROTECTED_KE_MISF_IDLE_THROTTLE_POSITION", nameFlags);
MakeRptCmt(0x00016CFE, "Maximum throttle position necessary to have abnormal speed detected.\nPercent");
MakeNameEx(0x00016D00, "PROTECTED_KE_MISF_IDLE_VEHICLE_SPEED", nameFlags);
MakeRptCmt(0x00016D00, "Maximum vehicle speed necessary to have abnormal speed detected.\nMPH");
MakeNameEx(0x00016D02, "PROTECTED_KE_MISF_NUMBER_OF_NORMALS_FILTER", nameFlags);
MakeRptCmt(0x00016D02, "Minimum number of normals necessary to reset misfire information.\nUnitless");
MakeNameEx(0x00016D03, "PROTECTED_KE_MISF_OPP_CYL_SINGLE_PEAK", nameFlags);
MakeRptCmt(0x00016D03, "Indicates whether to use the single peak method of analyzing peaks in opposing cylinder mode.\nFlag");
MakeNameEx(0x00016D04, "PROTECTED_KE_MISF_OPP_CYLINDER", nameFlags);
MakeRptCmt(0x00016D04, "Minimum number of misfires necessary to add in the number of misfires detected in opposing cylinder mode.\nUnitless");
MakeNameEx(0x00016D05, "PROTECTED_KE_MISF_REV_ABNORMAL_ENGINE_SPD", nameFlags);
MakeRptCmt(0x00016D05, "Threshold distinguishing abnormal speed in revolution mode.\nUnitless");
MakeNameEx(0x00016D06, "PROTECTED_KE_MISF_REV_MODE_CYLINDER_OFFSET", nameFlags);
MakeRptCmt(0x00016D06, "Compensates for revolution mode phase delay to find proper cylinder which misfired.\nUnitless");
MakeNameEx(0x00016D07, "PROTECTED_KE_MISF_RING_FILTER", nameFlags);
MakeRptCmt(0x00016D07, "Number of engine cycles to ignore due to misfire induced drive train ringing.\nUnitless");
MakeNameEx(0x00016D08, "PROTECTED_KE_MISF_SINGLE_PEAK_REV_METHOD", nameFlags);
MakeRptCmt(0x00016D08, "Indicates whether to use only one cylinder's peak in determining the highest peak of the revolution mode data.\nFlag");
MakeNameEx(0x00016D0A, "PROTECTED_KV_MISF_POWERUP_DELAY", nameFlags);
MakeRptCmt(0x00016D0A, "Number of engine cycles to delay on powerup.\nUnitless");
MakeNameEx(0x00016D12, "PROTECTED_KV_MISF_ZERO_TORQUE_TEMPERATURE", nameFlags);
MakeNameEx(0x00016D24, "DG_MF_REPORTING_KE_MISF_1_CYL_NO_CAT_DAMAGE_LOAD", nameFlags);
MakeRptCmt(0x00016D24, "Identifies the engine load region where a single cylinder misfire cannot cause catalyst damage.\nPercent");
MakeNameEx(0x00016D26, "DG_MF_REPORTING_KE_MISF_1_CYL_NO_CAT_DAMAGE_LVL", nameFlags);
MakeRptCmt(0x00016D26, "The amount of misfire that is needed in a single cylinder to indicate a single cylinder misfire is occurring.\nCounts");
MakeNameEx(0x00016D28, "DG_MF_REPORTING_KE_MISF_1_CYL_NO_CAT_DAMAGE_RPM", nameFlags);
MakeRptCmt(0x00016D28, "Identifies the engine speed region where a single cylinder misfire cannot cause catalyst damage.\nRPM");
MakeNameEx(0x00016D2A, "DG_MF_REPORTING_KE_MISF_ABNORMAL_SPEED_THRESHOLD", nameFlags);
MakeRptCmt(0x00016D2A, "Minimum ratio necessary to detect abnormal speed.\nUnitless");
MakeNameEx(0x00016D2B, "DG_MF_REPORTING_KE_MISF_CATALYST_ARRAY_SIZE", nameFlags);
MakeRptCmt(0x00016D2B, "Determines the number of elements in the Catalyst_Array to consider.\nUnitless");
MakeNameEx(0x00016D2C, "DG_MF_REPORTING_KE_MISF_DETERMINE_MISFIRE_P_CODE", nameFlags);
MakeRptCmt(0x00016D2C, "Maximum value necessary to detect which cylinder is misfiring.\nUnitless");
MakeNameEx(0x00016D2E, "DG_MF_REPORTING_KE_MISF_DFCO_TIME_STOP_MIL_FLASH", nameFlags);
MakeRptCmt(0x00016D2E, "Amount of time engine is in decel fuel cutoff before the Malfunction Indicator Light is forced to stop flashing.\nSeconds");
MakeNameEx(0x00016D30, "DG_MF_REPORTING_KE_MISF_DISABLE_TCC", nameFlags);
MakeRptCmt(0x00016D30, "Maximum value of misfire counts necessary to disable the TCC(Torque Converter Clutch)\nUnitless");
MakeNameEx(0x00016D31, "DG_MF_REPORTING_KE_MISF_EMISSION_ARRAY_SIZE", nameFlags);
MakeRptCmt(0x00016D31, "Determines the number of elements in the Emission_Array to consider.\nUnitless");
MakeNameEx(0x00016D32, "DG_MF_REPORTING_KE_MISF_FLASH_MIL_ENGINE_LOAD", nameFlags);
MakeRptCmt(0x00016D32, "Forces the Malfunction Indicator Light to stop flashing at lower engine loads.\nPercent");
MakeNameEx(0x00016D34, "DG_MF_REPORTING_KE_MISF_FLASH_MIL_LATCH", nameFlags);
MakeNameEx(0x00016D36, "DG_MF_REPORTING_KE_MISF_FLASH_MIL_VEHICLE_SPEED", nameFlags);
MakeRptCmt(0x00016D36, "Forces the Malfunction Indicator Light to stop flashing at lower vehicle speeds.\nMPH");
MakeNameEx(0x00016D38, "DG_MF_REPORTING_KE_MISF_FTP_MAX_ENGINE_LOAD", nameFlags);
MakeNameEx(0x00016D3A, "DG_MF_REPORTING_KE_MISF_FTP_MAX_ENGINE_SPEED", nameFlags);
MakeNameEx(0x00016D3C, "DG_MF_REPORTING_KE_MISF_INDISPUTABLE_MISFIRE", nameFlags);
MakeNameEx(0x00016D3D, "DG_MF_REPORTING_KE_MISF_INITIAL_EMISSION_FACTOR", nameFlags);
MakeNameEx(0x00016D3E, "DG_MF_REPORTING_KE_MISF_MARSHALLING_FACTOR", nameFlags);
MakeRptCmt(0x00016D3E, "Multiplier to increase emission misfire level. This must be set to 1.0, unless prior government approval is received.\nFactor");
MakeNameEx(0x00016D40, "DG_MF_REPORTING_KE_MISF_MARSHALLING_ODOMETER", nameFlags);
MakeRptCmt(0x00016D40, "The distance the vehicle is driven after the assembly plant dynamic vehicle test.\nKilometers");
MakeNameEx(0x00016D42, "DG_MISFIRE_KE_MISF_CYLINDER_MODE_EQUATION", nameFlags);
MakeNameEx(0x00016D43, "DG_MISFIRE_KE_MISF_CONSECUTIVE_NEGATIVE", nameFlags);
MakeRptCmt(0x00016D43, "Minimum number of consecutive cylinder events the engine is accelerating to cause a delay.\nUnitless");
MakeNameEx(0x00016D44, "DG_MISFIRE_KE_MISF_CONSECUTIVE_POSITIVE", nameFlags);
MakeRptCmt(0x00016D44, "Minimum number of consecutive cylinder events the engine is decelerating to cause a delay.\nUnitless");
MakeNameEx(0x00016D46, "DG_EOS_KE_EOSD_ASYMMETRICRATIO_TEST", nameFlags);
MakeRptCmt(0x00016D46, "Determines which response test method is to be used. TRUE = ratio test, FALSE = difference test.\nBoolean");
MakeNameEx(0x00016D48, "DG_EOS_KE_EOSD_OPEN_FAST_PASS_THRESH", nameFlags);
MakeNameEx(0x00016D4A, "DG_EOS_KE_EOSD_OPEN_FP_HIGH_THRESHOLD", nameFlags);
MakeNameEx(0x00016D4C, "DG_EOS_KE_EOSD_OPEN_FP_LOW_THRESHOLD", nameFlags);
MakeNameEx(0x00016D4E, "DG_EOS_KE_EOSD_REL_PE_SENSOR_THRESH", nameFlags);
MakeRptCmt(0x00016D4E, "The related sensor voltage required to allow monitoring of the current sensor during the PE test.\nMillivolts");
MakeNameEx(0x00016D50, "DG_EOS_KE_EOSD_RESP_SAMPLE_TIME_LIM", nameFlags);
MakeRptCmt(0x00016D50, "Amount of time to collect response data.\nMilliseconds");
MakeNameEx(0x00016D52, "DI_AIR_KE_AIRD_FAILED_TEST_MAX", nameFlags);
MakeRptCmt(0x00016D52, "The maximum number of AIR diagnostic test failures required to fail the AIR diagnostic.\nunitless");
MakeNameEx(0x00016D54, "DI_AIR_KE_AIRD_FUEL_TRIM_UPDATE_RATE", nameFlags);
MakeRptCmt(0x00016D54, "The fixed integrator update rate during the Active AIR Injection test.\nSeconds");
MakeNameEx(0x00016D56, "DI_AIR_KE_AIRD_INTAKE_AIR_TEMP_MIN", nameFlags);
MakeRptCmt(0x00016D56, "Minimum intake air temperature threshold to enable the diagnostic.\nDegrees_C");
MakeNameEx(0x00016D58, "DI_AIR_KE_AIRD_NUMBER_OF_O2_MONITORS", nameFlags);
MakeRptCmt(0x00016D58, "The number of O2 sensors that independently receive air injection from the secondary AIR system.\nUnitless");
MakeNameEx(0x00016D5A, "DI_AIR_KV_AIRD_PASV_COLD_LEAN_RATIO", nameFlags);
MakeRptCmt(0x00016D5A, "Minimum value for the O2 lean ratio, to pass part 1 of the passive test, during a cold start.\nRatio");
MakeNameEx(0x00016D5E, "DI_AIR_KV_AIRD_PASV_COLD_LEAN_THRESH", nameFlags);
MakeRptCmt(0x00016D5E, "Maximum threshold value to update the passive lean timer.\nSeconds");
MakeNameEx(0x00016D62, "DI_AIR_KV_AIRD_PASV_COLD_MIN_TIME", nameFlags);
MakeRptCmt(0x00016D62, "Minimum time to calculate a cold and lean ratio for the cold test.\nSeconds");
MakeNameEx(0x00016D66, "DI_AIR_KV_AIRD_PASV_COLD_RICH_RATIO", nameFlags);
MakeRptCmt(0x00016D66, "Maximum value for the O2 rich ratio, to pass part 1 of the passive test, during a cold start.\nRatio");
MakeNameEx(0x00016D6A, "DI_AIR_KV_AIRD_PASV_COLD_RICH_THRESH", nameFlags);
MakeRptCmt(0x00016D6A, "Minimum threshold value to update the passive rich timer.\nVolts");
MakeNameEx(0x00016D6E, "DI_AIR_KV_AIRD_PASV_HOT_LEAN_RATIO", nameFlags);
MakeRptCmt(0x00016D6E, "Minimum value for the O2 lean ratio, to pass part 1 of the passive test, during a hot start.\nRatio");
MakeNameEx(0x00016D72, "DI_AIR_KV_AIRD_PASV_HOT_LEAN_THRESH", nameFlags);
MakeRptCmt(0x00016D72, "Maximum threshold value to update the passive lean timer.\nVolts");
MakeNameEx(0x00016D76, "DI_AIR_KV_AIRD_PASV_HOT_MIN_TIME", nameFlags);
MakeRptCmt(0x00016D76, "Minimum threshold time to calculate a hot and lean ratio for the hot test.\nSeconds");
MakeNameEx(0x00016D7A, "DI_AIR_KV_AIRD_PASV_HOT_RICH_RATIO", nameFlags);
MakeRptCmt(0x00016D7A, "Maximum value for the O2 rich ratio, to pass part1 of the passive test, during a hot start.\nRatio");
MakeNameEx(0x00016D7E, "DI_AIR_KV_AIRD_PASV_HOT_RICH_THRESH", nameFlags);
MakeRptCmt(0x00016D7E, "Minimum threshold value to update the passive rich timer.\nVolts");
MakeNameEx(0x00016D82, "DI_AIR_KE_AIRD_PU_COOLANT_TEMP_MAX", nameFlags);
MakeRptCmt(0x00016D82, "Maximum powerup coolant temperature threshold to enable the diagnostic.\nDegrees_C");
MakeNameEx(0x00016D84, "DI_AIR_KA_AIRD_ACTIVE_FUEL_TRIM_DELTA", nameFlags);
MakeRptCmt(0x00016D84, "Determines the pass/fail thresholds for the fuel trim delta in the AIR diagnostic active test.\nscaler_2");
MakeNameEx(0x00016DAC, "DI_AIR_KA_AIRD_ACTIVE_LEAN_TIMER", nameFlags);
MakeRptCmt(0x00016DAC, "Determines the pass/fail thresholds for the active lean timer in AIR diagnoctic active test.\nseconds");
MakeNameEx(0x00016DC0, "DI_AIR_KE_AIRD_ADAPTIVE_LEARN_TIME_MIN", nameFlags);
MakeNameEx(0x00016DC2, "DI_AIR_KE_AIRD_AIRFLOW_MIN", nameFlags);
MakeRptCmt(0x00016DC2, "Minimum amount of airflow allowed to enable the diagnostic.\ngrams per second");
MakeNameEx(0x00016DC4, "DI_AIR_KE_AIRD_BARO_MIN", nameFlags);
MakeRptCmt(0x00016DC4, "Minimum amount of barometric pressure allowed to enable the diagnostic.\nkPa");
MakeNameEx(0x00016DC6, "DI_AIR_KE_AIRD_COOLANT_TEMP_MAX", nameFlags);
MakeRptCmt(0x00016DC6, "\nDegrees_C");
MakeNameEx(0x00016DC8, "DI_AIR_KE_AIRD_COOLANT_TEMP_MIN", nameFlags);
MakeRptCmt(0x00016DC8, "Minimum coolant temperature threshold to enable the diagnostic.\nDegrees_C");
MakeNameEx(0x00016DCA, "DI_AIR_KE_AIRD_ENGINE_LOAD_MIN", nameFlags);
MakeRptCmt(0x00016DCA, "Minimum engine load threshold to enable the diagnostic.\nPercent");
MakeNameEx(0x00016DCC, "DI_AIR_KE_AIRD_INTAKE_AIR_TEMP_MAX", nameFlags);
MakeRptCmt(0x00016DCC, "Maximum intake air temperature threshold to enable the diagnostic.\nDegrees_C");
MakeNameEx(0x00016DCE, "DI_AIR_KE_AIRD_SYSTEM_VOLTAGE_MIN", nameFlags);
MakeRptCmt(0x00016DCE, "Minimum system voltage threshold to enable the diagnostic.\nVolts");
MakeNameEx(0x00016DCF, "DI_AIR_KE_AIRD_VOLTAGE_LOW_TIME", nameFlags);
MakeRptCmt(0x00016DCF, "Length of time the voltage must stay below the minimum voltage to disable the diagnostic.\nSeconds");
MakeNameEx(0x00016DD0, "DI_AIR_KV_AIRD_ADAPTIVE_INDEX", nameFlags);
MakeRptCmt(0x00016DD0, "The adaptive indices in which the active test may run.\nunitless");
MakeNameEx(0x00016DDA, "DI_AIR_KV_AIRD_SHORT_TERM_FUEL_TRIM", nameFlags);
MakeRptCmt(0x00016DDA, "Frozen rich short term fuel trim value used during the IAR active test in the base pulse width equation.\nunitless");
MakeNameEx(0x00016DDE, "DI_EOS_KE_EOSD_NUMBER_OF_HEATED_SENSORS", nameFlags);
MakeRptCmt(0x00016DDE, "The number of O2 sensors in which the heater test is to be done.\nUnitless");
MakeNameEx(0x00016DDF, "DI_EOS_KE_EOSD_NUMBER_OF_O2_SENSORS", nameFlags);
MakeNameEx(0x00016DE0, "DI_EOS_KE_EOSD_NUMBER_OF_RESP_SENSORS", nameFlags);
MakeNameEx(0x00016DE1, "DI_EOS_KE_EOSD_INTRUSIVE_CNTRL_ENABLE", nameFlags);
MakeRptCmt(0x00016DE1, "This allow EOSD to intrusive control the fuel proportional terms and post O2 min/max limiting.\nBoolean");
MakeNameEx(0x00016DE2, "DI_EOS_KE_EOSD_POST_OXYGEN_OFFSET_MAX", nameFlags);
MakeRptCmt(0x00016DE2, "Limit maximum value of Post Oxygen Threshold Offset.\nMillivolts");
MakeNameEx(0x00016DE4, "DI_EOS_KE_EOSD_POST_OXYGEN_OFFSET_MIN", nameFlags);
MakeRptCmt(0x00016DE4, "Limit minimum value of Post Oxygen Threshold Offset.\nMillivolts");
MakeNameEx(0x00016DE6, "DI_EOS_KE_EOSD_SYSTEM_VOLTAGE_MAX", nameFlags);
MakeRptCmt(0x00016DE6, "Maximum system voltage above which the O2 diag will be disabled.\nVolts");
MakeNameEx(0x00016DE7, "DI_EOS_KE_EOSD_SYSTEM_VOLTAGE_MIN", nameFlags);
MakeRptCmt(0x00016DE7, "Minimum system voltage below which the O2 diag will be disabled.\nVolts");
MakeNameEx(0x00016DE8, "DI_EOS_KV_EOSD_DELTA_TPS_LIMIT", nameFlags);
MakeRptCmt(0x00016DE8, "The change in throttle position required to increment EOSD_Num_Of_Delta_TPS_Changes.\nPercent");
MakeNameEx(0x00016DF0, "DI_EOS_KV_EOSD_DFCO_FAIL_LIMIT", nameFlags);
MakeNameEx(0x00016DF8, "DI_EOS_KV_EOSD_DFCO_SAMPLE", nameFlags);
MakeRptCmt(0x00016DF8, "Number of samples taken to complete a DFCO test assuming the failure threshold has not been reached.\nCounts");
MakeNameEx(0x00016E00, "DI_EOS_KV_EOSD_DFCO_THRESHOLD", nameFlags);
MakeNameEx(0x00016E08, "DI_EOS_KV_EOSD_HEATED_SENSOR_INDEX", nameFlags);
MakeRptCmt(0x00016E08, "A cross reference of heater sensor index to sensor index for heater testing sensor identification.\nUnitless");
MakeNameEx(0x00016E0C, "DI_EOS_KV_EOSD_LEAN_FAIL_DELAY_LIMIT", nameFlags);
MakeRptCmt(0x00016E0C, "Maximum number of times to count while waiting for completion of the related sensors lean test.\nCounts");
MakeNameEx(0x00016E10, "DI_EOS_KV_EOSD_LEAN_FAIL_LIMIT", nameFlags);
MakeRptCmt(0x00016E10, "Maximum times an oxygen sensor can be in a failure region for a given number of samples during the lean test.\nCounts");
MakeNameEx(0x00016E18, "DI_EOS_KV_EOSD_LEAN_LOW_LIMIT", nameFlags);
MakeRptCmt(0x00016E18, "The number of lean failure samples required to set the fault pending flag.\nCounts");
MakeNameEx(0x00016E20, "DI_EOS_KV_EOSD_LEAN_LOW_THRESHOLD", nameFlags);
MakeRptCmt(0x00016E20, "Voltage threshold below which a sensor will be considered to be failed lean for the fault pending criteria.\nMillivolts");
MakeNameEx(0x00016E28, "DI_EOS_KV_EOSD_LEAN_SAMPLE", nameFlags);
MakeRptCmt(0x00016E28, "Number of samples taken to complete a lean test assuming the failure threshold has not been reached.\nCounts");
MakeNameEx(0x00016E30, "DI_EOS_KV_EOSD_LEAN_THRESHOLD", nameFlags);
MakeNameEx(0x00016E38, "DI_EOS_KV_EOSD_NUM_OF_DELTA_TPS_MAX", nameFlags);
MakeRptCmt(0x00016E38, "The number of delta TPS changes required to allow the Open test to report a failure.\nCounts");
MakeNameEx(0x00016E40, "DI_EOS_KV_EOSD_NUM_OF_REL_PE_SENSORS", nameFlags);
MakeRptCmt(0x00016E40, "Number of related PE sensors to check whenever a power enrichment condition is executed.\nUnitless");
MakeNameEx(0x00016E44, "DI_EOS_KV_EOSD_NUM_OF_RELATED_SENSORS", nameFlags);
MakeRptCmt(0x00016E44, "Number of sensors to check whenever a rich or lean condition is suspected.\nUnitless");
MakeNameEx(0x00016E48, "DI_EOS_KV_EOSD_OPEN_FAIL_LIMIT", nameFlags);
MakeNameEx(0x00016E50, "DI_EOS_KV_EOSD_OPEN_HIGH_THRESHOLD", nameFlags);
MakeNameEx(0x00016E58, "DI_EOS_KV_EOSD_OPEN_LOW_THRESHOLD", nameFlags);
MakeNameEx(0x00016E60, "DI_EOS_KV_EOSD_OPEN_SAMPLE", nameFlags);
MakeRptCmt(0x00016E60, "Number of samples taken to complete an open test assuming the failure threshold has not been reached.\nCounts");
MakeNameEx(0x00016E68, "DI_EOS_KV_EOSD_POST_SENSOR_INDEX", nameFlags);
MakeRptCmt(0x00016E68, "A cross-reference of the post O2 sensor index to sensor index for post sensor testing identification.\nUnitsless");
MakeNameEx(0x00016E6A, "DI_EOS_KV_EOSD_POWER_FAIL_LIMIT", nameFlags);
MakeNameEx(0x00016E72, "DI_EOS_KV_EOSD_POWER_SAMPLE", nameFlags);
MakeRptCmt(0x00016E72, "Number of samples taken to complete a power enrichment test assuming the failure threshold has not been reached.\nCounts");
MakeNameEx(0x00016E7A, "DI_EOS_KV_EOSD_POWER_THRESHOLD", nameFlags);
MakeNameEx(0x00016E82, "DI_EOS_KV_EOSD_RELATED_PE_SENSOR_INDEX", nameFlags);
MakeRptCmt(0x00016E82, "A cross-reference of the PE sensor index to the sensor index which serves to identify the specific sensor during PE testing.\nUnitless");
MakeNameEx(0x00016E86, "DI_EOS_KV_EOSD_RELATED_SENSOR_INDEX", nameFlags);
MakeNameEx(0x00016E8A, "DI_EOS_KV_EOSD_RELATED_2ND_SENSOR_INDEX", nameFlags);
MakeNameEx(0x00016E8E, "DI_EOS_KV_EOSD_RESP_HC_LEAN_THRESH", nameFlags);
MakeRptCmt(0x00016E8E, "Threshold which separates normal and lean operating zones using the half cycle time method.\nMillivolts");
MakeNameEx(0x00016E92, "DI_EOS_KV_EOSD_RESP_HC_RICH_THRESH", nameFlags);
MakeRptCmt(0x00016E92, "Threshold which separates normal and rich operating zones using the half cycle time method.\nMillivolts");
MakeNameEx(0x00016E96, "DI_EOS_KV_EOSD_RESP_ST_LEAN_THRESH", nameFlags);
MakeRptCmt(0x00016E96, "Threshold which separates normal and lean operating zones using the slope time method.\nMillivolts");
MakeNameEx(0x00016E9A, "DI_EOS_KV_EOSD_RESP_ST_RICH_THRESH", nameFlags);
MakeRptCmt(0x00016E9A, "Threshold which separates normal and rich operating zones using the slope time method.\nMillivolts");
MakeNameEx(0x00016E9E, "DI_EOS_KV_EOSD_RESP_SENSOR_INDEX", nameFlags);
MakeNameEx(0x00016EA0, "DI_EOS_KV_EOSD_RICH_FAIL_DELAY_LIMIT", nameFlags);
MakeRptCmt(0x00016EA0, "The number of times to count while waiting for completion of the related sensors' rich test.\nCounts");
MakeNameEx(0x00016EA4, "DI_EOS_KV_EOSD_RICH_FAIL_LIMIT", nameFlags);
MakeNameEx(0x00016EAC, "DI_EOS_KV_EOSD_RICH_HIGH_LIMIT", nameFlags);
MakeRptCmt(0x00016EAC, "The number of rich failure samples required to set the fault pending flag.\nCounts");
MakeNameEx(0x00016EB4, "DI_EOS_KV_EOSD_RICH_HIGH_THRESHOLD", nameFlags);
MakeRptCmt(0x00016EB4, "Value above which a sensor will be considered to be failed  rich for the fault pending criteria.\nMillivolts");
MakeNameEx(0x00016EBC, "DI_EOS_KV_EOSD_RICH_SAMPLE", nameFlags);
MakeRptCmt(0x00016EBC, "Number of samples taken to complete a rich test assuming the failure threshold has not been reached.\nCounts");
MakeNameEx(0x00016EC4, "DI_EOS_KV_EOSD_RICH_THRESHOLD", nameFlags);
MakeNameEx(0x00016ECC, "DI_EOS_KV_EOSD_SENSOR_INDEX", nameFlags);
MakeRptCmt(0x00016ECC, "A mapping of sensor names to the sensor index which serves to identify the specific sensor during testing, reporting, etc.\nUnitless");
MakeNameEx(0x00016ED0, "DI_EOS_KV_EOSD_PROP_TERM_NORM_BAS_LEAN", nameFlags);
MakeNameEx(0x00016EE2, "DI_EOS_KV_EOSD_PROP_TERM_NORM_BAS_RICH", nameFlags);
MakeNameEx(0x00016EF4, "DI_EOS_KA_EOSD_ST_LRA_LIM_RS1", nameFlags);
MakeRptCmt(0x00016EF4, "The lean-to-rich average response time (Bank 1 Sensor 1) threshold above which a response time failure will be reported.\nMilliseconds");
MakeNameEx(0x00016F26, "DI_EOS_KA_EOSD_ST_LRA_LIM_RS2", nameFlags);
MakeRptCmt(0x00016F26, "The lean-to-rich average response time (Bank 2 Sensor 1) threshold above which a response time failure will be reported.\nMilliseconds");
MakeNameEx(0x00016F58, "DI_EOS_KA_EOSD_ST_RLA_LIM_RS1", nameFlags);
MakeRptCmt(0x00016F58, "The rich-to-lean average response time threshold (Bank 1 Sensor 1) above which a response time failure will be reported.\nMilliseconds");
MakeNameEx(0x00016F8A, "DI_EOS_KA_EOSD_ST_RLA_LIM_RS2", nameFlags);
MakeRptCmt(0x00016F8A, "The rich-to-lean average response time threshold (Bank 2 Sensor 1) above which a response time failure will be reported.\nMilliseconds");
MakeNameEx(0x00016FBC, "DI_EOS_KE_EOSD_ST_LRS_LIM_RS1", nameFlags);
MakeRptCmt(0x00016FBC, "The number of lean-to-rich switches (Bank 1 Sensor 1) below which a switches failure will be reported.\nUnitless");
MakeNameEx(0x00016FBD, "DI_EOS_KE_EOSD_ST_LRS_LIM_RS2", nameFlags);
MakeRptCmt(0x00016FBD, "The number of lean-to-rich switches (Bank 2 Sensor 1) below which a switches failure will be reported.\nUnitless");
MakeNameEx(0x00016FBE, "DI_EOS_KE_EOSD_ST_RLS_LIM_RS1", nameFlags);
MakeRptCmt(0x00016FBE, "The number of rich-to-lean switches (Bank 1 Sensor 1) below which a switches failure will be reported.\nUnitless");
MakeNameEx(0x00016FBF, "DI_EOS_KE_EOSD_ST_RLS_LIM_RS2", nameFlags);
MakeRptCmt(0x00016FBF, "The number of rich-to-lean switches (Bank 2 Sensor 1) below which a switches failure will be reported.\nUnitless");
MakeNameEx(0x00016FC0, "DI_EOS_KA_EOSD_HC_LRS_LIM_RS1", nameFlags);
MakeRptCmt(0x00016FC0, "The number of lean-to-rich half cycle switches (Bank 1 Sensor 1) below which a switches failure will be reported.\nUnitless");
MakeNameEx(0x00016FF2, "DI_EOS_KA_EOSD_HC_LRS_LIM_RS2", nameFlags);
MakeRptCmt(0x00016FF2, "The number of lean-to-rich half cycle switches (Bank 2 Sensor 1) below which a switches failure will be reported.\nUnitless");
MakeNameEx(0x00017024, "DI_EOS_KA_EOSD_HC_RLS_LIM_RS1", nameFlags);
MakeRptCmt(0x00017024, "The number of rich-to-lean half cycle switches (Bank 1 Sensor 1) below which a switches failure will be reported.\nUnitless");
MakeNameEx(0x00017056, "DI_EOS_KA_EOSD_HC_RLS_LIM_RS2", nameFlags);
MakeRptCmt(0x00017056, "The number of rich-to-lean half cycle switches (Bank 2 Sensor 1) below which a switches failure will be reported.\nUnitless");
MakeNameEx(0x00017088, "DI_EOS_KA_EOSD_ST_RATIO_LOW_LIM_RS1", nameFlags);
MakeNameEx(0x000170BA, "DI_EOS_KA_EOSD_ST_RATIO_LOW_LIM_RS2", nameFlags);
MakeNameEx(0x000170EC, "DI_EOS_KA_EOSD_ST_RATIO_HIGH_LIM_RS1", nameFlags);
MakeNameEx(0x0001711E, "DI_EOS_KA_EOSD_ST_RATIO_HIGH_LIM_RS2", nameFlags);
MakeNameEx(0x00017150, "DI_EOS_KA_EOSD_ST_DIFFLOW_LIM_RS1", nameFlags);
MakeNameEx(0x000171B4, "DI_EOS_KA_EOSD_ST_DIFFLOW_LIM_RS2", nameFlags);
MakeNameEx(0x00017218, "DI_EOS_KA_EOSD_ST_DIFFHIGH_LIM_RS1", nameFlags);
MakeNameEx(0x0001727C, "DI_EOS_KA_EOSD_ST_DIFFHIGH_LIM_RS2", nameFlags);
MakeNameEx(0x000172E0, "DI_EOS_KE_EOSD_CURMON_AIRFLOW_LOW", nameFlags);
MakeRptCmt(0x000172E0, "Minimum airflow value for enabling the oxygen sensor heater current monitor.\nGrams Per Second");
MakeNameEx(0x000172E2, "DI_EOS_KE_EOSD_CURMON_AIRFLOW_HIGH", nameFlags);
MakeRptCmt(0x000172E2, "Maximum airflow value for enabling the oxygen sensor heater current monitor.\nGrams Per Second");
MakeNameEx(0x000172E4, "DI_EOS_KE_EOSD_CURMON_COOLANT_TEMP", nameFlags);
MakeRptCmt(0x000172E4, "Coolant temperature above which the oxygen sensor heater current monitor test will be enabled.\nDegrees_C");
MakeNameEx(0x000172E6, "DI_EOS_KV_EOSD_CURMON_CURRENT_MAX", nameFlags);
MakeNameEx(0x000172EE, "DI_EOS_KV_EOSD_CURMON_CURRENT_MIN", nameFlags);
MakeNameEx(0x000172F6, "DI_EOS_KE_EOSD_CURMON_DELAY_TIMER", nameFlags);
MakeRptCmt(0x000172F6, "The delay time between consecutive oxygen sensor current monitor tests.\nSeconds");
MakeNameEx(0x000172F8, "DI_EOS_KE_EOSD_CURMON_ENABLE_DELAY", nameFlags);
MakeRptCmt(0x000172F8, "The delay time before which the oxygen sensor heater current monitor test will be enabled.\nSeconds");
MakeNameEx(0x000172FA, "DI_EOS_KE_EOSD_CURMON_ENG_RUN_TIME", nameFlags);
MakeRptCmt(0x000172FA, "Engine run time above which the oxygen sensor heater current monitor test will be enabled.\nSeconds");
MakeNameEx(0x000172FC, "DI_EOS_KE_EOSD_CURMON_ENGINE_SPEED_LOW", nameFlags);
MakeRptCmt(0x000172FC, "Minimum engine speed value for enabling the oxygen sensor heater current monitor diagnostic.\nRPM");
MakeNameEx(0x000172FE, "DI_EOS_KE_EOSD_CURMON_ENGINE_SPEED_HIGH", nameFlags);
MakeRptCmt(0x000172FE, "Maximum engine speed value for enabling the oxygen sensor heater current monitor diagnostic.\nRPM");
MakeNameEx(0x00017300, "DI_EOS_KE_EOSD_CURMON_FAIL_LIMIT", nameFlags);
MakeRptCmt(0x00017300, "The number of failure samples required to fail an oxygen sensor heatercurrent monitor test.\nCounts");
MakeNameEx(0x00017302, "DI_EOS_KE_EOSD_CURMON_SAMPLE_LIMIT", nameFlags);
MakeRptCmt(0x00017302, "Number of samples required to complete an oxygen sensor heater current monitor test.\nCounts");
MakeNameEx(0x00017304, "DI_EOS_KE_EOSD_CURMON_TEST_CTR_LIMIT", nameFlags);
MakeRptCmt(0x00017304, "The maximum number of oxygen sensor heater current monitor tests to be run during this key cycle.\nCounts");
MakeNameEx(0x00017306, "DI_EOS_KE_EOSD_FAULTS_THAT_DISABLE", nameFlags);
MakeRptCmt(0x00017306, "If TRUE is specified for the indexed fault group, then any active fault within that group will inhibit the EOSD diagnostic.\nCal_Set_Of_Fault_Group_Type");
MakeNameEx(0x0001730A, "DI_EOS_KE_EOSD_PE_DFCO_RUN_TIME", nameFlags);
MakeRptCmt(0x0001730A, "Engine run time above which the oxygen sensor power enrichment and DFCO tests will be enabled.\nSeconds");
MakeNameEx(0x0001730C, "DI_EOS_KE_EOSD_LEAN_DELAY", nameFlags);
MakeRptCmt(0x0001730C, "Delay time after the lean test enable criteria have been met before starting data collection for lean test.\nSeconds");
MakeNameEx(0x0001730E, "DI_EOS_KE_EOSD_LEANPE_ETHANOL_THRESH", nameFlags);
MakeRptCmt(0x0001730E, "The ethanol percent below which the lean and power enrichment test will be enabled.\nPercent");
MakeNameEx(0x00017310, "DI_EOS_KE_EOSD_LOW_FUEL_DISABLE", nameFlags);
MakeRptCmt(0x00017310, "The fuel levelbelow which certain O2 sensor diagnostics will be disabled\nPercent");
MakeNameEx(0x00017312, "DI_EOS_KE_EOSD_MAX_EQUIVALENCE_RATIO", nameFlags);
MakeRptCmt(0x00017312, "Maximum Equivalence Ratio to enable the lean and rich oxygen sensor range tests.\nRatio");
MakeNameEx(0x00017314, "DI_EOS_KE_EOSD_MIN_EQUIVALENCE_RATIO", nameFlags);
MakeRptCmt(0x00017314, "Minimum Equivalence Ratio to enable the lean and rich oxygen sensor range tests.\nRatio");
MakeNameEx(0x00017316, "DI_EOS_KE_EOSD_O2_DFCO_TEST_ENABLE", nameFlags);
MakeRptCmt(0x00017316, "Used to enable or disable the activation of the O2 DFCO test.\nFlag");
MakeNameEx(0x00017317, "DI_EOS_KE_EOSD_O2_LEAN_TEST_ENABLE", nameFlags);
MakeRptCmt(0x00017317, "Used to enable or disable the activation of the O2 lean test.\nFlag");
MakeNameEx(0x00017318, "DI_EOS_KE_EOSD_O2_OPEN_TEST_ENABLE", nameFlags);
MakeRptCmt(0x00017318, "Used to enable or disable the activation of the O2 open test.\nFlag");
MakeNameEx(0x00017319, "DI_EOS_KE_EOSD_O2_PE_TEST_ENABLE", nameFlags);
MakeRptCmt(0x00017319, "Used to enable or disable the activation of the O2 PE test.\nFlag");
MakeNameEx(0x0001731A, "DI_EOS_KE_EOSD_O2_RESPONSE_TEST_ENABLE", nameFlags);
MakeRptCmt(0x0001731A, "Used to enable or disable the activation of the O2 response test.\nFlag");
MakeNameEx(0x0001731B, "DI_EOS_KE_EOSD_O2_RICH_TEST_ENABLE", nameFlags);
MakeRptCmt(0x0001731B, "Used to enable or disable the activation of the O2 rich test.\nFlag");
MakeNameEx(0x0001731C, "DI_EOS_KE_EOSD_OPEN_ENGINE_RUN_TIME", nameFlags);
MakeRptCmt(0x0001731C, "Minimum engine run time threshold to enable the oxygen sensor range tests.\nSeconds");
MakeNameEx(0x0001731E, "DI_EOS_KE_EOSD_OPEN_ETHANOL_THRESH", nameFlags);
MakeRptCmt(0x0001731E, "The ethanol percent below which the open test will be enabled.\nPercent");
MakeNameEx(0x00017320, "DI_EOS_KE_EOSD_OPEN_FAST_PASS_PERIOD", nameFlags);
MakeRptCmt(0x00017320, "Post catalyst oxygen sensor fast pass period.\nSeconds");
MakeNameEx(0x00017322, "DI_EOS_KE_EOSD_RESP_DELAY_TIME", nameFlags);
MakeRptCmt(0x00017322, "Delay time after the response test enable criteria have been met but before starting data collection for the response test.\nSeconds");
MakeNameEx(0x00017324, "DI_EOS_KE_EOSD_RESP_ENGINE_SPEED_HIGH", nameFlags);
MakeRptCmt(0x00017324, "Maximum engine speed for enabling data collection for the response test.\nRPM");
MakeNameEx(0x00017326, "DI_EOS_KE_EOSD_RESP_ENGINE_SPEED_LOW", nameFlags);
MakeRptCmt(0x00017326, "Mimimum engine speed for enabling data collection for the response test.\nRPM");
MakeNameEx(0x00017328, "DI_EOS_KE_EOSD_RESP_ETHANOL_THRESH", nameFlags);
MakeRptCmt(0x00017328, "The ethanol percent below which the response test will be enabled.\nPercent");
MakeNameEx(0x0001732A, "DI_EOS_KE_EOSD_RESP_FLOW_HIGH", nameFlags);
MakeRptCmt(0x0001732A, "Maximum airflow value for enabling data collection for the response test.\nGPS");
MakeNameEx(0x0001732C, "DI_EOS_KE_EOSD_RESP_FLOW_LOW", nameFlags);
MakeRptCmt(0x0001732C, "Minimum airflow value for enabling data collection for the response test.\nGPS");
MakeNameEx(0x0001732E, "DI_EOS_KE_EOSD_RESP_MIN_COOLANT_TEMP", nameFlags);
MakeRptCmt(0x0001732E, "Minimum coolant temperature threshold required to start data collection for the response test.\nDegrees C");
MakeNameEx(0x00017330, "DI_EOS_KE_EOSD_RESP_MIN_ENGINE_RUN", nameFlags);
MakeRptCmt(0x00017330, "Minimum engine run time threshold required to start data collection for the response test.\nSeconds");
MakeNameEx(0x00017332, "DI_EOS_KE_EOSD_RESP_PURGE_DC_MIN", nameFlags);
MakeRptCmt(0x00017332, "Minimum allowable purge duty cycle threshold which still permits data collection for the response test.\nPercent");
MakeNameEx(0x00017334, "DI_EOS_KE_EOSD_RESP_TPS_MIN", nameFlags);
MakeRptCmt(0x00017334, "Minimum TPS required to enable the response diagnostic.\nPercent");
MakeNameEx(0x00017336, "DI_EOS_KE_EOSD_RICH_DELAY", nameFlags);
MakeRptCmt(0x00017336, "Delay time after the rich test enable criteria have been met before starting data collection for rich test.\nSeconds");
MakeNameEx(0x00017338, "DI_EOS_KE_EOSD_RICHDFCO_ETHANOL_THRESH", nameFlags);
MakeRptCmt(0x00017338, "The ethanol percent below which the rich and decel fuel cutoff test will be enabled.\nPercent");
MakeNameEx(0x0001733A, "DI_EOS_KE_EOSD_RICH_SATURATED_ER", nameFlags);
MakeRptCmt(0x0001733A, "The equivalence ration below which the rich saturation counter of the DFCO test will be incremented.\nRatio");
MakeNameEx(0x0001733C, "DI_EOS_KE_EOSD_SYSTEM_VOLTAGE_TIME", nameFlags);
MakeRptCmt(0x0001733C, "Length of time the voltage must stay below the minimum voltage to disable the O2 diagnostics.\nSeconds");
MakeNameEx(0x0001733E, "DI_EOS_KE_O2_DIAG_COLD_START_AMBIENT", nameFlags);
MakeRptCmt(0x0001733E, "Powerup ambient temperature must be less than this for an O2 diagnostic cold start.\nDegrees_C");
MakeNameEx(0x00017340, "DI_EOS_KE_O2_DIAG_COLD_START_COOLANT", nameFlags);
MakeRptCmt(0x00017340, "Powerup coolant temperature must be less than this for an O2 diagnostic cold start.\nDegrees_C");
MakeNameEx(0x00017342, "DI_EOS_KE_O2_DIAG_COLD_START_DELTA", nameFlags);
MakeNameEx(0x00017344, "DI_EOS_KE_TRANSIENT_TPS_TIME", nameFlags);
MakeRptCmt(0x00017344, "Time that the min and max TPS will be measured over.\nSeconds");
MakeNameEx(0x00017346, "DI_EOS_KE_EOSD_RCOHT_OOR_CHECK_ENABLED", nameFlags);
MakeRptCmt(0x00017346, "Indicates whether reporting of the RCOHT limit part learn out of range check is enabled.\nBOOLEAN");
MakeNameEx(0x00017348, "DI_EOS_KV_EOSD_O2_HTR_TEMPERATURE_MIN", nameFlags);
MakeRptCmt(0x00017348, "The front O2 heaters must be below this value to allow the response diagnostic to be enabled.\nDegrees_C");
MakeNameEx(0x00017350, "DI_EOS_KV_EOSD_O2_HTR_TEMPERATURE_MAX", nameFlags);
MakeRptCmt(0x00017350, "\n");
MakeNameEx(0x00017358, "DI_EOS_KV_EOSD_DFCO_DELAY", nameFlags);
MakeRptCmt(0x00017358, "Delay time after the DFCO test enable criteria have been met before starting data collection for the DFCO test.\nSeconds");
MakeNameEx(0x00017360, "DI_EOS_KV_EOSD_LEAN_THROTTLE_LOW", nameFlags);
MakeRptCmt(0x00017360, "Minimum TPSThreshold below which the lean test will be disabled.\nPercent");
MakeNameEx(0x00017368, "DI_EOS_KV_EOSD_LEAN_THROTTLE_HIGH", nameFlags);
MakeRptCmt(0x00017368, "Maximum TPSThreshold above which the lean test will be disabled.\nPercent");
MakeNameEx(0x00017370, "DI_EOS_KV_EOSD_POWER_DELAY", nameFlags);
MakeRptCmt(0x00017370, "Delay time after the PE test enable criteria have been met before starting data collection for the PE test.\nSeconds");
MakeNameEx(0x00017378, "DI_EOS_KV_EOSD_RICH_THROTTLE_LOW", nameFlags);
MakeRptCmt(0x00017378, "Minimum TPSThreshold below which the rich test will be disabled.\nPercent");
MakeNameEx(0x00017380, "DI_EOS_KV_EOSD_RICH_THROTTLE_HIGH", nameFlags);
MakeRptCmt(0x00017380, "Maximum TPSThreshold above which the rich test will be disabled.\nPercent");
MakeNameEx(0x00017388, "DG_ODM_KE_OUTPUT_DRIVER_ENGINE_SPEED_TH", nameFlags);
MakeRptCmt(0x00017388, "Above this speed, output driver diagnostics may be enabled.\nRPM");
MakeNameEx(0x0001738A, "DG_ODM_KV_SIDM_FAIL_COUNTER", nameFlags);
MakeNameEx(0x000173A0, "DG_ODM_KV_SIDM_SAMPLE_COUNTER", nameFlags);
MakeNameEx(0x000173B6, "DG_ODM_KV_ODM_FAIL_COUNTER", nameFlags);
MakeNameEx(0x000173BC, "DG_ODM_KV_ODM_SAMPLE_COUNTER", nameFlags);
MakeNameEx(0x000173C2, "DG_ODM_KV_MFD1_FAIL_COUNTER", nameFlags);
MakeNameEx(0x000173C6, "DG_ODM_KV_MFD1_SAMPLE_COUNTER", nameFlags);
MakeNameEx(0x000173C9, "DG_ODM_KE_TFD_FAIL_COUNTER", nameFlags);
MakeRptCmt(0x000173C9, "This is the fail counter cal for TFD diagnostics.\nSHORTCARD");
MakeNameEx(0x000173CA, "DG_ODM_KE_TFD_SAMPLE_COUNTER", nameFlags);
MakeRptCmt(0x000173CA, "This is the pass counter cal for TFD diagnostics.\nSHORTCARD");
MakeNameEx(0x000173CC, "DG_POS_KE_POSD_STAGE2_ENABLE_TIME_MIN", nameFlags);
MakeNameEx(0x000173CE, "DI_POS_KE_POSD_NUM_OF_POST_O2_SENSORS", nameFlags);
MakeRptCmt(0x000173CE, "The number of post catalyst oxygen sensors in the system.\nUnitless");
MakeNameEx(0x000173D0, "DI_POS_KV_POSD_LEAN_TIMER", nameFlags);
MakeRptCmt(0x000173D0, "The amount of time to wait during the lean intrusive test before considering the sensor failed.\nSeconds");
MakeNameEx(0x000173D6, "DI_POS_KV_POSD_POST_O2_LEAN_THRESHOLD", nameFlags);
MakeRptCmt(0x000173D6, "The voltage threshold below which the post catalyst oxygen sensor is considered to be in a lean state.\nMillivolts");
MakeNameEx(0x000173DA, "DI_POS_KV_POSD_POST_O2_RICH_THRESHOLD", nameFlags);
MakeRptCmt(0x000173DA, "The voltage threshold above which the post catalyst oxygen sensor is considered to be in a rich state.\nMillivolts");
MakeNameEx(0x000173DE, "DI_POS_KV_POSD_PRE_O2_LEAN_THRESHOLD", nameFlags);
MakeRptCmt(0x000173DE, "The voltage threshold below which the pre-catalyst oxygen sensor is considered to be in a lean state.\nMillivolts");
MakeNameEx(0x000173E2, "DI_POS_KV_POSD_PRE_O2_RICH_THRESHOLD", nameFlags);
MakeRptCmt(0x000173E2, "The voltage threshold above which the pre-catalyst oxygen sensor is considered to be in a rich state.\nMillivolts");
MakeNameEx(0x000173E6, "DI_POS_KV_POSD_RICH_TIMER", nameFlags);
MakeRptCmt(0x000173E6, "The amount of time to wait during the rich intrusive test before considering the sensor failed.\nSeconds");
MakeNameEx(0x000173EC, "DI_POS_KE_POSD_ENGINE_AIRFLOW_MAX", nameFlags);
MakeRptCmt(0x000173EC, "The maximum engine airflow above which the intrusive test is disabled.\nGrams_Per_Second");
MakeNameEx(0x000173EE, "DI_POS_KE_POSD_ENGINE_AIRFLOW_MIN", nameFlags);
MakeRptCmt(0x000173EE, "The minimum engine airflow below which the intrusive test is disabled.\nGrams_Per_Second");
MakeNameEx(0x000173F0, "DI_POS_KE_POSD_ENGINE_RUN_TIME_MIN", nameFlags);
MakeRptCmt(0x000173F0, "Minimum engine running time before the time activated processes are run.\nSeconds");
MakeNameEx(0x000173F2, "DI_POS_KE_POSD_ENGINE_SPEED_MAX", nameFlags);
MakeRptCmt(0x000173F2, "The maximum engine speed above which the intrusive test is disabled.\nRPM");
MakeNameEx(0x000173F4, "DI_POS_KE_POSD_ENGINE_SPEED_MIN", nameFlags);
MakeRptCmt(0x000173F4, "The minimum engine speed below which the intrusive test is disabled.\nRPM");
MakeNameEx(0x000173F6, "DI_POS_KE_POSD_LEAN_EQUIV_RATIO", nameFlags);
MakeRptCmt(0x000173F6, "The A/F commanded  adjustment requested to force the fuel system lean during the intrusive test.\n0 - 32");
MakeNameEx(0x000173F8, "DI_POS_KE_POSD_NUM_STAGE2_TESTS", nameFlags);
MakeRptCmt(0x000173F8, "The maximum number of intrusive tests to run during any one trip.\nSHORTCARD");
MakeNameEx(0x000173F9, "DI_POS_KE_POSD_NUMBER_OF_POST_LTM_CELLS", nameFlags);
MakeRptCmt(0x000173F9, "The number of adaptive (block learn) cells that can be configured to enable the response diagnostic in specific adaptive cells.\nSHORTCARD");
MakeNameEx(0x000173FA, "DI_POS_KE_POSD_RICH_EQUIV_RATIO", nameFlags);
MakeRptCmt(0x000173FA, "The A/F commanded  adjustment requested to force the fuel system rich during the intrusive test.\n0 - 32");
MakeNameEx(0x000173FC, "DI_POS_KE_POSD_STAGE2_STABILIZATION_MIN", nameFlags);
MakeRptCmt(0x000173FC, "The minimum amount of time required for the system criteria to be stabilized before executing intrusive tests.\nSeconds");
MakeNameEx(0x000173FE, "DI_POS_KE_POSD_STAGE2_TEST_ORDER", nameFlags);
MakeRptCmt(0x000173FE, "Determines if the fuel control will be commanded rich-to-lean or leasn-to-rich during the intrusive test.\nTest Order Type");
MakeNameEx(0x00017400, "DI_POS_KE_POSD_VEHICLE_SPEED_MAX", nameFlags);
MakeRptCmt(0x00017400, "The maximum vehicle speed above which the intrusive test is disabled.\nMPH");
MakeNameEx(0x00017402, "DI_POS_KE_POSD_VEHICLE_SPEED_MIN", nameFlags);
MakeRptCmt(0x00017402, "The minimum vehicle speed below which the intrusive test is disabled.\nMPH");
MakeNameEx(0x00017404, "DI_POS_KV_POSD_CL_SHORT_TERM_INT_MAX", nameFlags);
MakeRptCmt(0x00017404, "Maximum short term integrator value above which the intrusive portion of the test will be disabled.\n0 - 2");
MakeNameEx(0x00017406, "DI_POS_KV_POSD_CL_SHORT_TERM_INT_MIN", nameFlags);
MakeRptCmt(0x00017406, "Minimum short term integrator value below which the intrusive portion of the test will be disabled.\n0 - 2");
MakeNameEx(0x00017408, "DI_POS_KV_POSD_POST_CELL_ENABLE", nameFlags);
MakeRptCmt(0x00017408, "A table of adaptive (block learn) cells in which to enable the post oxygen sensor tests.\nUnitless");
MakeNameEx(0x00017420, "DG_TPS_KE_TPSD_INT_SHORT_HIGH_FAIL_LIM", nameFlags);
MakeRptCmt(0x00017420, "Number of failed intermittent short to high tests within a sample size that will report a failure.\nFailures");
MakeNameEx(0x00017422, "DG_TPS_KE_TPSD_INT_SHORT_HIGH_SMPL_LIM", nameFlags);
MakeRptCmt(0x00017422, "Number of intermittent short to high tests that make up a sample size.\nSamples");
MakeNameEx(0x00017424, "DG_TPS_KE_TPSD_INT_SHORT_LOW_FAIL_LIM", nameFlags);
MakeRptCmt(0x00017424, "Number of failed intermittent short to low tests within a sample size that will report a failure.\nFailures");
MakeNameEx(0x00017426, "DG_TPS_KE_TPSD_INT_SHORT_LOW_SMPL_LIM", nameFlags);
MakeRptCmt(0x00017426, "Number of intermittent short to low tests that make up a sample size.\nSamples");
MakeNameEx(0x00017428, "DG_TPS_KE_TPSD_RAT_ECT_MIN", nameFlags);
MakeRptCmt(0x00017428, "The coolant value above which the TPS rationality diagnostic can be enabled.\nDegrees C");
MakeNameEx(0x0001742A, "DG_TPS_KE_TPSD_RAT_ENG_RUN_TIME_MIN", nameFlags);
MakeRptCmt(0x0001742A, "Ensures that the engine has reached stable operating conditions before enabling the TPS rationality diagnostic\nSeconds");
MakeNameEx(0x0001742C, "DG_TPS_KE_TPSD_RAT_FAIL_LIM", nameFlags);
MakeRptCmt(0x0001742C, "Number of rationality failed tests within a sample size that  will report a failure.\nFailures");
MakeNameEx(0x0001742E, "DG_TPS_KE_TPSD_RAT_HIGH_MAP", nameFlags);
MakeRptCmt(0x0001742E, "Maximum MAP for TPS to be checked for rationality high failures.\nkPa");
MakeNameEx(0x00017430, "DG_TPS_KE_TPSD_RAT_LOW_MAP", nameFlags);
MakeRptCmt(0x00017430, "Minimum MAP for TPS to be checked for rationality low failures.\nkPa");
MakeNameEx(0x00017432, "DG_TPS_KE_TPSD_RAT_MAP_DELTA_MAX", nameFlags);
MakeRptCmt(0x00017432, "Maximum allowable MAP Delta over a test interval which can enable the TPS rationality diagnostic\nkPa");
MakeNameEx(0x00017434, "DG_TPS_KE_TPSD_RAT_MAP_STABLE_TIME", nameFlags);
MakeRptCmt(0x00017434, "Minimum amount of time the delta MAP value must stay stable to enable the TPS rationality test.\nSeconds");
MakeNameEx(0x00017436, "DG_TPS_KE_TPSD_RAT_SMPL_LIM", nameFlags);
MakeRptCmt(0x00017436, "Number of rationality tests that make up a sample size.\nSamples");
MakeNameEx(0x00017438, "DG_TPS_KE_TPSD_SHORT_HIGH_FAIL_LIM", nameFlags);
MakeRptCmt(0x00017438, "Number ofNumber of failed short to high tests within a sample size that will report a failure.\nFailures");
MakeNameEx(0x0001743A, "DG_TPS_KE_TPSD_SHORT_HIGH_SMPL_LIM", nameFlags);
MakeRptCmt(0x0001743A, "Number of short to high tests that make up a sample size.\nSamples");
MakeNameEx(0x0001743C, "DG_TPS_KE_TPSD_SHORT_LOW_FAIL_LIM", nameFlags);
MakeRptCmt(0x0001743C, "Number of short to low tests that make up a sample size.\nSamples");
MakeNameEx(0x0001743E, "DG_TPS_KE_TPSD_SHORT_LOW_SMPL_LIM", nameFlags);
MakeRptCmt(0x0001743E, "\n");
MakeNameEx(0x00017440, "DG_TPS_KE_TPSD_SHORTED_HIGH_THRESH", nameFlags);
MakeRptCmt(0x00017440, "The threshold below which the throttle position sensor is considered opened or shorted to ground.\nPercent");
MakeNameEx(0x00017442, "DG_TPS_KE_TPSD_SHORTED_LOW_THRESH", nameFlags);
MakeRptCmt(0x00017442, "\n");
MakeNameEx(0x00017444, "DG_TPS_KV_TPSD_PREDICTED_TPS_HIGH_TEST", nameFlags);
MakeRptCmt(0x00017444, "A predicted TPS value based on RPM for the stuck high test.\nPercent");
MakeNameEx(0x00017464, "DG_TPS_KV_TPSD_PREDICTED_TPS_LOW_TEST", nameFlags);
MakeRptCmt(0x00017464, "A predicted TPS value based on RPM for the stuck low test.\nPercent");
MakeNameEx(0x00017484, "DG_VOLT_KE_IGN_VOLT_LOW_ENGINE_RUN_TIME", nameFlags);
MakeRptCmt(0x00017484, "Engine run time which must be exceeded to test code 562.\nSeconds");
MakeNameEx(0x00017488, "DG_VOLT_KE_IGN_VOLT_LOW_ENGINE_SPEED", nameFlags);
MakeRptCmt(0x00017488, "Minimum engine speed below which code 562 will not test.\nRPM");
MakeNameEx(0x0001748A, "DG_VOLT_KE_IGN_VOLT_LOW_VEHICLE_SPEED", nameFlags);
MakeRptCmt(0x0001748A, "Minimum vehicle speed below which code 562 will not test.\nMPH");
MakeNameEx(0x0001748C, "DG_VOLT_KE_IGN_VOLTAGE_HIGH", nameFlags);
MakeRptCmt(0x0001748C, "Ignition voltage above which failure conditions have been met, and the Fail counter will be incremented.\nVolts");
MakeNameEx(0x0001748E, "DG_VOLT_KE_IGN_VOLTAGE_HIGH_FAIL_COUNT", nameFlags);
MakeRptCmt(0x0001748E, "Fail counter above which code 563 will be set.\nCounts");
MakeNameEx(0x0001748F, "DG_VOLT_KE_IGN_VOLTAGE_HIGH_SAMPLE_COUNT", nameFlags);
MakeRptCmt(0x0001748F, "Sample counter above which a pass will be indicated if Fail counter is not exceeded.\nCounts");
MakeNameEx(0x00017490, "DG_VOLT_KE_IGN_VOLTAGE_LOW", nameFlags);
MakeRptCmt(0x00017490, "Ignition voltage below which failure conditions have been met and the Fail Counter will be incremented.\nVolts");
MakeNameEx(0x00017492, "DG_VOLT_KE_IGN_VOLTAGE_LOW_FAIL_COUNT", nameFlags);
MakeRptCmt(0x00017492, "Fail counter above which code 562 will be set.\nCounts");
MakeNameEx(0x00017493, "DG_VOLT_KE_IGN_VOLTAGE_LOW_SAMPLE_COUNT", nameFlags);
MakeRptCmt(0x00017493, "Sample counter above which a pass will be indicated if Fail counter is not exceeded.\nCounts");
MakeNameEx(0x00017494, "DG_VOLT_KE_V5B1_VOLTAGE_FAULT_TIMER", nameFlags);
MakeRptCmt(0x00017494, "Time that V5B1 voltage has to be wrong for a fault to set.\nSeconds");
MakeNameEx(0x00017496, "DG_VOLT_KE_V5B2_VOLTAGE_FAULT_TIMER", nameFlags);
MakeRptCmt(0x00017496, "Time that V5B2 voltage has to be wrong for a fault to set.\nSeconds");
MakeNameEx(0x00017498, "DI_CASE_KE_CASE_FUEL_CUTOFF_THRESHOLD", nameFlags);
MakeRptCmt(0x00017498, "Threshold above which fuel will be cut off to all cylinders.\nRPM");
MakeNameEx(0x0001749A, "DI_CASE_KE_CASE_ETC_ENG_SPD_LIMIT_OFFSET", nameFlags);
MakeRptCmt(0x0001749A, "RPM above the KE_CASE_Fuel_Cutoff_Threshold which the ETC governor will limit engine speed to when CASE learn is in progress.\nRPM");
MakeNameEx(0x0001749C, "DI_CASE_KE_CASE_LOWER_RPM_THRESHOLD", nameFlags);
MakeRptCmt(0x0001749C, "Engine speed below which crank error data collection and intrusive fuel control are disabled.\nRPM");
MakeNameEx(0x0001749E, "DI_CASE_KE_CASE_UPPER_RPM_THRESHOLD", nameFlags);
MakeRptCmt(0x0001749E, "Engine speed at which to begin the crank error calculation.\nRPM");
MakeNameEx(0x000174A0, "DI_CASE_KE_CASE_ENGINE_SPEED_HYSTERESIS", nameFlags);
MakeRptCmt(0x000174A0, "Engine speed hysteresis for enabling crank error learning.\nRPM");
MakeNameEx(0x000174A2, "DI_CASE_KE_CASE_COOLANT_TEMP_ENABLE", nameFlags);
MakeRptCmt(0x000174A2, "Minimum coolant temperature to allow learning of Crank Angle Sensing Error.\nDegrees_");
MakeNameEx(0x000174A4, "DI_CASE_KE_CASE_ATTEMPTS_TO_LEARN_MAX", nameFlags);
MakeRptCmt(0x000174A4, "Maximum number of times the system will attempt to learn the crank errors in one key cycle.\nCounts");
MakeNameEx(0x000174A6, "DI_ECTR_KV_ECTR_ETH_COMPENSATION", nameFlags);
MakeRptCmt(0x000174A6, "Modifies the total air threshold for variations in the ethanol composition.\nMult_0to2");
MakeNameEx(0x000174B0, "DI_ECTR_KE_ECTR_NUM_OF_TEMP_TESTS", nameFlags);
MakeRptCmt(0x000174B0, "The number of rationality tests or stabilized engine coolant temperature levels that will be checked.\nUnitless");
MakeNameEx(0x000174B2, "DI_ECTR_KV_ECTR_MIN_STABILIZED_ECT_TEMP", nameFlags);
MakeRptCmt(0x000174B2, "Minimum coolant temperature value to be considered passing the associated rationality test.\nDegrees_C");
MakeNameEx(0x000174B6, "DI_ECTR_KV_ECTR_DTCS", nameFlags);
MakeRptCmt(0x000174B6, "Defines the fault code associated with the rationality test index.\nPCodes");
MakeNameEx(0x000174BA, "DI_ECTR_KA_ECTR_TTL_AIR_GRAMS_AT_PWRUP", nameFlags);
MakeRptCmt(0x000174BA, "Power up coolant temperature-related portion of the calculated minimum total air threshold.\nGramsOfAir");
MakeNameEx(0x000174E6, "DI_ECTR_KV_ECTR_MIN_TRIP_DISTANCE", nameFlags);
MakeNameEx(0x000174EA, "DI_ECTR_KV_ECTR_HEAT_LOSS_COEF", nameFlags);
MakeRptCmt(0x000174EA, "Used to calculate the heat loss portion of the minimum total air threshold.\nGramsOfAir");
MakeNameEx(0x000174EC, "DI_ECTR_KV_ECTR_MAX_POWERUP_ECT", nameFlags);
MakeRptCmt(0x000174EC, "Maximum powerup coolant temperature value that will enable the associated rationality test.\nDegrees_C");
MakeNameEx(0x000174F0, "DI_ECTR_KV_ECTR_MIN_AIR_GRAMS_PER_SEC", nameFlags);
MakeRptCmt(0x000174F0, "Minimum average engine airflow rate to renable reporting a failure condition.\nGramsPerSec");
MakeNameEx(0x000174F4, "DI_EGRQ_KV_EGRF_ETH_COMP_MULTIPLIER", nameFlags);
MakeRptCmt(0x000174F4, "Compensation factor to modify the expected MAP change based on ethanol content.\nMult_0to2");
MakeNameEx(0x000174FE, "DI_EGRQ_KE_EGR_HS_POSITION_FILTER", nameFlags);
MakeRptCmt(0x000174FE, "First order filter coefficient for percent pintle opening during EGRF high speed mode.\nSeconds");
MakeNameEx(0x00017500, "DI_EGRQ_KA_EGRF_MNRPM_MAP_CHANGE_THRESH", nameFlags);
MakeNameEx(0x00017584, "DI_EGRQ_KA_EGRF_STRPM_MAP_CHANGE_THRESH", nameFlags);
MakeNameEx(0x000175EA, "DI_EGRQ_KE_EGRF_RPM_OFFSET", nameFlags);
MakeRptCmt(0x000175EA, "Used in defining the RPM range for KA_EGRF_StRPM_MAP_ Change_Thresh and KA_EGRF_MnRPM_MAP_Change_Thresh.\nRPM");
MakeNameEx(0x000175EC, "DI_EGRQ_KE_EGRF_STARTED_TIME", nameFlags);
MakeRptCmt(0x000175EC, "Amount of time the test is in the TEST_STARTED mode.\nSeconds");
MakeNameEx(0x000175EE, "DI_EGRQ_KE_EGRF_ETHANOL_DISABLE_PERCENT", nameFlags);
MakeRptCmt(0x000175EE, "The ethanol percentage at which the EGR diagnostic will be disabled.\nPercent");
MakeNameEx(0x000175F0, "DI_EGRQ_KE_EGRF_DFCO_STABLE_TIME", nameFlags);
MakeRptCmt(0x000175F0, "Minimum amount of time since a DFCO change before EGR considers DFCO stable.\nSeconds");
MakeNameEx(0x000175F2, "DI_EGRQ_KE_EGRF_VEHICLE_SPEED_MAXIMUM", nameFlags);
MakeRptCmt(0x000175F2, "Maximum vehicle speed allowed to run test.\nMPH");
MakeNameEx(0x000175F4, "DI_EGRQ_KE_EGRF_VEHICLE_SPEED_MINIMUM", nameFlags);
MakeRptCmt(0x000175F4, "Minimum vehicle speed allowed to run test.\nMPH");
MakeNameEx(0x000175F6, "DI_EGRQ_KE_EGRF_ENGINE_STALL_RPM", nameFlags);
MakeRptCmt(0x000175F6, "Minimum engine speed allowed to run test.\nRPM");
MakeNameEx(0x000175F8, "DI_EGRQ_KE_EGRF_COOLANT_TEMP_MAXIMUM", nameFlags);
MakeRptCmt(0x000175F8, "Maximum coolant temperature allowed to run test.\nDegrees C");
MakeNameEx(0x000175FA, "DI_EGRQ_KE_EGRF_COOLANT_TEMP_MINIMUM", nameFlags);
MakeRptCmt(0x000175FA, "Minimum coolant temperature allowed to run test.\nDegrees C");
MakeNameEx(0x000175FC, "DI_EGRQ_KE_EGRF_IAT_MAXIMUM", nameFlags);
MakeRptCmt(0x000175FC, "Maximum vehicle manifold air temperature allowed to run test\nDegrees C");
MakeNameEx(0x000175FE, "DI_EGRQ_KE_EGRF_IAT_MINIMUM", nameFlags);
MakeRptCmt(0x000175FE, "Minimum vehicle manifold air temperature allowed to run test\nDegrees C");
MakeNameEx(0x00017600, "DI_EGRQ_KE_EGRF_IGNITION_VOLTAGE_MAX", nameFlags);
MakeRptCmt(0x00017600, "Maximum ignition voltage allowed to run test.\nVolts");
MakeNameEx(0x00017602, "DI_EGRQ_KE_EGRF_IGNITION_VOLTAGE_MIN", nameFlags);
MakeRptCmt(0x00017602, "Minimum ignition voltage allowed to run test.\nVolts");
MakeNameEx(0x00017604, "DI_EGRQ_KE_EGRF_IAC_POSITION_DELTA_MAX", nameFlags);
MakeRptCmt(0x00017604, "Maximum changes of IAC steps allowed while common enableconditions are met.\nSteps");
MakeNameEx(0x00017606, "DI_EGRQ_KE_EGRF_IDLE_AREA_DELTA_MAX", nameFlags);
MakeRptCmt(0x00017606, "Maximum changes of IAC area for ETC allowed while common enableconditions are met.\nMillimeters_Squared");
MakeNameEx(0x00017608, "DI_EGRQ_KE_EGRF_PURGE_FREEZE", nameFlags);
MakeRptCmt(0x00017608, "Indication of desire to freeze the purge duty cycle duringcertain test intervals.\nTRUE/FALSE");
MakeNameEx(0x0001760A, "DI_EGRQ_KV_EGRF_DUTY_CYCLE", nameFlags);
MakeRptCmt(0x0001760A, "The desired EGR duty cycle value.\nPercent");
MakeNameEx(0x0001762A, "DI_FUEL_TRIM_KV_FTRM_LONG_TERM_IDLE_COEFF", nameFlags);
MakeRptCmt(0x0001762A, "Coefficient applied to each 'Idle' Long Term Target used FOR this diagnostic.\nNONE 0-2");
MakeNameEx(0x0001762C, "DI_FUEL_TRIM_KA_FTRM_LONG_TERM_OFF_IDLE_COEFF", nameFlags);
MakeRptCmt(0x0001762C, "Coefficient applied to each 'Off-Idle' Long Term Target used FOR this diagnostic.\nNONE 0-2");
MakeNameEx(0x0001764C, "DI_FUEL_TRIM_KE_FTRM_NUMBER_OF_OFF_IDLE_CELLS", nameFlags);
MakeRptCmt(0x0001764C, "Number of 'Off Idle' cells used in this diagnostic.\nCells");
MakeNameEx(0x0001764E, "DI_FUEL_TRIM_KV_FTRM_OFF_IDLE_CELLS_TO_AVG", nameFlags);
MakeRptCmt(0x0001764E, "Indicates for which Adaptive Regions to use the Long Term Target for this diagnostic.\nRegion");
MakeNameEx(0x0001765E, "DI_FUEL_TRIM_KE_FTRM_ENABLE_PLM_MODIFIER", nameFlags);
MakeRptCmt(0x0001765E, "Used as a modifier to the PLM multiplier for FTRM diagnostics.\n0_to_1");
MakeNameEx(0x00017660, "DI_FUEL_TRIM_KE_FTRM_NUMBER_OF_IDLE_CELLS", nameFlags);
MakeRptCmt(0x00017660, "Number of Idle Cells the system is calibrated to use FOR this diagnostic.\nCells");
MakeNameEx(0x00017662, "DI_FUEL_TRIM_KV_FTRM_IDLE_CELLS_TO_AVG", nameFlags);
MakeRptCmt(0x00017662, "Indicates for which adaptive regions the Long Term Target should be used for this diagnostic.\nRegion");
MakeNameEx(0x0001766A, "DI_FUEL_TRIM_KE_FTRM_DEFAULT_IDLE_CELL", nameFlags);
MakeRptCmt(0x0001766A, "Initialize idle fuel trim data to that indicated in this region.\nRegion");
MakeNameEx(0x0001766C, "DI_FUEL_TRIM_KE_FTRM_DIAG_INHIBITING_FAULTS", nameFlags);
MakeRptCmt(0x0001766C, "If TRUE is specified for the indexed fault group, then any active fault within that group will inhibit FTRM diagnostic.\nBoolean");
MakeNameEx(0x00017670, "DI_FUEL_TRIM_KE_FTRM_COOLANT_TEMP_LOW", nameFlags);
MakeRptCmt(0x00017670, "Coolant temperature must be > this to enable diagnostic.\nDegrees_C");
MakeNameEx(0x00017672, "DI_FUEL_TRIM_KE_FTRM_COOLANT_TEMP_HIGH", nameFlags);
MakeRptCmt(0x00017672, "Coolant temperature must be < this to enable diagnostic.\nDegrees_C");
MakeNameEx(0x00017674, "DI_FUEL_TRIM_KE_FTRM_MAT_LOW", nameFlags);
MakeRptCmt(0x00017674, "Manifold air temperature must be > this to enable diagnostic.\nDegrees_C");
MakeNameEx(0x00017676, "DI_FUEL_TRIM_KE_FTRM_MAT_HIGH", nameFlags);
MakeRptCmt(0x00017676, "Manifold air temperature must be < this to enable diagnostic.\nDegrees_C");
MakeNameEx(0x00017678, "DI_FUEL_TRIM_KE_FTRM_MAP_LOW", nameFlags);
MakeRptCmt(0x00017678, "Manifold absolute pressure must be > this to enable diagnostic.\nkPa");
MakeNameEx(0x0001767A, "DI_FUEL_TRIM_KE_FTRM_MAP_HIGH", nameFlags);
MakeRptCmt(0x0001767A, "Manifold absolute pressure must be < this to enable diagnostic.\nkPa");
MakeNameEx(0x0001767C, "DI_FUEL_TRIM_KE_FTRM_ENGINE_AIR_FLOW_LOW", nameFlags);
MakeRptCmt(0x0001767C, "Engine air flow must be > this to enable diagnostic.\ngm/s");
MakeNameEx(0x0001767E, "DI_FUEL_TRIM_KE_FTRM_ENGINE_AIR_FLOW_HIGH", nameFlags);
MakeRptCmt(0x0001767E, "Engine air flow must be < this to enable diagnostic.\ngm/s");
MakeNameEx(0x00017680, "DI_FUEL_TRIM_KE_FTRM_PURGE_TEST_TMR_OFFSET_DC", nameFlags);
MakeNameEx(0x00017682, "DI_FUEL_TRIM_KE_FTRM_RPM_LOW", nameFlags);
MakeRptCmt(0x00017682, "Engine speed must be > this to enable diagnostic.\nRPM");
MakeNameEx(0x00017684, "DI_FUEL_TRIM_KE_FTRM_RPM_HIGH", nameFlags);
MakeRptCmt(0x00017684, "Engine speed must be < this to enable diagnostic.\nRPM");
MakeNameEx(0x00017686, "DI_FUEL_TRIM_KE_FTRM_VEHICLE_SPEED_HIGH", nameFlags);
MakeRptCmt(0x00017686, "Vehicle speed must be < this to enable diagnostic.\nMPH");
MakeNameEx(0x00017688, "DI_FUEL_TRIM_KE_FTRM_TPS_HIGH", nameFlags);
MakeRptCmt(0x00017688, "Throttle position (opening) must be < this to enable diagnostic.\nPercent");
MakeNameEx(0x0001768A, "DI_FUEL_TRIM_KE_FTRM_BAROMETER_LOW", nameFlags);
MakeRptCmt(0x0001768A, "Barometric pressure must be > this to enable diagnostic.\nkPa");
MakeNameEx(0x0001768C, "DI_FUEL_TRIM_KE_FTRM_FUEL_LEVEL_MIN", nameFlags);
MakeNameEx(0x0001768E, "DI_FUEL_TRIM_KE_FTRM_FUEL_LEVEL_LOW_TIME", nameFlags);
MakeNameEx(0x00017690, "DI_FUEL_TRIM_KE_FTRM_PURGE_RPM_MIN", nameFlags);
MakeRptCmt(0x00017690, "Engine Speed must be > this to run the Excess Purge Test.\nRPM");
MakeNameEx(0x00017692, "DI_FUEL_TRIM_KE_FTRM_ENG_AIRFLOW_LOW", nameFlags);
MakeRptCmt(0x00017692, "Engine Airflow must be > this to run the Excess Purge Test.\ngm/S");
MakeNameEx(0x00017694, "DI_FUEL_TRIM_KE_FTRM_ENG_AIRFLOW_HIGH", nameFlags);
MakeRptCmt(0x00017694, "Engine Airflow < this to run the Excess Purge Test.\ngm/S");
MakeNameEx(0x00017696, "DI_FUEL_TRIM_KV_FTRM_INDEX_OPER_TIME", nameFlags);
MakeRptCmt(0x00017696, "This much time must be spent in the current  adaptive index region before the Excess Purge Test can be run.\nSeconds");
MakeNameEx(0x000176B6, "DI_FUEL_TRIM_KV_FTRM_PR_INDEX_OPER_TIME", nameFlags);
MakeRptCmt(0x000176B6, "This much time must be spent in the current adaptive index region before the Excess Purge Test can report a pass.\nSeconds");
MakeNameEx(0x000176D6, "DI_FUEL_TRIM_KV_FTRM_PURGE_LONG_TERM_DELTA", nameFlags);
MakeNameEx(0x000176E0, "DI_FUEL_TRIM_KV_FTRM_PURGE_SHORT_TERM_DELTA", nameFlags);
MakeNameEx(0x000176EA, "DI_FUEL_TRIM_KE_FTRM_EXCESS_PURGE_TEST_TIME", nameFlags);
MakeRptCmt(0x000176EA, "Intrusive Excess Purge Test lasts this long.\nSeconds");
MakeNameEx(0x000176EC, "DI_FUEL_TRIM_KE_FTRM_EXCESS_PURGE_DELTA_DELAY", nameFlags);
MakeRptCmt(0x000176EC, "The amount of time to delay the delta calculation once the excess purge test timer begins incrementing.\nSeconds");
MakeNameEx(0x000176EE, "DI_FUEL_TRIM_KE_FTRM_PURGE_CNTRL_STABLE_WINDO", nameFlags);
MakeRptCmt(0x000176EE, "Amount of time to wait for integrals to correct before enabling purge test.\nSeconds");
MakeNameEx(0x000176F0, "DI_FUEL_TRIM_KE_FTRM_PURGE_WAIT_LIMIT", nameFlags);
MakeRptCmt(0x000176F0, "NON-Intrusive Excess Purge Test lasts this long.\nSeconds");
MakeNameEx(0x000176F2, "DI_FUEL_TRIM_KE_FTRM_PURGE_DUTY_CYCLE_MIN", nameFlags);
MakeRptCmt(0x000176F2, "Purge Ducty Cycle must be >= this to make Excess Purge Test intrusive.\nPercent");
MakeNameEx(0x000176F4, "DI_FUEL_TRIM_KV_FTRM_CCP_SHUT_OFF_DUTY_CYCLE", nameFlags);
MakeRptCmt(0x000176F4, "Purge Ducty Cycle is set to this to shut of CCP.\nPercent");
MakeNameEx(0x00017716, "DI_FUEL_TRIM_KV_FTRM_LONG_TERM_TRIM_LEAN", nameFlags);
MakeRptCmt(0x00017716, "Threshold where the long term fuel trim average is failing due to lean fueling at a given level of ethanol in the fuel.\nNONE 0-2");
MakeNameEx(0x00017720, "DI_FUEL_TRIM_KV_FTRM_LONG_TERM_TRIM_RICH", nameFlags);
MakeRptCmt(0x00017720, "Threshold where the long term fuel trim average is failing due to rich fueling at a given level of ethanol in the fuel.\nNONE 0-2");
MakeNameEx(0x0001772A, "DI_FUEL_TRIM_KV_FTRM_IDLE_CELL_OPER_TIME_MIN", nameFlags);
MakeNameEx(0x0001773A, "DI_FUEL_TRIM_KV_FTRM_MAX_PURGE_FLOW", nameFlags);
MakeNameEx(0x0001775C, "DI_FUEL_TRIM_KE_FTRM_ACCUM_PURGE_THRESHOLD", nameFlags);
MakeRptCmt(0x0001775C, "Threshold of accumulated purge flow required to reduce the excess purge vapor condition before continuing testing\nGrams");
MakeNameEx(0x0001775E, "DI_FUEL_TRIM_KV_FTRM_THRESHOLD_TEMP_MULT", nameFlags);
MakeRptCmt(0x0001775E, "Threshold multiplier to compensate for the variation of excess purge vapor generation due to temperature.\nMultiplier_0_to_2");
MakeNameEx(0x0001777E, "DI_FUEL_TRIM_KE_FTRM_PURGE_OPEN_MIN", nameFlags);
MakeRptCmt(0x0001777E, "Minimum purge duty cycle value to begin the excess purge test and where purge valve is considered open.\nPercent");
MakeNameEx(0x00017780, "DI_FUEL_TRIM_KE_FTRM_FUEL_TRIM_UPDATE_RATE", nameFlags);
MakeRptCmt(0x00017780, "Integral delay value to be used for the short term learn when FTRM requests override.\nSeconds");
MakeNameEx(0x00017782, "DI_ICAT_KA_CAT_AFT1_FUEL_OFFSET_LEAN", nameFlags);
MakeRptCmt(0x00017782, "The percent change to the average Fuel during A/F transition period 1 to cause a lean state.\nPercent");
MakeNameEx(0x000177C6, "DI_ICAT_KA_CAT_AFT1_FUEL_OFFSET_RICH", nameFlags);
MakeRptCmt(0x000177C6, "The percent change to the average Fuel during A/F transition period 1 to cause a rich state.\nPercent");
MakeNameEx(0x0001780A, "DI_ICAT_KA_CAT_AFT2_FUEL_OFFSET_LEAN", nameFlags);
MakeRptCmt(0x0001780A, "The percent change added to the average Fuel during A/F transition period 2 to cause a lean state.\nPercent");
MakeNameEx(0x0001784E, "DI_ICAT_KA_CAT_AFT2_FUEL_OFFSET_RICH", nameFlags);
MakeRptCmt(0x0001784E, "The percent change added to the average Fuel during A/F transition period 2 to cause a rich state.\nPercent");
MakeNameEx(0x00017892, "DI_ICAT_KV_CAT_AFT1_POST_RESP_TIME_MAX", nameFlags);
MakeRptCmt(0x00017892, "Maximum allowed time for the post-catalyst O2 sensor to reach a stabilized voltage during the first air/fuel transition period.\nSeconds");
MakeNameEx(0x00017896, "DI_ICAT_KV_CAT_AFT1_PRE_RESP_TIME_MAX", nameFlags);
MakeRptCmt(0x00017896, "Maximum allowed time for the pre-catalyst O2 sensor to reach a stabilized voltage during the first air/fuel transition period.\nSeconds");
MakeNameEx(0x0001789A, "DI_ICAT_KV_CAT_AFT2_PRE_RESP_TIME_MAX", nameFlags);
MakeRptCmt(0x0001789A, "Maximum allowed time for the pre-catalyst O2 sensor to reach a stabilized voltage during the second air/fuel transition period.\nSeconds");
MakeNameEx(0x0001789E, "DI_ICAT_KV_CAT_CATALYTIC_CONVERTERS", nameFlags);
MakeNameEx(0x000178A2, "DI_ICAT_KV_CAT_EWMA_THRESH_HIGH", nameFlags);
MakeRptCmt(0x000178A2, "Minimum difference value to fail test if test is currently not failing.\nSeconds");
MakeNameEx(0x000178A6, "DI_ICAT_KV_CAT_MIN_DIFF_TO_ENABLE_RSR", nameFlags);
MakeRptCmt(0x000178A6, "The minimum diff value to trigger the rapid step response test.\nSeconds");
MakeNameEx(0x000178AA, "DI_ICAT_KV_CAT_MIN_OSC_STEP_FOR_RSR", nameFlags);
MakeNameEx(0x000178AE, "DI_ICAT_KV_CAT_MIN_RSR_EWMA", nameFlags);
MakeNameEx(0x000178B2, "DI_ICAT_KV_CAT_OSC_STG1_FAIL_THRESH", nameFlags);
MakeRptCmt(0x000178B2, "Maximum time difference in stage 1 to report a pass immediately to the executive.\nSeconds");
MakeNameEx(0x000178B6, "DI_ICAT_KV_CAT_OSC_WORST_PASS_THRESH", nameFlags);
MakeRptCmt(0x000178B6, "Worst acceptable( lowest time ) oxygen storage time measurement to pass.\nSeconds");
MakeNameEx(0x000178BA, "DI_ICAT_KE_CAT_FAN_STABLE_TIME", nameFlags);
MakeRptCmt(0x000178BA, "Required time for Fan1 and Fan2 state to remain unchanged.\nSeconds");
MakeNameEx(0x000178BC, "DI_ICAT_KE_FAN1_ON_EXTENDED_TIME_MAX", nameFlags);
MakeRptCmt(0x000178BC, "Maximum time allowed to hold the Fan1 state on.\nSeconds");
MakeNameEx(0x000178BE, "DI_ICAT_KE_CAT_CONTROLS_FAN1", nameFlags);
MakeRptCmt(0x000178BE, "Enables the control of Fan1 Held-On feature to make conditions favorable for the Idle CAT Monitor Diagnostic to complete.\nBOOLEAN");
MakeNameEx(0x000178BF, "DI_ICAT_KE_CAT_NUM_CATALYST_TO_DIAGNOSE", nameFlags);
MakeRptCmt(0x000178BF, "The number of catalytic converters to diagnose.\nUnitless");
MakeNameEx(0x000178C0, "DI_ICAT_KE_CAT_NUM_FUEL_CONTROL_BANKS", nameFlags);
MakeRptCmt(0x000178C0, "The number of fuel control banks to loop during each process.\nUnitless");
MakeNameEx(0x000178C2, "DI_ICAT_KA_CAT_1_COMP_LEAN_TO_RICH", nameFlags);
MakeNameEx(0x00017964, "DI_ICAT_KA_CAT_1_COMP_RICH_TO_LEAN", nameFlags);
MakeNameEx(0x00017A06, "DI_ICAT_KA_CAT_2_COMP_LEAN_TO_RICH", nameFlags);
MakeNameEx(0x00017AA8, "DI_ICAT_KA_CAT_2_COMP_RICH_TO_LEAN", nameFlags);
MakeNameEx(0x00017B4A, "DI_ICAT_KE_ICAT_O2_VOLT_THRESHOLD", nameFlags);
MakeRptCmt(0x00017B4A, "Voltage level below which O2 output is considered to be leanfor switch summming\nMillivolts");
MakeNameEx(0x00017B4C, "DI_ICAT_KE_ICAT_MIN_NUM_O2_SWITCHES", nameFlags);
MakeRptCmt(0x00017B4C, "Minimum number of O2 sensor voltage switches to completesumming.\nUnitless");
MakeNameEx(0x00017B4E, "DI_ICAT_KE_ICAT_MAX_O2_SWITCH_TIME", nameFlags);
MakeRptCmt(0x00017B4E, "Maximum time to allow switch summing process\nSeconds");
MakeNameEx(0x00017B50, "DI_ICAT_KE_ICAT_MIN_O2_SWITCH_TIME", nameFlags);
MakeRptCmt(0x00017B50, "Used to allow a stable idle to be measured before fuel controlis requested\nSeconds");
MakeNameEx(0x00017B52, "DI_ICAT_KE_CAT_AC_CLUTCH_IS_STABLE_TIME", nameFlags);
MakeRptCmt(0x00017B52, "Required time for AC clutch state to remain unchanged.\nSeconds");
MakeNameEx(0x00017B54, "DI_ICAT_KE_CAT_AC_OFF_EXTEND_TIME_MAX", nameFlags);
MakeRptCmt(0x00017B54, "Maximum time allowed to hold AC Clutch disengaged.\nSeconds");
MakeNameEx(0x00017B56, "DI_ICAT_KE_CAT_CONTROLS_AC", nameFlags);
MakeNameEx(0x00017B57, "DI_ICAT_KE_CAT_ATTEMPTS_THIS_TRIP_MAX", nameFlags);
MakeRptCmt(0x00017B57, "Maximum number of test attempts this trip.\nUnitless");
MakeNameEx(0x00017B58, "DI_ICAT_KE_CAT_BAROMETRIC_PRESSURE_MIN", nameFlags);
MakeRptCmt(0x00017B58, "Minimum barometric pressure value to enable the catalyst test at idle.\nkPa");
MakeNameEx(0x00017B5A, "DI_ICAT_KE_CAT_CONVERTER_TEMP_MAX", nameFlags);
MakeRptCmt(0x00017B5A, "Maximum acceptable converter temperature value.\nDegrees_C");
MakeNameEx(0x00017B5C, "DI_ICAT_KE_CAT_COOLANT_TEMP_MAX", nameFlags);
MakeRptCmt(0x00017B5C, "Maximum coolant Temperature value to enable the catalyst test at idle.\nDegrees_C");
MakeNameEx(0x00017B5E, "DI_ICAT_KE_CAT_COOLANT_TEMP_MIN", nameFlags);
MakeRptCmt(0x00017B5E, "Minimum coolant temperature value to enable the catalyst test at idle.\nDegrees_C");
MakeNameEx(0x00017B60, "DI_ICAT_KE_CAT_DESIRED_IDLE_RPM_DROP_MAX", nameFlags);
MakeNameEx(0x00017B62, "DI_ICAT_KE_CAT_DESIRED_IDLE_RPM_GAIN_MAX", nameFlags);
MakeNameEx(0x00017B64, "DI_ICAT_KE_CAT_ENGINE_RUN_TIME_MIN", nameFlags);
MakeRptCmt(0x00017B64, "Minimum time from engine start before stabilized conditions are met.\nSeconds");
MakeNameEx(0x00017B68, "DI_ICAT_KE_CAT_IDLE_EFF_AREA_MAX", nameFlags);
MakeRptCmt(0x00017B68, "Maximum change in desired idle effective area per 12.5 ms period.\nMillimeters_Squared");
MakeNameEx(0x00017B6A, "DI_ICAT_KE_CAT_IDLE_AIRFLOW_MAX", nameFlags);
MakeRptCmt(0x00017B6A, "Maximum airflow value for closed loop stability.\ngm_per_sec");
MakeNameEx(0x00017B6B, "DI_ICAT_KE_CAT_IDLE_AIRFLOW_MIN", nameFlags);
MakeRptCmt(0x00017B6B, "Minimum airflow value for closed loop stability.\ngm_per_sec");
MakeNameEx(0x00017B6C, "DI_ICAT_KE_CAT_EXCESS_IDLE_TIME_LIMIT", nameFlags);
MakeRptCmt(0x00017B6C, "Maximum amount of idle time to enable the catalyst test at idle. A max value in this cal will never check the idle time limit,\nSeconds");
MakeNameEx(0x00017B6E, "DI_ICAT_KE_CAT_IDLE_TPS_MAX", nameFlags);
MakeRptCmt(0x00017B6E, "Maximum Throttle position value to consider the vehicle idling.\nPercent");
MakeNameEx(0x00017B70, "DI_ICAT_KE_CAT_IDLE_VEHICLE_SPEED_MAX", nameFlags);
MakeRptCmt(0x00017B70, "Maximum vehicle speed value to consider the vehicle idling.\nMPH");
MakeNameEx(0x00017B72, "DI_ICAT_KE_CAT_INTAKE_AIR_TEMP_MAX", nameFlags);
MakeRptCmt(0x00017B72, "Maximum intake air temperature threshold to continue to enable the catalyst test.\nDegrees_C");
MakeNameEx(0x00017B74, "DI_ICAT_KE_CAT_INTAKE_AIR_TEMP_MIN", nameFlags);
MakeRptCmt(0x00017B74, "Minimum intake air temperature threshold to continue to enable the catalyst test.\nDegrees_C");
MakeNameEx(0x00017B76, "DI_ICAT_KE_CAT_INTEGRATOR_MAX", nameFlags);
MakeRptCmt(0x00017B76, "Maximum integrator value to enable the catalyst diagnostic.\nUnitless");
MakeNameEx(0x00017B77, "DI_ICAT_KE_CAT_INTEGRATOR_MIN", nameFlags);
MakeRptCmt(0x00017B77, "Minimum integrator value to enable the catalyst diagnostic.\nUnitless");
MakeNameEx(0x00017B78, "DI_ICAT_KE_CAT_MIN_TIME_ABOVE_MIN_RPM", nameFlags);
MakeRptCmt(0x00017B78, "Minimum time that the minimum RPM must be maintained prior to entering idle for stabilization conditions to be satisfied.\nSeconds");
MakeNameEx(0x00017B7A, "DI_ICAT_KE_CAT_MAT_BURNOFF_TEMP_THRESH", nameFlags);
MakeRptCmt(0x00017B7A, "The minimum temperature required for the catalytic converter toburn off the material when it is 'green'\nDegrees C_S");
MakeNameEx(0x00017B7C, "DI_ICAT_KE_CAT_MATERIAL_BURNOFF_DELAY", nameFlags);
MakeNameEx(0x00017B80, "DI_ICAT_KE_CAT_RPM_TO_WARMUP_CATALYST", nameFlags);
MakeRptCmt(0x00017B80, "Minimum RPM that must be maintained for the catalyst warmup timer to increment.\nRPM");
MakeNameEx(0x00017B82, "DI_ICAT_KE_CAT_STABILIZATION_TIME_MAX", nameFlags);
MakeRptCmt(0x00017B82, "Maximum amount of stabilization time before enabling the catalyst diagnostic.\nSeconds");
MakeNameEx(0x00017B84, "DI_ICAT_KE_CAT_STABILIZATION_TIME_MIN", nameFlags);
MakeRptCmt(0x00017B84, "Minimum amount of stabilization time to enable the catalyst diagnostic.\nSeconds");
MakeNameEx(0x00017B86, "DI_ICAT_KE_CAT_VOLTAGE_MIN", nameFlags);
MakeRptCmt(0x00017B86, "Minimum battery voltage threshold to enable the catalyst test at idle.\nVolts");
MakeNameEx(0x00017B88, "DI_ICAT_KE_EGPT_ENG_AIRFLOW_HIGH", nameFlags);
MakeRptCmt(0x00017B88, "Maximum engine air flow to be used in steady state temperature calculations.\nGrams_Air_Per_Second");
MakeNameEx(0x00017B8A, "DI_ICAT_KE_EGPT_RPM_HIGH", nameFlags);
MakeRptCmt(0x00017B8A, "Maximum engine speed to be used in steady state temperature calculations.\nRevolutions per minute");
MakeNameEx(0x00017B8C, "DI_ICAT_KE_CAT_AC_CLUTCH_HAS_BEEN_ON_VST", nameFlags);
MakeRptCmt(0x00017B8C, "Maximum vehicle speed threshold to allow AC_Clutch_Has_Been_Onset to TRUE.\nMPH");
MakeNameEx(0x00017B8E, "DI_ICAT_KE_NUM_INTEGRATOR_SAMPLES", nameFlags);
MakeRptCmt(0x00017B8E, "Number of consecutive periods that all integrator values must remain within range to establish stability.\nUnitless");
MakeNameEx(0x00017B90, "DI_ICAT_KE_CAT_MAX_ETH_PERCENT", nameFlags);
MakeRptCmt(0x00017B90, "Minimum fuel ethanol percent threshold to enable the catalyst test.\nPercent");
MakeNameEx(0x00017B92, "DI_ICAT_KV_CAT_1_ETH_COMPENSATION_FACTOR", nameFlags);
MakeNameEx(0x00017B9C, "DI_ICAT_KV_CAT_2_ETH_COMPENSATION_FACTOR", nameFlags);
MakeNameEx(0x00017BA6, "DI_ICAT_KV_CAT_DISABLE_IF_CODE_SET", nameFlags);
MakeRptCmt(0x00017BA6, "Disable diagnostic test if any malfunctions in the groups marked TRUE are active.\nBOOLEAN");
MakeNameEx(0x00017BAA, "DI_ICAT_KV_CAT_RPM_CHANGE_MAX", nameFlags);
MakeRptCmt(0x00017BAA, "Used to set the maximum RPM change value based on whether or not fuel control mode is active.\nRPM");
MakeNameEx(0x00017BAE, "DI_ICAT_KV_EGPT_ECT_ENABLE_MIN", nameFlags);
MakeRptCmt(0x00017BAE, "Minimum coolant temperature threshold for the location to enable the exhaust location temperature model.\nUnitless");
MakeNameEx(0x00017BB2, "DI_ICAT_KV_EGPT_EXHAUST_TEMP_WARM_MIN", nameFlags);
MakeRptCmt(0x00017BB2, "Minimum exhaust location temperature threshold for the location to be considered warm enough to test.\nUnitless");
MakeNameEx(0x00017BB6, "DI_ICAT_KV_EGPT_FILTER_COEF_DECREASING", nameFlags);
MakeNameEx(0x00017BBA, "DI_ICAT_KV_EGPT_FILTER_COEF_INCREASING", nameFlags);
MakeNameEx(0x00017BBE, "DI_ICAT_KV_EGPT_SS_ENG_AIRFLOW_COEF", nameFlags);
MakeRptCmt(0x00017BBE, "Engine air flow multiplier used in steady state temperature calculation.\nUnitless");
MakeNameEx(0x00017BC6, "DI_ICAT_KV_EGPT_SS_EXHAUST_TEMP_DEFAULT", nameFlags);
MakeRptCmt(0x00017BC6, "Default steady state temperature.\nDegrees Celsius");
MakeNameEx(0x00017BCA, "DI_ICAT_KV_EGPT_SS_LOW_OFFSET_TEMP", nameFlags);
MakeNameEx(0x00017BCE, "DI_ICAT_KV_EGPT_SS_HIGH_OFFSET_TEMP", nameFlags);
MakeNameEx(0x00017BD2, "DI_ICAT_KV_EGPT_SS_OFFSET_TRANSIT_TEMP", nameFlags);
MakeRptCmt(0x00017BD2, "Temperature boundry used to determine whether the high or low offset is used in the steady state temperature calculation.\nDegrees Celsius");
MakeNameEx(0x00017BD6, "DI_ICAT_KV_EGPT_SS_RPM_COEF", nameFlags);
MakeRptCmt(0x00017BD6, "Engine speed multiplier used in steady state temperature calculation.\nDegrees Celsius / RPM");
MakeNameEx(0x00017BDA, "DI_ICAT_KV_EGPT_SS_ETH_COMPENSATION", nameFlags);
MakeRptCmt(0x00017BDA, "Modifies the predicted steady state exhaust gas temperatureto account for variations caused by ethanol fuel.\nDegrees_Celsius");
MakeNameEx(0x00017BE4, "DI_IDLE_KE_IAC_BAROMETRIC_PRESSURE_MIN", nameFlags);
MakeRptCmt(0x00017BE4, "Minimum barometric pressure threshold to enable the IAC diagnostic.\nkPa");
MakeNameEx(0x00017BE6, "DI_IDLE_KE_IAC_COOL_TEMP_MIN", nameFlags);
MakeRptCmt(0x00017BE6, "Minimum coolant temperature threshold to enable the IAC diagnostic.\nDegrees_C");
MakeNameEx(0x00017BE8, "DI_IDLE_KE_IAC_ENGINE_RUN_TIME_MIN", nameFlags);
MakeRptCmt(0x00017BE8, "Minimum engine run time to enable the IAC diagnostic.\nSeconds");
MakeNameEx(0x00017BEA, "DI_IDLE_KE_IAC_IGNITION_VOLTAGE_MAX", nameFlags);
MakeRptCmt(0x00017BEA, "Maximum ignition system voltage threshold to enable the IAC diagnostic.\nVolts");
MakeNameEx(0x00017BEC, "DI_IDLE_KE_IAC_IGNITION_VOLTAGE_MIN", nameFlags);
MakeRptCmt(0x00017BEC, "Minimum ignition system voltage threshold to enable the IAC diagnostic.\nVolts");
MakeNameEx(0x00017BEE, "DI_IDLE_KE_IAC_INTAKE_AIR_TEMP_MIN", nameFlags);
MakeRptCmt(0x00017BEE, "Minimum intake air temperature threshold to enable the IAC diagnostic.\nDegrees_C");
MakeNameEx(0x00017BF0, "DI_IDLE_KE_IAC_IDLE_THROTTLE_POS_MAX", nameFlags);
MakeRptCmt(0x00017BF0, "Maximum throttle position threshold to allow idle conditions.\nPercent");
MakeNameEx(0x00017BF2, "DI_IDLE_KE_IAC_IDLE_VEHICLE_SPEED_MAX", nameFlags);
MakeRptCmt(0x00017BF2, "Maximum vehicle speed threshold to allow idle conditions.\nMPH");
MakeNameEx(0x00017BF4, "DI_IDLE_KE_IAC_DIAG_STABLE_WINDOW_TIME", nameFlags);
MakeRptCmt(0x00017BF4, "Time for which the appropriate conditions must be stable before Idle Conditions Present flag can be SET.\nSeconds");
MakeNameEx(0x00017BF6, "DI_LEGR_KE_EGRP_STRK_MAX_OPEN_TIME", nameFlags);
MakeRptCmt(0x00017BF6, "Maximum amount of time the  EGR valve is commanded open to 100 percent.\nSeconds");
MakeNameEx(0x00017BF8, "DI_LEGR_KE_EGRP_STROKE_TIME_DELAY", nameFlags);
MakeNameEx(0x00017BFA, "DI_LEGR_KE_EGRP_STRK_LOW_EGR_POSITION", nameFlags);
MakeRptCmt(0x00017BFA, "EGR desired must be greater than or equal to this in order to enable EGR stroking for pintle diagnostics.\nPercent");
MakeNameEx(0x00017BFC, "DI_LEGR_KE_EGRP_STROKE_COUNTER_LMT", nameFlags);
MakeRptCmt(0x00017BFC, "Maximum amount of successful stroking events which will be allowed for one stroking set.\nStrokes");
MakeNameEx(0x00017BFE, "DI_LEGR_KE_EGRP_IGNITION_VOLTAGE_MIN", nameFlags);
MakeRptCmt(0x00017BFE, "Minimum ignition voltage required to enable the EGRP tests.\nVolts");
MakeNameEx(0x00017C00, "DI_MISFIRE_KE_MISF_IDLE_MODE_VEH_SPD", nameFlags);
MakeRptCmt(0x00017C00, "Maximum vehicle speed before cylinder mode (idle) misfire detection is disabled.\nMPH");
MakeNameEx(0x00017C02, "DI_MISFIRE_KE_MISF_GENERIC_DELAY", nameFlags);
MakeRptCmt(0x00017C02, "Number of engine cycles to delay for the enable criteria not being met, decel fuel cutoff, fuel shut off, or torque reduction.\nEng Cycles");
MakeNameEx(0x00017C04, "DI_MISFIRE_KE_MISF_CRANK_ANGLE_CRRCTN_USED", nameFlags);
MakeRptCmt(0x00017C04, "Determines if crank angle correction should be used.\nBOOLEAN");
MakeNameEx(0x00017C05, "DI_MISFIRE_KE_MISF_REPORT_EMISSION_MISFIRE", nameFlags);
MakeNameEx(0x00017C06, "DI_MISFIRE_KE_MISF_EMISSION_MISFIRE", nameFlags);
MakeRptCmt(0x00017C06, "If misfire counts are above this threshold, catalyst damage misfire is possible.\nUnitless");
MakeNameEx(0x00017C08, "DI_MISFIRE_KA_MISF_CATALYST_MISFIRE", nameFlags);
MakeRptCmt(0x00017C08, "If misfire counts are above this threshold, catalyst damage misfire is possible.\nUnitless");
MakeNameEx(0x00017C74, "DI_MISFIRE_KA_MISF_REPORT_CATALYST_MISFIRE", nameFlags);
MakeNameEx(0x00017CE0, "DI_MISFIRE_KA_MISF_CYLINDER_MODE_IDLE", nameFlags);
MakeNameEx(0x00017E34, "DI_MISFIRE_KA_MISF_CYLINDER_MODE_REG1", nameFlags);
MakeNameEx(0x00017F88, "DI_MISFIRE_KA_MISF_CYLINDER_MODE_REG2", nameFlags);
MakeNameEx(0x00018340, "DI_MISFIRE_KA_MISF_CYLINDER_MODE_REG3", nameFlags);
MakeNameEx(0x00018384, "DI_MISFIRE_KA_MISF_REVOLUTION_MODE_REG1", nameFlags);
MakeNameEx(0x000183EA, "DI_MISFIRE_KA_MISF_REVOLUTION_MODE_REG2", nameFlags);
MakeNameEx(0x000187A2, "DI_MISFIRE_KA_MISF_REVOLUTION_MODE_REG3", nameFlags);
MakeNameEx(0x0001882A, "DI_MISFIRE_KV_MISF_ZERO_TORQUE_REG1_SPEED", nameFlags);
MakeNameEx(0x0001883E, "DI_MISFIRE_KV_MISF_ZERO_TORQUE_REG2_SPEED", nameFlags);
MakeNameEx(0x00018876, "DI_MISFIRE_KV_MISF_ZERO_TORQUE_REG3_SPEED", nameFlags);
MakeNameEx(0x0001887E, "DI_MISFIRE_KV_MISF_ENGINE_BLOCK_CYLINDER_ID", nameFlags);
MakeRptCmt(0x0001887E, "Identifies the actual engine block cylinder from the misfire diagnostic cylinder counter.\nUnitless");
MakeNameEx(0x00018886, "DI_MISFIRE_KE_MISF_ABUSIVE_ENGINE_SPEED", nameFlags);
MakeRptCmt(0x00018886, "Minimum abusive engine speed to delay the diagnostic.\nRPM");
MakeNameEx(0x00018888, "DI_MISFIRE_KE_MISF_CTS_AT_STARTUP_HIGH", nameFlags);
MakeRptCmt(0x00018888, "If startup coolant temp is not above CTS_At_Startup_Low cal, enable misfire detection when coolant exceeds this.\nDeg_C");
MakeNameEx(0x0001888A, "DI_MISFIRE_KE_MISF_CTS_AT_STARTUP_LOW", nameFlags);
MakeRptCmt(0x0001888A, "Minimum engine starup coolant temperature to allow misfire detection.\nDeg_C");
MakeNameEx(0x0001888C, "DI_MISFIRE_KE_MISF_COOLANT_TEMP_HIGH", nameFlags);
MakeRptCmt(0x0001888C, "Maximum coolant temperature to allow misfire detection.\nDeg_C");
MakeNameEx(0x0001888E, "DI_MISFIRE_KE_MISF_COOLANT_TEMP_LOW", nameFlags);
MakeRptCmt(0x0001888E, "Minimum coolant temperature to allow misfire detection.\nDeg_C");
MakeNameEx(0x00018890, "DI_MISFIRE_KE_MISF_CRANK_UNLEARNED_RPM_MAX", nameFlags);
MakeRptCmt(0x00018890, "Maximum engine speed to allow misfire detection.\nRPM");
MakeNameEx(0x00018892, "DI_MISFIRE_KE_MISF_RPM_HIGH", nameFlags);
MakeRptCmt(0x00018892, "Maximum engine speed to allow misfire detection.\nRPM");
MakeNameEx(0x00018894, "DI_MISFIRE_KE_MISF_RPM_LOW", nameFlags);
MakeRptCmt(0x00018894, "Minimum engine speed to allow misfire detection.\nRPM");
MakeNameEx(0x00018896, "DI_MISFIRE_KE_MISF_VOLTAGE_HIGH", nameFlags);
MakeRptCmt(0x00018896, "Maximum ignition voltage to allow misfire detection.\nVolts");
MakeNameEx(0x00018898, "DI_MISFIRE_KE_MISF_VOLTAGE_LOW", nameFlags);
MakeRptCmt(0x00018898, "Minimum ignition voltage to allow misfire detection.\nVolts");
MakeNameEx(0x0001889A, "DI_MISFIRE_KE_MISF_INHIBITING_FAULTS", nameFlags);
MakeRptCmt(0x0001889A, "If TRUE is specified for the indexed fault group, then any active fault within that group will inhibit the Misfire diagnostic.\nCal_Set_Of_Fault_Group_Type");
MakeNameEx(0x0001889E, "DI_MISFIRE_KE_MISF_IDLE_BLMS_LEARNED_TIME", nameFlags);
MakeRptCmt(0x0001889E, "This is the time limit for learning BLMs.\nSeconds");
MakeNameEx(0x000188A0, "DI_MISFIRE_KE_MISF_TPS_LIMIT", nameFlags);
MakeRptCmt(0x000188A0, "Maximum throttle position to delay the diagnostic.\nPercent");
MakeNameEx(0x000188A2, "DI_MISFIRE_KE_MISF_VEHICLE_SPEED_LIMIT", nameFlags);
MakeRptCmt(0x000188A2, "Minimum vehicle speed to delay the diagnostic.\nMPH");
MakeNameEx(0x000188A4, "DI_MISFIRE_KE_MISF_TPS_NEGATIVE_DELTA", nameFlags);
MakeRptCmt(0x000188A4, "Maximum allowable negative throttle position delta before misfire diagnostic is disabled.\nPercent");
MakeNameEx(0x000188A6, "DI_MISFIRE_KE_MISF_TPS_POSITIVE_DELTA", nameFlags);
MakeRptCmt(0x000188A6, "Maximum allowable positive throttle position delta before misfire diagnostic is disabled.\nPercent");
MakeNameEx(0x000188A8, "DI_MISFIRE_KE_MISF_FUEL_LEVEL_MINIMUM", nameFlags);
MakeRptCmt(0x000188A8, "If fuel level is below this value, misfire diagnostic will be delayed.\nPercent");
MakeNameEx(0x000188AA, "DI_MISFIRE_KE_MISF_ABS_ENGINE_LOAD", nameFlags);
MakeRptCmt(0x000188AA, "Disable ABS rough road detection above this engine load.\nPercent");
MakeNameEx(0x000188AC, "DI_MISFIRE_KE_MISF_ABS_ENGINE_SPEED", nameFlags);
MakeRptCmt(0x000188AC, "Disable ABS rough road detection above this engine speed.\nRPM");
MakeNameEx(0x000188AE, "DI_MISFIRE_KV_MISF_CAT_DAMAGE_ETH_FACTOR", nameFlags);
MakeRptCmt(0x000188AE, "Modifies the misfire catalyst damage threshold for ethanol.\nMultiplier");
MakeNameEx(0x000188B8, "DI_MISFIRE_KV_MISF_EMS_FAIL_ETHANOL_FACTOR", nameFlags);
MakeRptCmt(0x000188B8, "Modifies the misfire emission failure threshold for ethanol.\nMultiplier");
MakeNameEx(0x000188C2, "DI_MISFIRE_KV_MISF_ABS_WITH_TCS_LIMIT", nameFlags);
MakeNameEx(0x000188D0, "DI_MISFIRE_KV_MISF_ABS_ONLY_LIMIT", nameFlags);
MakeNameEx(0x000188DE, "DI_MISFIRE_KE_MISF_ABUSIVE_ENGINE_SPD_DELAY", nameFlags);
MakeRptCmt(0x000188DE, "Number of engine cycles to delay if an abusive high engine speed occurs.\nEng Cycles");
MakeNameEx(0x000188E0, "DI_MISFIRE_KE_MISF_AIR_CONDITIONER_DELAY", nameFlags);
MakeRptCmt(0x000188E0, "Number of engine cycles to delay if the air conditioner clutch as changed state.\nEng Cycles");
MakeNameEx(0x000188E2, "DI_MISFIRE_KE_MISF_AIR_TEST_DELAY", nameFlags);
MakeRptCmt(0x000188E2, "Number of engine cycles to delay if the AIR test is intrusive.\nEng Cycles");
MakeNameEx(0x000188E4, "DI_MISFIRE_KE_MISF_AUTO_TRANS_SHIFT_DELAY", nameFlags);
MakeRptCmt(0x000188E4, "Number of engine cycles to delay the diagnostic during automatic transmission shifts.\nEng Cycles");
MakeNameEx(0x000188E6, "DI_MISFIRE_KE_MISF_CAM_MALFUNCTION_DELAY", nameFlags);
MakeRptCmt(0x000188E6, "Number of engine cycles to delay on a cam malfunction.\nEng Cycles");
MakeNameEx(0x000188E8, "DI_MISFIRE_KE_MISF_EGR_TEST_DELAY", nameFlags);
MakeRptCmt(0x000188E8, "Number of engine cycles to delay if the EGR test is active.\nEng Cycles");
MakeNameEx(0x000188EA, "DI_MISFIRE_KE_MISF_ETHANOL_PERCENT", nameFlags);
MakeRptCmt(0x000188EA, "The percent ethanol in the fuel which disables the Misfire diagnostic.\nPercent");
MakeNameEx(0x000188EC, "DI_MISFIRE_KE_MISF_EXCESS_ACCEL_DELAY", nameFlags);
MakeRptCmt(0x000188EC, "Number of engine cycles to delay if excess acceleration is detected.\nEng Cycles");
MakeNameEx(0x000188EE, "DI_MISFIRE_KE_MISF_FUEL_DELAY", nameFlags);
MakeRptCmt(0x000188EE, "Number of engine cycles to delay during periods of low fuel.\nEng Cycles");
MakeNameEx(0x000188F0, "DI_MISFIRE_KE_MISF_TPS_DELTA_DELAY", nameFlags);
MakeRptCmt(0x000188F0, "Number of engine cycles to delay on changes to the throttle position.\nEng Cycles");
MakeNameEx(0x000188F2, "DI_MISFIRE_KE_MISF_UNDETECTABLE_DELAY", nameFlags);
MakeNameEx(0x000188F4, "DI_MISFIRE_KE_MISF_ABS_FAIL_COUNTER", nameFlags);
MakeRptCmt(0x000188F4, "Minimum number of ABS failures needed to consider an ABS fault.\ncounts");
MakeNameEx(0x000188F6, "DI_MISFIRE_KE_MISF_ABS_SAMPLE_COUNTER", nameFlags);
MakeRptCmt(0x000188F6, "Minimum number of samples necessary to restart the test.\ncounts");
MakeNameEx(0x000188F8, "DI_MISFIRE_KE_MISF_ABS_VEHICLE_SPEED", nameFlags);
MakeRptCmt(0x000188F8, "Disable Misfire-ABS rough road diagnostic below this vehicle speed.\nMPH");
MakeNameEx(0x000188FA, "DI_MISFIRE_KE_MISF_WHEEL_SLIP_VEHICLE_SPEED", nameFlags);
MakeNameEx(0x000188FC, "DI_MISFIRE_KE_MISF_WHEEL_SLIP_LIMIT", nameFlags);
MakeRptCmt(0x000188FC, "Misfire diagnostic is disabled when the driven wheels are spinning faster than the non-drive wheels BY this threshold.\nMPH");
MakeNameEx(0x000188FE, "DI_MISFIRE_KE_MISF_SERIAL_DATA_FAIL_CNTR", nameFlags);
MakeRptCmt(0x000188FE, "Minimum number of serial data failures necessary to consider a fault.\nCounts");
MakeNameEx(0x00018900, "DI_MISFIRE_KE_MISF_SERIAL_DATA_FAIL_DELAY", nameFlags);
MakeRptCmt(0x00018900, "Minimum timer value necessary to increment the serial data fail counter.\nSeconds");
MakeNameEx(0x00018902, "DI_MISFIRE_KE_MISF_SERIAL_DATA_SAMPLE_CNTR", nameFlags);
MakeRptCmt(0x00018902, "Minimum number of samples necessary to restart the test.\ncounts");
MakeNameEx(0x00018904, "DI_MISFIRE_KE_MISF_FUEL_DELAY_DISABLE_TIME", nameFlags);
MakeNameEx(0x00018906, "DI_MISFIRE_KE_MISF_SHIFT_DELAY_DISABLE_TIME", nameFlags);
MakeNameEx(0x00018908, "DI_MISFIRE_KE_MISF_START_DELAY_DISABLE_TIME", nameFlags);
MakeNameEx(0x0001890A, "DI_TPS_KE_TPSD_IAC_POS_MIN", nameFlags);
MakeRptCmt(0x0001890A, "Minimum IAC position to be within normal operating window.\nSteps");
MakeNameEx(0x0001890C, "DI_TPS_KE_TPSD_IAC_POS_MAX", nameFlags);
MakeRptCmt(0x0001890C, "Maximum IAC position to be within normal operating window.\nSteps");
MakeNameEx(0x0001890E, "DM_DATA_MANAGER_KE_DGDM_FUEL_SYS_CONDS_LIMIT", nameFlags);
MakeNameEx(0x00018910, "DM_DATA_MANAGER_KE_DGDM_MAX_LOW_COOLANT", nameFlags);
MakeNameEx(0x00018912, "DM_DATA_MANAGER_KE_DGDM_MIN_HIGH_COOLANT", nameFlags);
MakeNameEx(0x00018914, "DM_DATA_MANAGER_KE_DGDM_MISFIRE_CONDS_LIMIT", nameFlags);
MakeNameEx(0x00018916, "DM_EXECUTIVE_KV_DGDM_DTC_DEP_FR_LIST_ID", nameFlags);
MakeRptCmt(0x00018916, "Defines the relationship between a DTC identifier and the DTC dependent PID list used in a Failure Record.\nEnumeration");
MakeNameEx(0x00018A1B, "DM_EXECUTIVE_KE_DGDM_COOLANT_RAIL", nameFlags);
MakeRptCmt(0x00018A1B, "This calibration is intended to represent the supply voltage to which an open coolant sensor input would float.\nCounts");
MakeNameEx(0x00018A1C, "DM_EXECUTIVE_KE_DGDM_MAP_RAIL", nameFlags);
MakeRptCmt(0x00018A1C, "This calibration is intended to represent the supply voltage to which an open manifold pressure sensor input would float.\nCounts");
MakeNameEx(0x00018A1D, "DM_EXECUTIVE_KE_DGDM_ODO_SINCE_CC_SCALE_FACT", nameFlags);
MakeRptCmt(0x00018A1D, "Multiplier factor for determining proper DGDM_Odo_Since_CC scaling.\nKPS/MPH");
MakeNameEx(0x00018A1E, "DM_EXECUTIVE_KE_DGDM_ODO_WITH_MIL_ON_SCALE_FA", nameFlags);
MakeRptCmt(0x00018A1E, "Multiplier factor for determining proper DGDM_Odo_With_MIL_On scaling.\nKPS/MPH");
MakeNameEx(0x00018A20, "DM_EXECUTIVE_KE_DGDM_SVS_ON_MIN_DURATION", nameFlags);
MakeNameEx(0x00018A22, "DM_TYPES_KV_NON_CONTINUOUS_TEST_SUPPORTED", nameFlags);
MakeRptCmt(0x00018A22, "This calibration indicates what non-continuous diagnostics are supported by the diagnostic executive.\nBOOLEAN");
MakeNameEx(0x00018A24, "DM_TYPES_KV_DM_FAULT_TYPE", nameFlags);
MakeRptCmt(0x00018A24, "A = 1 trip SES On, 3 trips SES Off; B = 2 trips SES On, 3 trips SES Off; C = SVS On; X = no reporting\nFault Type");
MakeNameEx(0x00018B2A, "DM_TYPES_KV_DM_LIGHT_ENABLE", nameFlags);
MakeRptCmt(0x00018B2A, "This calibration enables or disables the telltale lamp for any fault code.\nBOOLEAN");
MakeNameEx(0x00018C30, "ETC_DIAG_KA_ETC_AIR_A0_FILT_COEF", nameFlags);
MakeRptCmt(0x00018C30, "MAP based airflow diagnostic A0 filter time constant in msecs.\nMilliseconds");
MakeNameEx(0x00018DA6, "ETC_DIAG_KA_ETC_AIR_B0_FILT_COEF", nameFlags);
MakeRptCmt(0x00018DA6, "MAP based airflow diagnostic B0 filter time constant in msecs.\nMilliseconds");
MakeNameEx(0x00018F1C, "ETC_DIAG_KA_ETC_MAF_FILT_A0_COEF", nameFlags);
MakeRptCmt(0x00018F1C, "MAF based airflow diagnostic A0 filter time constant in msecs.\nMilliseconds");
MakeNameEx(0x00019092, "ETC_DIAG_KA_ETC_MAF_FILT_B0_COEF", nameFlags);
MakeRptCmt(0x00019092, "MAF based airflow diagnostic B0 filter time constant in msecs.\nMilliseconds");
MakeNameEx(0x00019208, "ETC_DIAG_KV_MAX_ETC_MAF_AIRFLOW", nameFlags);
MakeRptCmt(0x00019208, "Lookup to clamp the value of the MAF sensor based airflow usingengine speed as the index\nMilligrams_Per_Cylinder");
MakeNameEx(0x0001922A, "ETC_DIAG_KV_DESIRED_TERM_COEF_0", nameFlags);
MakeRptCmt(0x0001922A, "Nth order model coefficient vs. ignition voltage for current Desired Throttle Position.\nNth_Model_Coef_Vs_Volts_Table");
MakeNameEx(0x0001924A, "ETC_DIAG_KV_DESIRED_TERM_COEF_1", nameFlags);
MakeRptCmt(0x0001924A, "Nth order model coefficient vs. ingition voltage for 1 sample old Desired Throttle Position.\nNth_Model_Coef_Vs_Volts_Table");
MakeNameEx(0x0001926A, "ETC_DIAG_KV_DESIRED_TERM_COEF_2", nameFlags);
MakeRptCmt(0x0001926A, "Nth order model coefficient vs. ingition voltage for 2 samples old Desired Throttle Position.\nNth_Model_Coef_Vs_Volts_Table");
MakeNameEx(0x0001928A, "ETC_DIAG_KV_ESTIMATED_TERM_COEF_1", nameFlags);
MakeRptCmt(0x0001928A, "Nth order model coefficient vs. ingition voltage for 1 sample old Nth order model output.\nNth_Model_Coef_Vs_Volts_Table");
MakeNameEx(0x000192AA, "ETC_DIAG_KV_ESTIMATED_TERM_COEF_2", nameFlags);
MakeRptCmt(0x000192AA, "Nth order model coefficient vs. ingition voltage for 2 samples old Nth order model output.\nNth_Model_Coef_Vs_Volts_Table");
MakeNameEx(0x000192CA, "ETC_DIAG_KA_SATP_AIRFLOW", nameFlags);
MakeRptCmt(0x000192CA, "Predicted airflow at standard pressure and temp based on currentEngine speed and commanded throttle position.\nmGPC_Vs_RPM_And_Rotation_Table");
MakeNameEx(0x0001950C, "ETC_DIAG_KV_BARO_CORR_FACTOR", nameFlags);
MakeRptCmt(0x0001950C, "Lookup for a correction factor for barometric pressure.\nScaler_0to2_Vs_kPa_Table");
MakeNameEx(0x00019512, "ETC_DIAG_KV_INDUCTION_TEMP_CORR_FACTOR", nameFlags);
MakeRptCmt(0x00019512, "Lookup for a correction factor for induction air temperature.\nScaler_0to2_Vs_Degrees_C_Table");
MakeNameEx(0x00019526, "ETC_DIAG_KA_PEDAL_STATUS_DECODE", nameFlags);
MakeRptCmt(0x00019526, "Pedal sensor vrs pedal sensor faults conversion constants. DISAGREE 0=1-2  1=1-3  2=2-3 X RANGE 0=PPS1, 1=PPS2, 2=PPS3\nPedal_Status_Table_Type");
MakeNameEx(0x00019566, "ETC_DIAG_KV_THROTTLE_STATUS_DECODE", nameFlags);
MakeRptCmt(0x00019566, "Throttle status as a function of throttle related diagnostic flags0=TPS1 range 1=TPS2 Range 2=TPS Disagree\nThrottle_Status_Table_Type");
MakeNameEx(0x0001956E, "ETC_DIAG_KE_MIN_MAF_VALID_TIME", nameFlags);
MakeRptCmt(0x0001956E, "Time that ignition voltage must be present for the MAF sensorheating element to warm up.\nSeconds");
MakeNameEx(0x00019570, "ETC_DIAG_KE_TPS_VS_MAF_ACTUATION_ERROR", nameFlags);
MakeRptCmt(0x00019570, "Limit for TPS Vs MAF airflow actuation error.\nMilligrams_Per_Cylinder");
MakeNameEx(0x00019572, "ETC_DIAG_KE_TPS_VS_MAP_ACTUATION_ERROR", nameFlags);
MakeRptCmt(0x00019572, "Limit for TPS Vs MAP airflow actuation error.\nMilligrams_Per_Cylinder");
MakeNameEx(0x00019574, "ETC_DIAG_KE_THROTTLE_ACTUATION_ERROR_COUN", nameFlags);
MakeRptCmt(0x00019574, "Max limit for accumulated local actuation errors\nSHORTCARD");
MakeNameEx(0x00019576, "ETC_DIAG_KE_THROTTLE_ACTUATION_ERROR_THRE", nameFlags);
MakeNameEx(0x00019578, "ETC_DIAG_KE_DEFAULT_THROTTLE_POSITION", nameFlags);
MakeRptCmt(0x00019578, "Throttle position to use when ETC link not awake or UART fault for estimating engine airflow.\nPercent_Rotation");
MakeNameEx(0x0001957A, "ETC_DIAG_KE_MAX_ALLOWABLE_INCONSISTENCY", nameFlags);
MakeRptCmt(0x0001957A, "limit of difference between primary and redundant throt position\nPercent_Rotation");
MakeNameEx(0x0001957C, "ETC_DIAG_KE_MIN_MAF_VALID_RPM", nameFlags);
MakeRptCmt(0x0001957C, "Lowest engine speed at which behavior of the MAF sensor is deemedaccurate.\nRPM");
MakeNameEx(0x0001957E, "ETC_DIAG_KE_AIRFLOW_ACTUATION_COUNT_LIMIT", nameFlags);
MakeRptCmt(0x0001957E, "Number of times the airflow diagnostic must run before the testcomplete flag is set.\nSHORTCARD");
MakeNameEx(0x0001957F, "ETC_DIAG_KE_TPS_VS_MAF_ERROR_COUNT_LIMIT", nameFlags);
MakeRptCmt(0x0001957F, "Limit for TPS vs MAF accumulated airflow actuation errors.\nSHORTCARD");
MakeNameEx(0x00019580, "ETC_DIAG_KE_TPS_VS_MAF_ACT_UP_COUNTER", nameFlags);
MakeRptCmt(0x00019580, "Amount to inc the airflow act error count when possible TPS vs MAF airflow actuation error\nSHORTCARD");
MakeNameEx(0x00019581, "ETC_DIAG_KE_TPS_VS_MAP_ACT_DOWN_COUNTER", nameFlags);
MakeRptCmt(0x00019581, "Amount to dec the tps vs MAP airflow act error count when no actuation error\nSHORTCARD");
MakeNameEx(0x00019582, "ETC_DIAG_KE_TPS_VS_MAP_ERROR_COUNT_LIMIT", nameFlags);
MakeRptCmt(0x00019582, "Limit for TPS vs MAP accumulated airflow actuation errors.\nSHORTCARD");
MakeNameEx(0x00019583, "ETC_DIAG_KE_TPS_VS_MAP_ACT_UP_COUNTER", nameFlags);
MakeRptCmt(0x00019583, "Amount to inc the airflow act error count when possible TPS vs MAP airflow actuation error\nSHORTCARD");
MakeNameEx(0x00019584, "ETC_DIAG_KE_TPS_VS_MAF_ACT_DOWN_COUNTER", nameFlags);
MakeRptCmt(0x00019584, "Amount to dec the tps vs MAF airflow act error count when no actuation error\nSHORTCARD");
MakeNameEx(0x00019585, "ETC_DIAG_KE_THR_HI_CTR_INC", nameFlags);
MakeNameEx(0x00019586, "ETC_DIAG_KE_THR_HI_CTR_POS_ERR_DEC", nameFlags);
MakeNameEx(0x00019587, "ETC_DIAG_KE_THR_HI_CTR_NEG_ERR_DEC", nameFlags);
MakeNameEx(0x00019588, "ETC_DIAG_KE_THR_HI_CTR_NEG_THRESH_DEC", nameFlags);
MakeNameEx(0x00019589, "ETC_DIAG_KE_THR_LO_CTR_INC", nameFlags);
MakeNameEx(0x0001958A, "ETC_DIAG_KE_THR_LO_CTR_NEG_ERR_DEC", nameFlags);
MakeNameEx(0x0001958B, "ETC_DIAG_KE_THR_LO_CTR_POS_ERR_DEC", nameFlags);
MakeNameEx(0x0001958C, "ETC_DIAG_KE_THR_LO_CTR_POS_THRESH_DEC", nameFlags);
MakeNameEx(0x0001958E, "MANIFOLD_KE_MAP_DEFAULT_SLOPE", nameFlags);
MakeRptCmt(0x0001958E, "Manifold absolute pressure scaling factor used to convert cylinder air mass to manifold pressure for default calculation.\nkPa/Gram/Cylinder");
MakeNameEx(0x00019590, "MANIFOLD_KV_MAP_DEFAULT_OFFSET", nameFlags);
MakeRptCmt(0x00019590, "Manifold absolute pressure offset value for defaultcalculation.\n");
MakeNameEx(0x000195B2, "MANIFOLD_KE_MAP_DEFAULT_ENGINE_NOT_RUNNIN", nameFlags);
MakeRptCmt(0x000195B2, "Manifold absolute pressure offset value for defaultcalculation.\nkPa");
MakeNameEx(0x000195B4, "MANIFOLD_KE_MAF_DEFAULT_SLOPE", nameFlags);
MakeNameEx(0x000195B6, "MANIFOLD_KE_MAF_DEFAULT_MINIMUM", nameFlags);
MakeNameEx(0x000195B8, "MANIFOLD_KE_MAP_SENSOR_SCALE_FACTOR", nameFlags);
MakeRptCmt(0x000195B8, "Manifold absolute pressure sensor scaling factor.\nkPa/Count");
MakeNameEx(0x000195BA, "MANIFOLD_KE_MAP_SENSOR_OFFSET", nameFlags);
MakeRptCmt(0x000195BA, "Manifold absolute pressure sensor offset value.\nkPa");
MakeNameEx(0x000195BC, "T_DG_TASKS_KE_MAN_VSS_COOLANT_TEMPERATURE", nameFlags);
MakeRptCmt(0x000195BC, "Disable VSS diagnostic below this temperature.\nDegrees C");
MakeNameEx(0x000195BE, "T_DG_TASKS_KE_MAN_VSS_DELAY", nameFlags);
MakeRptCmt(0x000195BE, "Delay time to meet enable criteria, before checking VSS.\nCounts");
MakeNameEx(0x000195C0, "T_DG_TASKS_KE_MAN_VSS_DIAG_FAIL", nameFlags);
MakeRptCmt(0x000195C0, "Number of failures to fail the code.\nCounts");
MakeNameEx(0x000195C2, "T_DG_TASKS_KE_MAN_VSS_DIAG_MAX_THROTTLE", nameFlags);
MakeRptCmt(0x000195C2, "Diagnostic does not run above this throttle position.\nPercent");
MakeNameEx(0x000195C4, "T_DG_TASKS_KE_MAN_VSS_DIAG_MIN_THROTTLE", nameFlags);
MakeRptCmt(0x000195C4, "Diagnostic does not run below this throttle position.\nPercent");
MakeNameEx(0x000195C6, "T_DG_TASKS_KE_MAN_VSS_DIAG_PASS", nameFlags);
MakeRptCmt(0x000195C6, "Number of passes to pass the code.\nCounts");
MakeNameEx(0x000195C8, "T_DG_TASKS_KE_MAN_VSS_DIAG_RPM", nameFlags);
MakeRptCmt(0x000195C8, "Diagnostic does not run below this RPM.\nRPM");
MakeNameEx(0x000195CA, "T_DG_TASKS_KV_MAN_VSS_DIAG_MAX_MAP", nameFlags);
MakeRptCmt(0x000195CA, "Diagnostic does not run above this pressure.\nkPa");
MakeNameEx(0x000195CE, "T_DG_TASKS_KV_MAN_VSS_DIAG_MIN_MAP", nameFlags);
MakeRptCmt(0x000195CE, "Diagnostic does not run below this pressure.\nkPa");
MakeNameEx(0x000195D2, "T_DG_TASKS_KE_CLUTCH_SWITCH_FAIL_COUNT_MAX", nameFlags);
MakeRptCmt(0x000195D2, "If Clutch_Switch_Fail_Count exceeds this calibration, a clutch switch failure will be logged to the diagnostic executive\nCounts");
MakeNameEx(0x000195D3, "T_DG_TASKS_KE_CLUTCH_SWITCH_SAMPLE_COUNT_MA", nameFlags);
MakeRptCmt(0x000195D3, "If Clutch_Switch_Sample_Count exceeds this calibration, a clutch switch test passed will be logged to the diagnostic executive\nCounts");
MakeNameEx(0x000195D4, "T_DG_TASKS_KE_PRNDL_CKT_FAIL_COUNT_MAX", nameFlags);
MakeRptCmt(0x000195D4, "If PRNDL_Ckt_Fail_Count exceeds this value, PRNDL_Range_Fault will be logged to the diagnostic.\nCounts");
MakeNameEx(0x000195D5, "T_DG_TASKS_KE_PRNDL_CKT_SAMPLE_COUNT_MAX", nameFlags);
MakeRptCmt(0x000195D5, "If PRNDL_Ckt_Sample_Count exceeds this value, PRNDL_Range_Passed will be logged to the diagnostic.\nCounts");
MakeNameEx(0x000195D6, "T_DG_TASKS_KE_PRNDL_PNSWITCH_DR_FAIL_CNT", nameFlags);
MakeNameEx(0x000195D7, "T_DG_TASKS_KE_PRNDL_PNSWITCH_DR_PASS_CNT", nameFlags);
MakeNameEx(0x000195D8, "T_DG_TASKS_KE_PRNDL_PNSWITCH_PN_FAIL_CNT", nameFlags);
MakeNameEx(0x000195D9, "T_DG_TASKS_KE_PRNDL_PNSWITCH_PN_PASS_CNT", nameFlags);
MakeNameEx(0x000195DA, "T_DG_TASKS_KE_CLUTCH_VEHICLE_SPEED_THRESH", nameFlags);
MakeRptCmt(0x000195DA, "The vehicle speed threshold at which there should be at least one transmission clutch switch transition.\nMPH");
MakeNameEx(0x000195DC, "T_DG_TASKS_KE_PRNDL_PNSWITCH_ENG_RUN_MIN", nameFlags);
MakeNameEx(0x000195DE, "T_DG_TASKS_KE_PRNDL_PNSWITCH_GEAR_MIN", nameFlags);
MakeNameEx(0x000195E0, "T_DG_TASKS_KE_PRNDL_PNSWITCH_THROTTLE_MIN", nameFlags);
MakeNameEx(0x000195E2, "T_DG_TASKS_KE_PRNDL_PNSWITCH_TORQUE_MIN", nameFlags);
MakeRptCmt(0x000195E2, "Engine troque must be greater than or equal to this in order to run Park/Neutral test of the PRNDL_Switch diagnostic (P706).\nFoot_Pounds");
MakeNameEx(0x000195E4, "T_DG_TASKS_KE_PRNDL_PNSWITCH_VEH_SPD_MIN", nameFlags);
MakeNameEx(0x000195E6, "T_DG_TASKS_KE_PRNDL_PNSWITCH_VOLTAGE_MIN", nameFlags);
MakeNameEx(0x000195E7, "T_DG_TASKS_KE_PRNDL_PNSWITCH_VOLTAGE_MAX", nameFlags);
MakeNameEx(0x000195E8, "VOLTAGE_MONITOR_KE_SA_V5B1_FRACTION_LOW", nameFlags);
MakeRptCmt(0x000195E8, "Minimum threshold that the ratio of V5B1 voltage to 5volt reference can be before setting a fault.\nUnitless");
MakeNameEx(0x000195EA, "VOLTAGE_MONITOR_KE_SA_V5B1_FRACTION_HIGH", nameFlags);
MakeRptCmt(0x000195EA, "Maximum threshold that the ratio of V5B1 voltage to 5volt reference can be before setting a fault.\nUnitless");
MakeNameEx(0x000195EC, "VOLTAGE_MONITOR_KE_SA_V5B2_FRACTION_LOW", nameFlags);
MakeRptCmt(0x000195EC, "Minimum threshold that the ratio of V5B2 voltage to 5volt reference can be before setting a fault.\nUnitless");
MakeNameEx(0x000195EE, "VOLTAGE_MONITOR_KE_SA_V5B2_FRACTION_HIGH", nameFlags);
MakeRptCmt(0x000195EE, "Maximum threshold that the ratio of V5B2 voltage to 5volt reference can be before setting a fault.\nUnitless");
MakeNameEx(0x00019600, "TRANCALIBRATIONS_HEADER", nameFlags);
MakeRptCmt(0x00019600, "Use this cal to identify the transmission calibration set\nCal_ID_Record");
MakeNameEx(0x0001961C, "TRANS_IO_KE_TRANSFER_CASE_RATIO", nameFlags);
MakeRptCmt(0x0001961C, "Ratio of trans output speed to transfer case output.\nFactor");
MakeNameEx(0x0001961E, "TRANS_IO_KE_TRANSMISSION_TYPE", nameFlags);
MakeRptCmt(0x0001961E, "This determines which type of transmission is on the vehicle.\nXmsn. Type");
MakeNameEx(0x0001961F, "TRANS_IO_KE_MANUAL_TRANSMISSION_SPEEDS", nameFlags);
MakeRptCmt(0x0001961F, "Used to configure Class 2 3A3C transmission option message for manual transmissions.\nXmsn_Spd_Type");
MakeNameEx(0x00019620, "TRANS_IO_KE_REVERSE_LOCKOUT_EQUIPPED", nameFlags);
MakeRptCmt(0x00019620, "Set TRUE if manual transmission has reverse lockout control solenoid.\nBoolean");
MakeNameEx(0x00019621, "TRANS_IO_KE_ALLISON_LCT_MODEL", nameFlags);
MakeRptCmt(0x00019621, "Used to configure Class 2 3A3C transmission option message for Allison LCT applications.\nAllison_LCT_Model_Type");
MakeNameEx(0x00019622, "TRANS_IO_KE_FORCE_MOTOR_FREQUENCY", nameFlags);
MakeRptCmt(0x00019622, "Frequency at which to operate the Force Motor output.\nHertz");
MakeNameEx(0x00019624, "TRANS_IO_KE_CLUTCH_SWITCH_TYPE", nameFlags);
MakeRptCmt(0x00019624, "Describes the type of clutch switch, if any, used on thevehicle.\nNo_switch/Closed to IGN/GRN");
MakeNameEx(0x00019626, "TRANS_IO_KE_PRNDL_ERROR_TIME", nameFlags);
MakeRptCmt(0x00019626, "Force DRIVE4 value if PRNDL reading is bad for this length of time.\nSeconds");
MakeNameEx(0x00019628, "TRANS_IO_KE_PRNDL_GOOD_TIME", nameFlags);
MakeRptCmt(0x00019628, "Update PRNDL position if PRNDL reading is good for this length of time.\nSeconds");
MakeNameEx(0x0001962A, "TRANS_IO_KE_PSM_ERROR_TIME", nameFlags);
MakeRptCmt(0x0001962A, "Force DRIVE4 value if PSM reading is bad for this length of time.\nSeconds");
MakeNameEx(0x0001962C, "TRANS_IO_KE_PSM_GOOD_TIME", nameFlags);
MakeRptCmt(0x0001962C, "Update PSM position if PSM reading is good for this length of time.\nSeconds");
MakeNameEx(0x0001962E, "TRANS_IO_KE_RPM_DROP", nameFlags);
MakeRptCmt(0x0001962E, "PN to Drive shift occurred if RPM drops more than this.\nRPM");
MakeNameEx(0x00019630, "TRANS_IO_KE_RPM_RISE", nameFlags);
MakeRptCmt(0x00019630, "Drive to PN shift occurred if RPM rises more than this.\nRPM");
MakeNameEx(0x00019632, "TRANS_IO_KE_SF_PULSES_PER_REVOLUTION", nameFlags);
MakeRptCmt(0x00019632, "Transmission output speed sensor scaling factor.\nPulses/Rev");
MakeNameEx(0x00019634, "TRANS_IO_KE_SF_MAX_TIME_SINCE_LAST_PULSE", nameFlags);
MakeRptCmt(0x00019634, "If no transmission output speed pulses have been seen for this length of time then the speed is considered to be zero.\nSeconds");
MakeNameEx(0x00019636, "TRANS_IO_KE_NEUTRAL_START_SWITCH_EQUIPPED", nameFlags);
MakeRptCmt(0x00019636, "True if vehicle is equipped with a Neutral_Start_Switch or Bottom_of_Travel_Clutch_Switch.\nBoolean");
MakeNameEx(0x00019638, "TRANS_IO_KE_XMIS_MODULATOR_OFF_DELAY_TIME", nameFlags);
MakeNameEx(0x0001963A, "TRANS_IO_KV_XMIS_MODULATOR_TPS", nameFlags);
MakeRptCmt(0x0001963A, "Throttle position above this cal enables high load shiftpattern in the transmission.\nPercent");
MakeNameEx(0x00019650, "TRANS_IO_KV_XMIS_MODULATOR_TPS_HYSTERESIS", nameFlags);
MakeRptCmt(0x00019650, "KV_Xmis_Modulator_TPS minus this cal allows high load shiftpattern to be disabled.\nPercent");
MakeNameEx(0x00019666, "TRANS_IO_KE_MANUAL_MODE_ALLOWED", nameFlags);
MakeRptCmt(0x00019666, "This determines whether manual mode is allowed as a shift pattern.\nBOOLEAN");
MakeNameEx(0x00019667, "TRANS_IO_KE_MNP_TYPE", nameFlags);
MakeRptCmt(0x00019667, "This determines how many shift pattern switches are used as input.\nSwitches");
MakeNameEx(0x00019668, "TRANS_IO_KE_NE_TOSS_FIRST_LOW", nameFlags);
MakeRptCmt(0x00019668, "This is the lower numerical value of NE/TOSS in first gear.MUST BE less than KE_NE_TOSS_First_High.\nNE_TOSS_Ratio");
MakeNameEx(0x0001966A, "TRANS_IO_KE_NE_TOSS_FIRST_HIGH", nameFlags);
MakeRptCmt(0x0001966A, "This is the higher numerical value of NE/TOSS in first gear.MUST BE greater than KE_NE_TOSS_First_Low.\nNE_TOSS_Ratio");
MakeNameEx(0x0001966C, "TRANS_IO_KE_NE_TOSS_SECOND_LOW", nameFlags);
MakeRptCmt(0x0001966C, "This is the lower numerical value of NE/TOSS in second gear.MUST BE less than KE_NE_TOSS_Second_High.\nNE_TOSS_Ratio");
MakeNameEx(0x0001966E, "TRANS_IO_KE_NE_TOSS_SECOND_HIGH", nameFlags);
MakeRptCmt(0x0001966E, "This is the higher numerical value of NE/TOSS in second gear.MUST BE greater than KE_NE_TOSS_Second_Low.\nNE_TOSS_Ratio");
MakeNameEx(0x00019670, "TRANS_IO_KE_NE_TOSS_THIRD_LOW", nameFlags);
MakeRptCmt(0x00019670, "This is the lower numerical value of NE/TOSS in third gear.MUST BE less than KE_NE_TOSS_Third_High.\nNE_TOSS_Ratio");
MakeNameEx(0x00019672, "TRANS_IO_KE_NE_TOSS_THIRD_HIGH", nameFlags);
MakeRptCmt(0x00019672, "This is the higher numerical value of NE/TOSS in third gear.MUST BE greater than KE_NE_TOSS_Third_Low.\nNE_TOSS_Ratio");
MakeNameEx(0x00019674, "TRANS_IO_KE_NE_TOSS_FOURTH_LOW", nameFlags);
MakeRptCmt(0x00019674, "This is the lower numerical value of NE/TOSS in fourth gear.MUST BE less than KE_NE_TOSS_Fourth_High.\nNE_TOSS_Ratio");
MakeNameEx(0x00019676, "TRANS_IO_KE_NE_TOSS_FOURTH_HIGH", nameFlags);
MakeRptCmt(0x00019676, "This is the higher numerical value of NE/TOSS in fourth gear.MUST BE greater than KE_NE_TOSS_Fourth_Low.\nNE_TOSS_Ratio");
MakeNameEx(0x00019678, "TRANS_IO_KE_NE_TOSS_FIFTH_LOW", nameFlags);
MakeRptCmt(0x00019678, "This is the lower numerical value of NE/TOSS in fifth gear.MUST BE less than KE_NE_TOSS_Fifth_High.\nNE_TOSS_Ratio");
MakeNameEx(0x0001967A, "TRANS_IO_KE_NE_TOSS_FIFTH_HIGH", nameFlags);
MakeRptCmt(0x0001967A, "This is the higher numerical value of NE/TOSS in fifth gear.MUST BE greater than KE_NE_TOSS_Fifth_Low.\nNE_TOSS_Ratio");
MakeNameEx(0x0001967C, "TRANS_IO_KE_NE_TOSS_SIXTH_LOW", nameFlags);
MakeRptCmt(0x0001967C, "This is the lower numerical value of NE/TOSS in sixth gear.MUST BE less than KE_NE_TOSS_Sixth_High.\nNE_TOSS_Ratio");
MakeNameEx(0x0001967E, "TRANS_IO_KE_NE_TOSS_SIXTH_HIGH", nameFlags);
MakeRptCmt(0x0001967E, "This is the higher numerical value of NE/TOSS in sixth gear.MUST BE greater than KE_NE_TOSS_Sixth_Low.\nNE_TOSS_Ratio");
MakeNameEx(0x00019680, "TRANS_IO_KE_NE_TOSS_RATIO_TRANSITION", nameFlags);
MakeRptCmt(0x00019680, "This is the value NE_TOSS_Ratio is set to during a PCMstate transition.\nNE_TOSS_Ratio");
MakeNameEx(0x00019682, "TRANS_IO_KE_REVERSE_ENABLE_ON", nameFlags);
MakeRptCmt(0x00019682, "The vehicle speed below which reverse is allowed.\nMPH");
MakeNameEx(0x00019684, "TRANS_IO_KE_REVERSE_ENABLE_OFF", nameFlags);
MakeRptCmt(0x00019684, "The vehicle speed above which reverse is not allowed.\nMPH");
MakeNameEx(0x00019686, "TRANS_IO_KE_CARS_FIRST_MIN", nameFlags);
MakeRptCmt(0x00019686, "This is the minimum value of NE_TOSS_Ratio in the first CARSgear. MUST BE less than KE_CARS_First_Max.\nNE_TOSS_Ratio");
MakeNameEx(0x00019688, "TRANS_IO_KE_CARS_FIRST_MAX", nameFlags);
MakeRptCmt(0x00019688, "This is the maximum value of NE_TOSS_Ratio in the first CARSgear. MUST BE greater than KE_CARS_First_Min.\nNE_TOSS_Ratio");
MakeNameEx(0x0001968A, "TRANS_IO_KE_CARS_FINAL_MIN", nameFlags);
MakeRptCmt(0x0001968A, "This is the minimum value of NE_TOSS_Ratio in the final CARSgear. MUST BE less than KE_CARS_Final_Max.\nNE_TOSS_Ratio");
MakeNameEx(0x0001968C, "TRANS_IO_KE_CARS_FINAL_MAX", nameFlags);
MakeRptCmt(0x0001968C, "This is the maximum value of NE_TOSS_Ratio in the final CARSgear. MUST BE greater than KE_CARS_Final_Min.\nNE_TOSS_Ratio");
MakeNameEx(0x0001968E, "TRANS_IO_KE_CARS_MAX_PEDAL", nameFlags);
MakeRptCmt(0x0001968E, "Maximum accelerator pedal position for CARS to be enabled.\nPercent");
MakeNameEx(0x00019690, "TRANS_IO_KE_CARS_COOLANT", nameFlags);
MakeRptCmt(0x00019690, "Minimum coolant for CARS to be enabled.\nDegreesC");
MakeNameEx(0x00019692, "TRANS_IO_KE_CARS_MAX_SPEED", nameFlags);
MakeRptCmt(0x00019692, "Vehicle speeds greater than this will disable CARS.\nMPH");
MakeNameEx(0x00019694, "TRANS_IO_KE_CARS_RESET_SPEED", nameFlags);
MakeRptCmt(0x00019694, "Vehicle speeds equal to or less than this will reset the CARS logic to look for the vehicle speed window.\nMPH");
MakeNameEx(0x00019696, "TRANS_IO_KE_CARS_ENABLE_SPEED", nameFlags);
MakeRptCmt(0x00019696, "Vehicle speeds equal to or greater than this will be the CARS on speed (if currently not on).\nMPH");
MakeNameEx(0x00019698, "TRANS_IO_KE_CARS_SPEED_HYSTERESIS", nameFlags);
MakeRptCmt(0x00019698, "Vehicle speeds hysteresis for low side of vehicle speedenables of CARS.\nMPH");
MakeNameEx(0x0001969A, "TRANS_IO_KE_CARS_BARO_LOW", nameFlags);
MakeRptCmt(0x0001969A, "Baro pressure below which CARS is disabled (must be lowerthan KE_CARS_Baro_Low).\nkPa");
MakeNameEx(0x0001969C, "TRANS_IO_KE_CARS_BARO_HIGH", nameFlags);
MakeRptCmt(0x0001969C, "Baro pressure below which CARS is disabled (must be higherthan KE_CARS_Baro_Low).\nkPa");
MakeNameEx(0x0001969E, "TRANS_IO_KE_CARS_BULB_TIME", nameFlags);
MakeRptCmt(0x0001969E, "The amount of time to turn CARS light on during bulb check.\nSeconds");
MakeNameEx(0x000196A0, "TRANS_IO_KE_CARS_BULB_CHECK", nameFlags);
MakeRptCmt(0x000196A0, "Determine if the bulb check is to be used.\nBoolean");
MakeNameEx(0x000196A1, "TRANS_IO_KE_EXECUTE_CARS_ALGORITHM", nameFlags);
MakeRptCmt(0x000196A1, "Set to TRUE if the CARS (skip shift) logic should be executed\nBoolean");
MakeNameEx(0x000196A2, "TRANS_IO_KE_CONTROL_CARS_LIGHT", nameFlags);
MakeRptCmt(0x000196A2, "Set to TRUE if the CARS (skip shift) logic should directlycontrol the CARS light PCM output. (Class2 message not used)\nBoolean");
MakeNameEx(0x000196A3, "TRANS_IO_KE_MANUAL_XMSN_HAS_TEMP_SENSOR", nameFlags);
MakeNameEx(0x000196A4, "TCM_IO_INTERFACE_KE_TRANS_DIAG_SYSTEM_VOLT_LOW", nameFlags);
MakeRptCmt(0x000196A4, "System voltage below which transmission diagnostics willbe disabled.\nVolts");
MakeNameEx(0x000196A5, "TCM_IO_INTERFACE_KE_TRANS_DIAG_SYSTEM_VOLT_HIGH", nameFlags);
MakeRptCmt(0x000196A5, "System voltage above which transmission diagnostics willbe disabled.\nVolts");
MakeNameEx(0x000196A6, "TCM_IO_INTERFACE_KE_ALLISON_TCM_VOLTAGE", nameFlags);
MakeRptCmt(0x000196A6, "Voltage below which the TCM MIL request will not be monitored\nVolts");
MakeNameEx(0x000196A8, "TCM_IO_INTERFACE_KE_TCM_POWERUP_INTEGRITY_DELAY", nameFlags);
MakeRptCmt(0x000196A8, "Time after ignition on that the PCM will start monitoring theAllison TCM MIL request for line integrity check - P0802\nSeconds");
MakeNameEx(0x000196AA, "TCM_IO_INTERFACE_KE_TCM_POWERUP_INTEGRITY_COMPLET", nameFlags);
MakeRptCmt(0x000196AA, "Time after ignition on that the PCM will stop monitoring theAllison TCM MIL request for line integrity check - P0802\nSeconds");
MakeNameEx(0x000196AC, "TCM_IO_INTERFACE_KE_TCM_GENERAL_DELAY_REQUEST", nameFlags);
MakeNameEx(0x000196AE, "TCM_IO_INTERFACE_KE_TCM_MIL_REQUEST_TIME", nameFlags);
MakeRptCmt(0x000196AE, "Allison TCM MIL request line must be active for this amount of time before PCM will log a P0700 and illuminate the MIL.\nSeconds");
MakeNameEx(0x000196B0, "TCM_IO_INTERFACE_KE_TCC_DC_LOW_THRESH", nameFlags);
MakeRptCmt(0x000196B0, "When the TCC PWM is below this threshold the TCC PWM isconsidered OFF.\nPercent");
MakeNameEx(0x000196B2, "TCM_IO_INTERFACE_KE_TCC_DC_HIGH_THRESH", nameFlags);
MakeRptCmt(0x000196B2, "When the TCC PWM is above this threshold the TCC PWM isconsidered ON.\nPercent");
MakeNameEx(0x000196B4, "TCM_OPTIONS_K_FOUR_WHEEL_DRIVE_AVAILABLE", nameFlags);
MakeRptCmt(0x000196B4, "If TRUE, vehicle has four wheel drive.\nBOOLEAN");
MakeNameEx(0x000196B5, "TCM_OPTIONS_K_INPUT_SPEED_PRESENT", nameFlags);
MakeRptCmt(0x000196B5, "If TRUE, a transmission input speed sensor is present.\nBOOLEAN");
MakeNameEx(0x000196B6, "TCM_OPTIONS_K_INP_SPD_SENSOR_AFTER_OVERDRV", nameFlags);
MakeRptCmt(0x000196B6, "If TRUE, a transmission input speed sensor after overdrive is present.\nBOOLEAN");
MakeNameEx(0x000196B7, "TCM_OPTIONS_K_TCC_ENABLE_SOLENOID_PRESENT", nameFlags);
MakeRptCmt(0x000196B7, "Indicates whether the transmission has a TCC enable solenoid.\nBOOLEAN");
MakeNameEx(0x000196B8, "TCM_OPTIONS_KE_TRANS_HAS_TCC_RELEASE_SWITCH", nameFlags);
MakeRptCmt(0x000196B8, "Trans has TCC Release Switch.  Used with 4T65E transmissions.\nBOOLEAN");
MakeNameEx(0x000196BA, "TCM_OPTIONS_KE_TCC_CONTROL_OPERATING_FREQ", nameFlags);
MakeRptCmt(0x000196BA, "Used to tune the TCC control solenoid operating frequency\nHertz");
MakeNameEx(0x000196BC, "TCM_OPTIONS_KE_TRANS_HAS_SIGNED_TORQUE_MODEL", nameFlags);
MakeRptCmt(0x000196BC, "When TRUE, allows for signed engine torque values and uses the negative torque model.\nT/F");
MakeNameEx(0x000196BD, "TCM_OPTIONS_KE_SIGNED_TRQ_SHIFT_PRESS_ENBL", nameFlags);
MakeRptCmt(0x000196BD, "When TRUE, signed torque pressure control is enabled if KE_Trans_Has_Signed_Torque_Model is also TRUE.\nT/F");
MakeNameEx(0x000196BE, "TCM_OPTIONS_K_TRANS_HAS_THIRD_GEAR_DEFAULT", nameFlags);
MakeRptCmt(0x000196BE, "If TRUE, then the transmission will assume third gear when the wiring harness is disabled; otherwise, second gear.\nBOOLEAN");
MakeNameEx(0x000196BF, "TCM_OPTIONS_K_USE_STALL_ABUSE_TORQUE_RED", nameFlags);
MakeRptCmt(0x000196BF, "If TRUE, a stall torque reduction and/or abuse torquereduction condition is present.\nBOOLEAN");
MakeNameEx(0x000196C0, "TCM_OPTIONS_K_TRANS_HAS_ECCC", nameFlags);
MakeRptCmt(0x000196C0, "If TRUE, Transmission has ECCC\nBOOLEAN");
MakeNameEx(0x000196C1, "TCM_OPTIONS_K_D32_PRESS_BIAS_CONTROL_AVAIL", nameFlags);
MakeRptCmt(0x000196C1, "If TRUE, electronic control of the 3-2 downshift timing is available.\nBOOLEAN");
MakeNameEx(0x000196C2, "TCM_OPTIONS_KE_TCC_REL_DBNC_TIME", nameFlags);
MakeRptCmt(0x000196C2, "Determines the amount of time the TCC release switch status waits before transitioning to a new state. (used with 4T65E).\nSeconds");
MakeNameEx(0x000196C4, "TCM_OPTIONS_KE_FM_FDBCK_CURR_CRTN_ENABLE", nameFlags);
MakeRptCmt(0x000196C4, "TRUE if force motor feedback current circuit characterization is available and desired, else FALSE.\nT/F");
MakeNameEx(0x000196C5, "TCM_OPTIONS_K_DEFAULT_GEAR", nameFlags);
MakeRptCmt(0x000196C5, "Default hydraulic gear for the transmission.\nGear");
MakeNameEx(0x000196C6, "T_INP_SPEED_KE_INPUT_SPD_ZERO_PULSE_TIME", nameFlags);
MakeRptCmt(0x000196C6, "Time with out input speed pulses to assume zero speed.\nSeconds");
MakeNameEx(0x000196C8, "T_INP_SPEED_KE_CALCULATED_PULSES_PER_REV", nameFlags);
MakeRptCmt(0x000196C8, "Defines the number of input speed sensor pulses as Input_Speed_Pulses_Per_Rev / KE_Drive_Sproket_Ratio.\nPulses/Rev");
MakeNameEx(0x000196CA, "T_PRESSURE_TABLES_KV_BASE_PRESSURE_NORMAL_2", nameFlags);
MakeRptCmt(0x000196CA, "Base pressure for normal pressure pattern, 2nd Gear\nPSI");
MakeNameEx(0x0001970C, "T_PRESSURE_TABLES_KV_BASE_PRESSURE_NORMAL_3", nameFlags);
MakeRptCmt(0x0001970C, "Base pressure for normal pressure pattern, 3rd Gear\nPSI");
MakeNameEx(0x0001974E, "T_PRESSURE_TABLES_KV_BASE_PRESSURE_NORMAL_4", nameFlags);
MakeRptCmt(0x0001974E, "Base pressure for normal pressure pattern, 4th Gear\nPSI");
MakeNameEx(0x00019790, "T_PRESSURE_TABLES_KV_BASE_PRESSURE_PERFORMANCE_2", nameFlags);
MakeRptCmt(0x00019790, "Base pressure for performance pressure pattern, 2nd Gear\nPSI");
MakeNameEx(0x000197D2, "T_PRESSURE_TABLES_KV_BASE_PRESSURE_PERFORMANCE_3", nameFlags);
MakeRptCmt(0x000197D2, "Base pressure for performance pressure pattern, 3rd Gear\nPSI");
MakeNameEx(0x00019814, "T_PRESSURE_TABLES_KV_BASE_PRESSURE_PERFORMANCE_4", nameFlags);
MakeRptCmt(0x00019814, "Base pressure for performance pressure pattern, 4th Gear\nPSI");
MakeNameEx(0x00019856, "T_PRESSURE_TABLES_KA_2_DOWN_TEMP_PRESSURE_MOD", nameFlags);
MakeRptCmt(0x00019856, "3D Downshift Pressure Temperature Compensation\nPSI_S");
MakeNameEx(0x00019900, "T_PRESSURE_TABLES_KA_3_DOWN_TEMP_PRESSURE_MOD", nameFlags);
MakeRptCmt(0x00019900, "3D Downshift Pressure Temperature Compensation\nPSI_S");
MakeNameEx(0x000199AA, "T_PRESSURE_TABLES_KA_4_DOWN_TEMP_PRESSURE_MOD", nameFlags);
MakeRptCmt(0x000199AA, "3D Downshift Pressure Temperature Compensation\nPSI_S");
MakeNameEx(0x00019A54, "T_PRESSURE_TABLES_KA_2ND_PRESSURE_TEMP_COMP_TABLE", nameFlags);
MakeRptCmt(0x00019A54, "3D Pressure Temperature Compensation\nPSI_S");
MakeNameEx(0x00019AFE, "T_PRESSURE_TABLES_KA_3RD_PRESSURE_TEMP_COMP_TABLE", nameFlags);
MakeRptCmt(0x00019AFE, "3D Pressure Temperature Compensation\nPSI_S");
MakeNameEx(0x00019BA8, "T_PRESSURE_TABLES_KA_4TH_PRESSURE_TEMP_COMP_TABLE", nameFlags);
MakeRptCmt(0x00019BA8, "3D Pressure Temperature Compensation\nPSI_S");
MakeNameEx(0x00019C52, "T_PRESSURE_TABLES_KV_1_BRAKING_PRESS_TABLE", nameFlags);
MakeRptCmt(0x00019C52, "Braking pressure for 1st gear\nPSI");
MakeNameEx(0x00019C74, "T_PRESSURE_TABLES_KV_2_BRAKING_PRESS_TABLE", nameFlags);
MakeRptCmt(0x00019C74, "Braking pressure for 2nd gear\nPSI");
MakeNameEx(0x00019C96, "T_PRESSURE_TABLES_KV_3_BRAKING_PRESS_TABLE", nameFlags);
MakeRptCmt(0x00019C96, "Braking pressure for 3rd gear\nPSI");
MakeNameEx(0x00019CB8, "T_PRESSURE_TABLES_KV_2_1_NORMAL_PRESS_MODIFIER", nameFlags);
MakeRptCmt(0x00019CB8, "Normal downshift pressure offset modifier for 2nd gear\nPSI_S");
MakeNameEx(0x00019CDA, "T_PRESSURE_TABLES_KV_3_2_NORMAL_PRESS_MODIFIER", nameFlags);
MakeRptCmt(0x00019CDA, "Normal downshift pressure offset modifier for 3rd gear\nPSI_S");
MakeNameEx(0x00019CFC, "T_PRESSURE_TABLES_KV_4_3_NORMAL_PRESS_MODIFIER", nameFlags);
MakeRptCmt(0x00019CFC, "Normal downshift pressure offset modifier for 4th gear\nPSI_S");
MakeNameEx(0x00019D1E, "T_PRESSURE_TABLES_KV_BASE_PRESSURE_BRAKE_ON_ELE_2", nameFlags);
MakeRptCmt(0x00019D1E, "Used todetermine second gear Base_Pressure during downshifts whenbraking element is applied - negative torque model.\nPSI");
MakeNameEx(0x00019D5E, "T_PRESSURE_TABLES_KV_BASE_PRESSURE_BRAKE_ON_ELE_3", nameFlags);
MakeRptCmt(0x00019D5E, "Used todetermine third gear Base_Pressure during downshifts whenbraking element is applied - negative torque model.\nPSI");
MakeNameEx(0x00019D9E, "T_PRESSURE_TABLES_KV_BASE_PRESSURE_BRAKE_ON_ELE_4", nameFlags);
MakeRptCmt(0x00019D9E, "Used todetermine fourth gear Base_Pressure during downshifts whenbraking element is applied - negative torque model.\nPSI");
MakeNameEx(0x00019DDE, "T_PRESSURE_TABLES_KA_1_2_GEARBOX_INERTIA_TRQ_MULT", nameFlags);
MakeRptCmt(0x00019DDE, "Base pressure multiplier for a 1-2 upshift.\nScaler");
MakeNameEx(0x00019E88, "T_PRESSURE_TABLES_KA_2_3_GEARBOX_INERTIA_TRQ_MULT", nameFlags);
MakeRptCmt(0x00019E88, "Base pressure multiplier for a 1-2 upshift.\nScaler");
MakeNameEx(0x00019F32, "T_PRESSURE_TABLES_KA_3_4_GEARBOX_INERTIA_TRQ_MULT", nameFlags);
MakeRptCmt(0x00019F32, "Base pressure multiplier for a 1-2 upshift.\nScaler");
MakeNameEx(0x00019FDC, "T_SEM_KV_DRIVE_RANGE_TIME", nameFlags);
MakeRptCmt(0x00019FDC, "Time limit during which abuse mode may be active as a functionof temperature\nSeconds");
MakeNameEx(0x00019FFE, "T_SEM_KV_REVERSE_RANGE_TIME", nameFlags);
MakeRptCmt(0x00019FFE, "Time limit during which abuse mode may be active as a functionof temperature\nSeconds");
MakeNameEx(0x0001A020, "T_SEM_KV_FIRST_DN_PERCENT_TOT_TRQ_RED", nameFlags);
MakeRptCmt(0x0001A020, "Percentage of total torque reduction for 2-1 downshift\nPercent");
MakeNameEx(0x0001A042, "T_SEM_KV_SECOND_DN_PERCENT_TOT_TRQ_RED", nameFlags);
MakeRptCmt(0x0001A042, "Percentage of total torque reduction for 3-2 downshift\nPercent");
MakeNameEx(0x0001A064, "T_SEM_KV_THIRD_DN_PERCENT_TOT_TRQ_RED", nameFlags);
MakeRptCmt(0x0001A064, "Percentage of total torque reduction for 4-3 downshift\nPercent");
MakeNameEx(0x0001A086, "T_SEM_KV_UPSHIFT_TOT_TRQ_RED_NORM_2", nameFlags);
MakeRptCmt(0x0001A086, "Percentage of total torque reduction for 1-2 upshiftusing Normal pressure pattern\nPercent");
MakeNameEx(0x0001A0A8, "T_SEM_KV_UPSHIFT_TOT_TRQ_RED_NORM_3", nameFlags);
MakeRptCmt(0x0001A0A8, "Percentage of total torque reduction for 2-3 upshiftusing Normal pressure pattern\nPercent");
MakeNameEx(0x0001A0CA, "T_SEM_KV_UPSHIFT_TOT_TRQ_RED_NORM_4", nameFlags);
MakeRptCmt(0x0001A0CA, "Percentage of total torque reduction for 3-4 upshiftusing Normal pressure pattern\nPercent");
MakeNameEx(0x0001A0EC, "T_SEM_KV_UPSHIFT_TOT_TRQ_RED_PERF_2", nameFlags);
MakeRptCmt(0x0001A0EC, "Percentage of total torque reduction for 1-2 upshiftusing Performance pressure pattern\nPercent");
MakeNameEx(0x0001A10E, "T_SEM_KV_UPSHIFT_TOT_TRQ_RED_PERF_3", nameFlags);
MakeRptCmt(0x0001A10E, "Percentage of total torque reduction for 2-3 upshiftusing Performance pressure pattern\nPercent");
MakeNameEx(0x0001A130, "T_SEM_KV_UPSHIFT_TOT_TRQ_RED_PERF_4", nameFlags);
MakeRptCmt(0x0001A130, "Percentage of total torque reduction for 3-4 upshiftusing Performance pressure pattern\nPercent");
MakeNameEx(0x0001A152, "T_SHIFT_TABLES_KV_SHIFT_STAB_SHIFT_PATTRN_ENBLE", nameFlags);
MakeRptCmt(0x0001A152, "These flags will enable or disable ETC shift stabilization for the indicated shift pattern.\nT/F");
MakeNameEx(0x0001A15E, "T_SHIFT_TABLES_KV_1_2_NORMAL_LINE", nameFlags);
MakeRptCmt(0x0001A15E, "Normal 1st to 2nd gear upshift shift line table\nMPH");
MakeNameEx(0x0001A180, "T_SHIFT_TABLES_KV_2_3_NORMAL_LINE", nameFlags);
MakeRptCmt(0x0001A180, "Normal 2nd to 3rd gear upshift shift line table\nMPH");
MakeNameEx(0x0001A1A2, "T_SHIFT_TABLES_KV_3_4_NORMAL_LINE", nameFlags);
MakeRptCmt(0x0001A1A2, "Normal 3rd to 4th gear upshift shift line table\nMPH");
MakeNameEx(0x0001A1C4, "T_SHIFT_TABLES_KV_2_1_NORMAL_LINE", nameFlags);
MakeRptCmt(0x0001A1C4, "Normal 2nd to 1st gear downshift shift line table\nMPH");
MakeNameEx(0x0001A1E6, "T_SHIFT_TABLES_KV_3_2_NORMAL_LINE", nameFlags);
MakeRptCmt(0x0001A1E6, "Normal 3rd to 2nd gear downshift shift line table\nMPH");
MakeNameEx(0x0001A208, "T_SHIFT_TABLES_KV_4_3_NORMAL_LINE", nameFlags);
MakeRptCmt(0x0001A208, "Normal 4th to 3rd gear downshift shift line table\nMPH");
MakeNameEx(0x0001A22A, "T_SHIFT_TABLES_KV_1_2_CRUISE_LINE", nameFlags);
MakeRptCmt(0x0001A22A, "Cruise 1st to 2nd gear upshift shift line table\nMPH");
MakeNameEx(0x0001A24C, "T_SHIFT_TABLES_KV_2_3_CRUISE_LINE", nameFlags);
MakeRptCmt(0x0001A24C, "Cruise 2nd to 3rd gear upshift shift line table\nMPH");
MakeNameEx(0x0001A26E, "T_SHIFT_TABLES_KV_3_4_CRUISE_LINE", nameFlags);
MakeRptCmt(0x0001A26E, "Cruise 3rd to 4th gear upshift shift line table\nMPH");
MakeNameEx(0x0001A290, "T_SHIFT_TABLES_KV_2_1_CRUISE_LINE", nameFlags);
MakeRptCmt(0x0001A290, "Cruise 2nd to 1st gear downshift shift line table\nMPH");
MakeNameEx(0x0001A2B2, "T_SHIFT_TABLES_KV_3_2_CRUISE_LINE", nameFlags);
MakeRptCmt(0x0001A2B2, "Cruise 3rd to 2nd gear downshift shift line table\nMPH");
MakeNameEx(0x0001A2D4, "T_SHIFT_TABLES_KV_4_3_CRUISE_LINE", nameFlags);
MakeRptCmt(0x0001A2D4, "Cruise 4th to 3rd gear downshift shift line table\nMPH");
MakeNameEx(0x0001A2F6, "T_SHIFT_TABLES_KV_1_2_DRIVE_2_LINE", nameFlags);
MakeRptCmt(0x0001A2F6, "Drive-2 1st to 2nd gear upshift shift line table\nMPH");
MakeNameEx(0x0001A318, "T_SHIFT_TABLES_KE_2_3_DRIVE_2_LINE", nameFlags);
MakeRptCmt(0x0001A318, "Drive-2 2nd to 3rd gear downshift shift line cal\nMPH");
MakeNameEx(0x0001A31A, "T_SHIFT_TABLES_KV_2_1_DRIVE_2_LINE", nameFlags);
MakeRptCmt(0x0001A31A, "Drive-2 2nd to 1st gear downshift shift line table\nMPH");
MakeNameEx(0x0001A33C, "T_SHIFT_TABLES_KE_3_2_DRIVE_2_LINE", nameFlags);
MakeRptCmt(0x0001A33C, "Drive-2 3rd to 2nd gear downshift shift line cal\nMPH");
MakeNameEx(0x0001A33E, "T_SHIFT_TABLES_KE_1_2_DRIVE_LOW_LINE", nameFlags);
MakeRptCmt(0x0001A33E, "Drive-Low 1st to 2nd gear upshift shift line.\nMPH");
MakeNameEx(0x0001A340, "T_SHIFT_TABLES_KE_2_1_DRIVE_LOW_LINE", nameFlags);
MakeRptCmt(0x0001A340, "Drive-Low 2nd to 1st gear downshift shift line.\nMPH");
MakeNameEx(0x0001A342, "T_SHIFT_TABLES_KE_2_3_DRIVE_LOW_LINE", nameFlags);
MakeRptCmt(0x0001A342, "Drive-Low 2nd to 3rd gear upshift shift line.\nMPH");
MakeNameEx(0x0001A344, "T_SHIFT_TABLES_KE_3_2_DRIVE_LOW_LINE", nameFlags);
MakeRptCmt(0x0001A344, "Drive-Low 3rd to 2nd gear downshift shift line.\nMPH");
MakeNameEx(0x0001A346, "T_SHIFT_TABLES_KV_1_2_HP_EP_DELTA_LINE", nameFlags);
MakeRptCmt(0x0001A346, "Maximum amount shift point could be modified when inheater performance/engine protection mode\nMPH");
MakeNameEx(0x0001A368, "T_SHIFT_TABLES_KV_2_3_HP_EP_DELTA_LINE", nameFlags);
MakeRptCmt(0x0001A368, "Maximum amount shift point could be modified when inheater performance/engine protection mode\nMPH");
MakeNameEx(0x0001A38A, "T_SHIFT_TABLES_KV_3_4_HP_EP_DELTA_LINE", nameFlags);
MakeRptCmt(0x0001A38A, "Maximum amount shift point could be modified when inheater performance/engine protection mode\nMPH");
MakeNameEx(0x0001A3AC, "T_SHIFT_TABLES_KV_2_1_HP_EP_DELTA_LINE", nameFlags);
MakeRptCmt(0x0001A3AC, "Maximum amount shift point could be modified when inheater performance/engine protection mode\nMPH");
MakeNameEx(0x0001A3CE, "T_SHIFT_TABLES_KV_3_2_HP_EP_DELTA_LINE", nameFlags);
MakeRptCmt(0x0001A3CE, "Maximum amount shift point could be modified when inheater performance/engine protection mode\nMPH");
MakeNameEx(0x0001A3F0, "T_SHIFT_TABLES_KV_4_3_HP_EP_DELTA_LINE", nameFlags);
MakeRptCmt(0x0001A3F0, "Maximum amount shift point could be modified when inheater performance/engine protection mode\nMPH");
MakeNameEx(0x0001A412, "T_SHIFT_TABLES_KV_1_2_HOT_NORMAL_LINE", nameFlags);
MakeRptCmt(0x0001A412, "Hot normal 1st to 2nd gear upshift shift line.\nMPH");
MakeNameEx(0x0001A434, "T_SHIFT_TABLES_KV_2_3_HOT_NORMAL_LINE", nameFlags);
MakeRptCmt(0x0001A434, "Hot normal 2nd to 3rd gear upshift shift line.\nMPH");
MakeNameEx(0x0001A456, "T_SHIFT_TABLES_KV_3_4_HOT_NORMAL_LINE", nameFlags);
MakeRptCmt(0x0001A456, "Hot normal 3rd to 4th gear upshift shift line.\nMPH");
MakeNameEx(0x0001A478, "T_SHIFT_TABLES_KV_2_1_HOT_NORMAL_LINE", nameFlags);
MakeRptCmt(0x0001A478, "Hot normal 1st to 2nd gear upshift shift line.\nMPH");
MakeNameEx(0x0001A49A, "T_SHIFT_TABLES_KV_3_2_HOT_NORMAL_LINE", nameFlags);
MakeRptCmt(0x0001A49A, "Hot normal 2nd to 3rd gear upshift shift line.\nMPH");
MakeNameEx(0x0001A4BC, "T_SHIFT_TABLES_KV_4_3_HOT_NORMAL_LINE", nameFlags);
MakeRptCmt(0x0001A4BC, "Hot normal 3rd to 4th gear upshift shift line.\nMPH");
MakeNameEx(0x0001A4DE, "T_SHIFT_TABLES_KV_1_2_PERFORMANCE", nameFlags);
MakeRptCmt(0x0001A4DE, "Performance 1st to 2nd gear upshift shift line.\nMPH");
MakeNameEx(0x0001A500, "T_SHIFT_TABLES_KV_2_3_PERFORMANCE", nameFlags);
MakeRptCmt(0x0001A500, "Performance 2nd to 3rd gear upshift shift line.\nMPH");
MakeNameEx(0x0001A522, "T_SHIFT_TABLES_KV_3_4_PERFORMANCE", nameFlags);
MakeRptCmt(0x0001A522, "Performance 3rd to 4th gear upshift shift line.\nMPH");
MakeNameEx(0x0001A544, "T_SHIFT_TABLES_KV_2_1_PERFORMANCE", nameFlags);
MakeRptCmt(0x0001A544, "Performance 1st to 2nd gear upshift shift line.\nMPH");
MakeNameEx(0x0001A566, "T_SHIFT_TABLES_KV_3_2_PERFORMANCE", nameFlags);
MakeRptCmt(0x0001A566, "Performance 2nd to 3rd gear upshift shift line.\nMPH");
MakeNameEx(0x0001A588, "T_SHIFT_TABLES_KV_4_3_PERFORMANCE", nameFlags);
MakeRptCmt(0x0001A588, "Performance 3rd to 4th gear upshift shift line.\nMPH");
MakeNameEx(0x0001A5AA, "T_SHIFT_TABLES_KE_1_2_DETENT", nameFlags);
MakeRptCmt(0x0001A5AA, "Detent 1st to 2nd gear upshift shift point.\nMPH");
MakeNameEx(0x0001A5AC, "T_SHIFT_TABLES_KE_2_3_DETENT", nameFlags);
MakeRptCmt(0x0001A5AC, "Detent 2nd to 3rd gear upshift shift point.\nMPH");
MakeNameEx(0x0001A5AE, "T_SHIFT_TABLES_KE_3_4_DETENT", nameFlags);
MakeRptCmt(0x0001A5AE, "Detent 3rd to 4th gear upshift shift point.\nMPH");
MakeNameEx(0x0001A5B0, "T_SHIFT_TABLES_KE_2_1_DETENT", nameFlags);
MakeRptCmt(0x0001A5B0, "Detent 1st to 2nd gear upshift shift point.\nMPH");
MakeNameEx(0x0001A5B2, "T_SHIFT_TABLES_KE_3_2_DETENT", nameFlags);
MakeRptCmt(0x0001A5B2, "Detent 2nd to 3rd gear upshift shift point.\nMPH");
MakeNameEx(0x0001A5B4, "T_SHIFT_TABLES_KE_4_3_DETENT", nameFlags);
MakeRptCmt(0x0001A5B4, "Detent 3rd to 4th gear upshift shift point.\nMPH");
MakeNameEx(0x0001A5B6, "T_SHIFT_TABLES_KE_1_2_HOT_DETENT", nameFlags);
MakeRptCmt(0x0001A5B6, "Hot detent 1st to 2nd gear upshift shift point.\nMPH");
MakeNameEx(0x0001A5B8, "T_SHIFT_TABLES_KE_2_3_HOT_DETENT", nameFlags);
MakeRptCmt(0x0001A5B8, "Hot detent 2nd to 3rd gear upshift shift point.\nMPH");
MakeNameEx(0x0001A5BA, "T_SHIFT_TABLES_KE_3_4_HOT_DETENT", nameFlags);
MakeRptCmt(0x0001A5BA, "Hot detent 3rd to 4th gear upshift shift point.\nMPH");
MakeNameEx(0x0001A5BC, "T_SHIFT_TABLES_KE_2_1_HOT_DETENT", nameFlags);
MakeRptCmt(0x0001A5BC, "Hot detent 1st to 2nd gear upshift shift point.\nMPH");
MakeNameEx(0x0001A5BE, "T_SHIFT_TABLES_KE_3_2_HOT_DETENT", nameFlags);
MakeRptCmt(0x0001A5BE, "Hot detent 2nd to 3rd gear upshift shift point.\nMPH");
MakeNameEx(0x0001A5C0, "T_SHIFT_TABLES_KE_4_3_HOT_DETENT", nameFlags);
MakeRptCmt(0x0001A5C0, "Hot detent 3rd to 4th gear upshift shift point.\nMPH");
MakeNameEx(0x0001A5C2, "T_SHIFT_TABLES_KE_1_2_PERFORMANCE_DETENT", nameFlags);
MakeRptCmt(0x0001A5C2, "Performance detent 1st to 2nd gear upshift shift point.\nMPH");
MakeNameEx(0x0001A5C4, "T_SHIFT_TABLES_KE_2_3_PERFORMANCE_DETENT", nameFlags);
MakeRptCmt(0x0001A5C4, "Performance detent 2nd to 3rd gear upshift shift point.\nMPH");
MakeNameEx(0x0001A5C6, "T_SHIFT_TABLES_KE_3_4_PERFORMANCE_DETENT", nameFlags);
MakeRptCmt(0x0001A5C6, "Performance detent 3rd to 4th gear upshift shift point.\nMPH");
MakeNameEx(0x0001A5C8, "T_SHIFT_TABLES_KE_2_1_PERFORMANCE_DETENT", nameFlags);
MakeRptCmt(0x0001A5C8, "Performance detent 1st to 2nd gear upshift shift point.\nMPH");
MakeNameEx(0x0001A5CA, "T_SHIFT_TABLES_KE_3_2_PERFORMANCE_DETENT", nameFlags);
MakeRptCmt(0x0001A5CA, "Performance detent 2nd to 3rd gear upshift shift point.\nMPH");
MakeNameEx(0x0001A5CC, "T_SHIFT_TABLES_KE_4_3_PERFORMANCE_DETENT", nameFlags);
MakeRptCmt(0x0001A5CC, "Performance detent 3rd to 4th gear upshift shift point.\nMPH");
MakeNameEx(0x0001A5CE, "T_SHIFT_TABLES_KV_1_2_NORMAL_ALTITUDE_OFFSET", nameFlags);
MakeRptCmt(0x0001A5CE, "Altitude compensation speed offset for 1st to 2nd normal upshift.\nMPH");
MakeNameEx(0x0001A5E0, "T_SHIFT_TABLES_KV_2_3_HOT_ALTITUDE_OFFSET", nameFlags);
MakeRptCmt(0x0001A5E0, "Altitude compensation speed offset for 2nd to 3rd upshift.\nMPH");
MakeNameEx(0x0001A5F2, "T_SHIFT_TABLES_KV_3_4_HOT_ALTITUDE_OFFSET", nameFlags);
MakeRptCmt(0x0001A5F2, "Altitude compensation speed offset for 3rd to 4th upshift.\nMPH");
MakeNameEx(0x0001A604, "T_SHIFT_TABLES_KV_3_2_HOT_ALTITUDE_OFFSET", nameFlags);
MakeRptCmt(0x0001A604, "Altitude compensation speed offset for 3rd to 2nd downshift.\nMPH");
MakeNameEx(0x0001A616, "T_SHIFT_TABLES_KV_4_3_HOT_ALTITUDE_OFFSET", nameFlags);
MakeRptCmt(0x0001A616, "Altitude compensation speed offset for 4th to 3rd downshift.\nMPH");
MakeNameEx(0x0001A628, "T_SHIFT_TABLES_KE_1_2_DETENT_ALTITUDE_OFFSET", nameFlags);
MakeRptCmt(0x0001A628, "Altitude compensation speed offset for 1st to 2nd detent upshift.\nMPH");
MakeNameEx(0x0001A62A, "T_SHIFT_TABLES_KE_2_3_DETENT_ALTITUDE_OFFSET", nameFlags);
MakeRptCmt(0x0001A62A, "Altitude compensation speed offset for 2nd to 3rd detent upshift.\nMPH");
MakeNameEx(0x0001A62C, "T_SHIFT_TABLES_KE_3_4_DETENT_ALTITUDE_OFFSET", nameFlags);
MakeRptCmt(0x0001A62C, "Altitude compensation speed offset for 3rd to 4th detent upshift.\nMPH");
MakeNameEx(0x0001A62E, "T_SHIFT_TABLES_KE_2_1_DETENT_ALTITUDE_OFFSET", nameFlags);
MakeRptCmt(0x0001A62E, "Altitude compensation speed offset for 2nd to 1st detent downshift.\nMPH");
MakeNameEx(0x0001A630, "T_SHIFT_TABLES_KE_3_2_DETENT_ALTITUDE_OFFSET", nameFlags);
MakeRptCmt(0x0001A630, "Altitude compensation speed offset for 3rd to 2nd detent downshift.\nMPH");
MakeNameEx(0x0001A632, "T_SHIFT_TABLES_KE_4_3_DETENT_ALTITUDE_OFFSET", nameFlags);
MakeRptCmt(0x0001A632, "Altitude compensation speed offset for 4th to 3rd detent downshift.\nMPH");
MakeNameEx(0x0001A634, "T_SHIFT_TABLES_KE_1_2_DETENT_RPM_LINE", nameFlags);
MakeRptCmt(0x0001A634, "Engine speed threshold for a 1-2 detent upshift\nRPM");
MakeNameEx(0x0001A636, "T_SHIFT_TABLES_KE_2_3_DETENT_RPM_LINE", nameFlags);
MakeRptCmt(0x0001A636, "Engine speed threshold for a 2-3 detent upshift\nRPM");
MakeNameEx(0x0001A638, "T_SHIFT_TABLES_KE_3_4_DETENT_RPM_LINE", nameFlags);
MakeRptCmt(0x0001A638, "Engine speed threshold for a 3-4 detent upshift\nRPM");
MakeNameEx(0x0001A63A, "T_SHIFT_TABLES_KE_1_2_HOT_DETENT_RPM_LINE", nameFlags);
MakeRptCmt(0x0001A63A, "Engine speed threshold for a 1-2 hot detent upshift\nRPM");
MakeNameEx(0x0001A63C, "T_SHIFT_TABLES_KE_2_3_HOT_DETENT_RPM_LINE", nameFlags);
MakeRptCmt(0x0001A63C, "Engine speed threshold for a 2-3 hot detent upshift\nRPM");
MakeNameEx(0x0001A63E, "T_SHIFT_TABLES_KE_3_4_HOT_DETENT_RPM_LINE", nameFlags);
MakeRptCmt(0x0001A63E, "Engine speed threshold for a 3-4 hot detent upshift\nRPM");
MakeNameEx(0x0001A640, "T_SHIFT_TABLES_KE_1_2_RPM_HP_EP_DELTA_LINE", nameFlags);
MakeRptCmt(0x0001A640, "Engine speed cold temperature 1-2 detent upshift modifier\nRPM");
MakeNameEx(0x0001A642, "T_SHIFT_TABLES_KE_2_3_RPM_HP_EP_DELTA_LINE", nameFlags);
MakeRptCmt(0x0001A642, "Engine speed cold temperature 2-3 detent upshift modifier\nRPM");
MakeNameEx(0x0001A644, "T_SHIFT_TABLES_KE_3_4_RPM_HP_EP_DELTA_LINE", nameFlags);
MakeRptCmt(0x0001A644, "Engine speed cold temperature 3-4 detent upshift modifier\nRPM");
MakeNameEx(0x0001A646, "T_SHIFT_TABLES_KE_1_2_PERF_DETENT_RPM", nameFlags);
MakeRptCmt(0x0001A646, "Engine speed threshold for a 1-2 perf. detent upshift.\nRPM");
MakeNameEx(0x0001A648, "T_SHIFT_TABLES_KE_2_3_PERF_DETENT_RPM", nameFlags);
MakeRptCmt(0x0001A648, "Engine speed threshold for a 2-3 perf. detent upshift.\nRPM");
MakeNameEx(0x0001A64A, "T_SHIFT_TABLES_KE_3_4_PERF_DETENT_RPM", nameFlags);
MakeRptCmt(0x0001A64A, "Engine speed threshold for a 3-4 perf. detent upshift.\nRPM");
MakeNameEx(0x0001A64C, "T_SHIFT_TABLES_KE_1_2_ALTITUDE_ENG_SPD_OFFSET", nameFlags);
MakeRptCmt(0x0001A64C, "Altitude compensation engine speed offset for a 1st to 2nd upshift.\nRPM");
MakeNameEx(0x0001A64E, "T_SHIFT_TABLES_KE_2_3_ALTITUDE_ENG_SPD_OFFSET", nameFlags);
MakeRptCmt(0x0001A64E, "Altitude compensation engine speed offset for a 2nd to 3rd upshift.\nRPM");
MakeNameEx(0x0001A650, "T_SHIFT_TABLES_KE_3_4_ALTITUDE_ENG_SPD_OFFSET", nameFlags);
MakeRptCmt(0x0001A650, "Altitude compensation engine speed offset for a 3rd to 4th upshift.\nRPM");
MakeNameEx(0x0001A652, "T_SHIFT_TABLES_KV_DNSHFT_COLD_ENG_STRT_LIMIT", nameFlags);
MakeNameEx(0x0001A658, "T_SHIFT_TABLES_KV_DNSHFT_COOLANT_DUMP_LIMIT", nameFlags);
MakeNameEx(0x0001A65E, "T_SHIFT_TABLES_KV_UPSHFT_COLD_ENG_STRT_LIMIT", nameFlags);
MakeNameEx(0x0001A664, "T_SHIFT_TABLES_KV_UPSHFT_COOLANT_DUMP_LIMIT", nameFlags);
MakeNameEx(0x0001A66A, "T_SHIFT_TABLES_KV_12_NORM_MAX_THR_ALLOWED", nameFlags);
MakeRptCmt(0x0001A66A, "Used tp determine maximum amount of throttle before a 2-1 downshift is commanded.\n%");
MakeNameEx(0x0001A68C, "T_SHIFT_TABLES_KV_23_NORM_MAX_THR_ALLOWED", nameFlags);
MakeRptCmt(0x0001A68C, "Used tp determine maximum amount of throttle before a 3-2 downshift is commanded.\n%");
MakeNameEx(0x0001A6AE, "T_SHIFT_TABLES_KV_34_NORM_MAX_THR_ALLOWED", nameFlags);
MakeRptCmt(0x0001A6AE, "Used tp determine maximum amount of throttle before a 4-3 downshift is commanded.\n%");
MakeNameEx(0x0001A6D0, "T_SHIFT_TABLES_KV_12_CRS_MAX_THR_ALLOWED", nameFlags);
MakeRptCmt(0x0001A6D0, "Used tp determine maximum amount of throttle before a 2-1 downshift is commanded.\n%");
MakeNameEx(0x0001A6F2, "T_SHIFT_TABLES_KV_23_CRS_MAX_THR_ALLOWED", nameFlags);
MakeRptCmt(0x0001A6F2, "Used tp determine maximum amount of throttle before a 3-2 downshift is commanded.\n%");
MakeNameEx(0x0001A714, "T_SHIFT_TABLES_KV_34_CRS_MAX_THR_ALLOWED", nameFlags);
MakeRptCmt(0x0001A714, "Used tp determine maximum amount of throttle before a 4-3 downshift is commanded.\n%");
MakeNameEx(0x0001A736, "T_SHIFT_TABLES_KV_12_PERF_MAX_THR_ALLOWED", nameFlags);
MakeRptCmt(0x0001A736, "Used tp determine maximum amount of throttle before a 2-1 downshift is commanded.\n%");
MakeNameEx(0x0001A758, "T_SHIFT_TABLES_KV_23_PERF_MAX_THR_ALLOWED", nameFlags);
MakeRptCmt(0x0001A758, "Used tp determine maximum amount of throttle before a 3-2 downshift is commanded.\n%");
MakeNameEx(0x0001A77A, "T_SHIFT_TABLES_KV_34_PERF_MAX_THR_ALLOWED", nameFlags);
MakeRptCmt(0x0001A77A, "Used tp determine maximum amount of throttle before a 4-3 downshift is commanded.\n%");
MakeNameEx(0x0001A79C, "T_SHIFT_TABLES_KV_1_2_DRIVE_LOW_URBAN_LINE", nameFlags);
MakeRptCmt(0x0001A79C, "Drive-Low urban 1st to 2nd gear upshift shift line table\nMPH");
MakeNameEx(0x0001A7BE, "T_SHIFT_TABLES_KV_2_3_DRIVE_LOW_URBAN_LINE", nameFlags);
MakeRptCmt(0x0001A7BE, "Drive-Low urban 2nd to 3rd gear upshift shift line table\nMPH");
MakeNameEx(0x0001A7E0, "T_SHIFT_TABLES_KV_2_1_DRIVE_LOW_URBAN_LINE", nameFlags);
MakeRptCmt(0x0001A7E0, "Drive-Low urban 2nd to 1st gear downshift shift line table\nMPH");
MakeNameEx(0x0001A802, "T_SHIFT_TABLES_KV_3_2_DRIVE_LOW_URBAN_LINE", nameFlags);
MakeRptCmt(0x0001A802, "Drive-Low urban 3rd to 2nd gear downshift shift line table\nMPH");
MakeNameEx(0x0001A824, "T_SHIFT_TABLES_KV_2_3_NORMAL_ALTITUDE_OFFSET", nameFlags);
MakeRptCmt(0x0001A824, "Altitude compensation speed offset for 2nd to 3rd normal upshift.\nMPH");
MakeNameEx(0x0001A836, "T_SHIFT_TABLES_KV_3_4_NORMAL_ALTITUDE_OFFSET", nameFlags);
MakeRptCmt(0x0001A836, "Altitude compensation speed offset for 3rd to 4th normal upshift.\nMPH");
MakeNameEx(0x0001A848, "T_SHIFT_TABLES_KV_3_2_NORMAL_ALTITUDE_OFFSET", nameFlags);
MakeRptCmt(0x0001A848, "Altitude compensation speed offset for 3rd to 2nd normal downshift.\nMPH");
MakeNameEx(0x0001A85A, "T_SHIFT_TABLES_KV_4_3_NORMAL_ALTITUDE_OFFSET", nameFlags);
MakeRptCmt(0x0001A85A, "Altitude compensation speed offset for 4th to 3rd normal downshift.\nMPH");
MakeNameEx(0x0001A86C, "T_SHIFT_TABLES_KV_1_2_HOT_ALTITUDE_OFFSET", nameFlags);
MakeRptCmt(0x0001A86C, "Altitude compensation speed offset for 1st to 2nd hot normal upshift.\nMPH");
MakeNameEx(0x0001A87E, "T_SHIFT_TABLES_KV_1_2_PERF_ALTITUDE_OFFSET", nameFlags);
MakeRptCmt(0x0001A87E, "Altitude compensation speed offset for 1st to 2nd performance upshift.\nMPH");
MakeNameEx(0x0001A890, "T_SHIFT_TABLES_KV_2_3_PERF_ALTITUDE_OFFSET", nameFlags);
MakeRptCmt(0x0001A890, "Altitude compensation speed offset for 2nd to 3rd performance upshift.\nMPH");
MakeNameEx(0x0001A8A2, "T_SHIFT_TABLES_KV_3_4_PERF_ALTITUDE_OFFSET", nameFlags);
MakeRptCmt(0x0001A8A2, "Altitude compensation speed offset for 3rd to 4th performance upshift.\nMPH");
MakeNameEx(0x0001A8B4, "T_SHIFT_TABLES_KV_3_2_PERF_ALTITUDE_OFFSET", nameFlags);
MakeRptCmt(0x0001A8B4, "Altitude compensation speed offset for 3rd to 2nd performance downshift.\nMPH");
MakeNameEx(0x0001A8C6, "T_SHIFT_TABLES_KV_4_3_PERF_ALTITUDE_OFFSET", nameFlags);
MakeRptCmt(0x0001A8C6, "Altitude compensation speed offset for 4th to 3rd performance downshift.\nMPH");
MakeNameEx(0x0001A8D8, "T_SHIFT_TABLES_KV_1_2_CRUISE_ALTITUDE_OFFSET", nameFlags);
MakeRptCmt(0x0001A8D8, "Altitude compensation speed offset for 1st to 2nd cruise upshift.\nMPH");
MakeNameEx(0x0001A8EA, "T_SHIFT_TABLES_KV_2_3_CRUISE_ALTITUDE_OFFSET", nameFlags);
MakeRptCmt(0x0001A8EA, "Altitude compensation speed offset for 2nd to 3rd cruise upshift.\nMPH");
MakeNameEx(0x0001A8FC, "T_SHIFT_TABLES_KV_3_4_CRUISE_ALTITUDE_OFFSET", nameFlags);
MakeRptCmt(0x0001A8FC, "Altitude compensation speed offset for 3rd to 4th cruise upshift.\nMPH");
MakeNameEx(0x0001A90E, "T_SHIFT_TABLES_KV_3_2_CRUISE_ALTITUDE_OFFSET", nameFlags);
MakeRptCmt(0x0001A90E, "Altitude compensation speed offset for 3rd to 2nd cruise downshift.\nMPH");
MakeNameEx(0x0001A920, "T_SHIFT_TABLES_KV_4_3_CRUISE_ALTITUDE_OFFSET", nameFlags);
MakeRptCmt(0x0001A920, "Altitude compensation speed offset for 4th to 3rd cruise downshift.\nMPH");
MakeNameEx(0x0001A932, "T_SHIFT_TABLES_KE_2_1_4WD_LOW_DETENT", nameFlags);
MakeRptCmt(0x0001A932, "Vehicle speed where shifts occur. Max value disables upshifsmin value disable downshifts.\nMPH");
MakeNameEx(0x0001A934, "T_SHIFT_TABLES_KE_3_2_4WD_LOW_DETENT", nameFlags);
MakeRptCmt(0x0001A934, "Vehicle speed where shifts occur. Max value disables upshifsmin value disable downshifts.\nMPH");
MakeNameEx(0x0001A936, "T_SHIFT_TABLES_KE_4_3_4WD_LOW_DETENT", nameFlags);
MakeRptCmt(0x0001A936, "Vehicle speed where shifts occur. Max value disables upshifsmin value disable downshifts.\nMPH");
MakeNameEx(0x0001A938, "T_SHIFT_TABLES_KE_1_2_4WD_LOW_DETENT", nameFlags);
MakeRptCmt(0x0001A938, "Describe the desired engine speed points for detentupshifts when 4WD low engaged is true.\nMPH");
MakeNameEx(0x0001A93A, "T_SHIFT_TABLES_KE_2_3_4WD_LOW_DETENT", nameFlags);
MakeRptCmt(0x0001A93A, "Describe the desired engine speed points for detentupshifts when 4WD low engaged is true.\nMPH");
MakeNameEx(0x0001A93C, "T_SHIFT_TABLES_KE_3_4_4WD_LOW_DETENT", nameFlags);
MakeRptCmt(0x0001A93C, "Describe the desired engine speed points for detentupshifts when 4WD low engaged is true.\nMPH");
MakeNameEx(0x0001A93E, "T_SHIFT_TABLES_KE_1_2_4WD_LOW_DETENT_RPM", nameFlags);
MakeRptCmt(0x0001A93E, "Describe the engine speed where shifts occur. Max value disables upshifs, min value disable downshifts.\nRPM");
MakeNameEx(0x0001A940, "T_SHIFT_TABLES_KE_2_3_4WD_LOW_DETENT_RPM", nameFlags);
MakeRptCmt(0x0001A940, "Describe the engine speed where shifts occur. Max value disables upshifs, min value disable downshifts.\nRPM");
MakeNameEx(0x0001A942, "T_SHIFT_TABLES_KE_3_4_4WD_LOW_DETENT_RPM", nameFlags);
MakeRptCmt(0x0001A942, "Describe the engine speed where shifts occur. Max value disables upshifs, min value disable downshifts.\nRPM");
MakeNameEx(0x0001A944, "T_TCC_TABLES_KV_APPLY_2_NORMAL_LINE", nameFlags);
MakeRptCmt(0x0001A944, "Normal 2nd gear TCC Apply line table\nMPH");
MakeNameEx(0x0001A966, "T_TCC_TABLES_KV_APPLY_3_NORMAL_LINE", nameFlags);
MakeRptCmt(0x0001A966, "Normal 3rd gear TCC Apply line table\nMPH");
MakeNameEx(0x0001A988, "T_TCC_TABLES_KV_APPLY_4_NORMAL_LINE", nameFlags);
MakeRptCmt(0x0001A988, "Normal 4th gear TCC Apply line table\nMPH");
MakeNameEx(0x0001A9AA, "T_TCC_TABLES_KV_RELEASE_2_NORMAL_LINE", nameFlags);
MakeRptCmt(0x0001A9AA, "Normal 2rd gear TCC Release line table\nMPH");
MakeNameEx(0x0001A9CC, "T_TCC_TABLES_KV_RELEASE_3_NORMAL_LINE", nameFlags);
MakeRptCmt(0x0001A9CC, "Normal 3rd gear TCC Release line table\nMPH");
MakeNameEx(0x0001A9EE, "T_TCC_TABLES_KV_RELEASE_4_NORMAL_LINE", nameFlags);
MakeRptCmt(0x0001A9EE, "Normal 4th gear TCC Release line table\nMPH");
MakeNameEx(0x0001AA10, "T_TCC_TABLES_KV_APPLY_2_CRUISE_LINE", nameFlags);
MakeRptCmt(0x0001AA10, "Cruise 2nd gear TCC Apply line table\nMPH");
MakeNameEx(0x0001AA32, "T_TCC_TABLES_KV_APPLY_3_CRUISE_LINE", nameFlags);
MakeRptCmt(0x0001AA32, "Cruise 3rd gear TCC Apply line table\nMPH");
MakeNameEx(0x0001AA54, "T_TCC_TABLES_KV_APPLY_4_CRUISE_LINE", nameFlags);
MakeRptCmt(0x0001AA54, "Cruise 4th gear TCC Apply line table\nMPH");
MakeNameEx(0x0001AA76, "T_TCC_TABLES_KV_RELEASE_2_CRUISE_LINE", nameFlags);
MakeRptCmt(0x0001AA76, "Cruise 2nd gear TCC Release line table\nMPH");
MakeNameEx(0x0001AA98, "T_TCC_TABLES_KV_RELEASE_3_CRUISE_LINE", nameFlags);
MakeRptCmt(0x0001AA98, "Cruise 3rd gear TCC Release line table\nMPH");
MakeNameEx(0x0001AABA, "T_TCC_TABLES_KV_RELEASE_4_CRUISE_LINE", nameFlags);
MakeRptCmt(0x0001AABA, "Cruise 4th gear TCC Release line table\nMPH");
MakeNameEx(0x0001AADC, "T_TCC_TABLES_KV_APPLY_2_HOT", nameFlags);
MakeRptCmt(0x0001AADC, "Hot 2nd gear TCC Apply line table\nMPH");
MakeNameEx(0x0001AAFE, "T_TCC_TABLES_KV_APPLY_3_HOT", nameFlags);
MakeRptCmt(0x0001AAFE, "Hot 3rd gear TCC Apply line table\nMPH");
MakeNameEx(0x0001AB20, "T_TCC_TABLES_KV_APPLY_4_HOT", nameFlags);
MakeRptCmt(0x0001AB20, "Hot 4th gear TCC Apply line table\nMPH");
MakeNameEx(0x0001AB42, "T_TCC_TABLES_KV_RELEASE_2_HOT", nameFlags);
MakeRptCmt(0x0001AB42, "Hot 2nd gear TCC Release line table\nMPH");
MakeNameEx(0x0001AB64, "T_TCC_TABLES_KV_RELEASE_3_HOT", nameFlags);
MakeRptCmt(0x0001AB64, "Hot 3rd gear TCC Release line table\nMPH");
MakeNameEx(0x0001AB86, "T_TCC_TABLES_KV_RELEASE_4_HOT", nameFlags);
MakeRptCmt(0x0001AB86, "Hot 4th gear TCC Release line table\nMPH");
MakeNameEx(0x0001ABA8, "T_TCC_TABLES_KV_APPLY_2_PERFORMANCE", nameFlags);
MakeRptCmt(0x0001ABA8, "Performance 2nd gear TCC Apply line table\nMPH");
MakeNameEx(0x0001ABCA, "T_TCC_TABLES_KV_APPLY_3_PERFORMANCE", nameFlags);
MakeRptCmt(0x0001ABCA, "Performance 3rd gear TCC Apply line table\nMPH");
MakeNameEx(0x0001ABEC, "T_TCC_TABLES_KV_APPLY_4_PERFORMANCE", nameFlags);
MakeRptCmt(0x0001ABEC, "Performance 4th gear TCC Apply line table\nMPH");
MakeNameEx(0x0001AC0E, "T_TCC_TABLES_KV_RELEASE_2_PERFORMANCE", nameFlags);
MakeRptCmt(0x0001AC0E, "Performance 2nd gear TCC Release line table\nMPH");
MakeNameEx(0x0001AC30, "T_TCC_TABLES_KV_RELEASE_3_PERFORMANCE", nameFlags);
MakeRptCmt(0x0001AC30, "Performance 3rd gear TCC Release line table\nMPH");
MakeNameEx(0x0001AC52, "T_TCC_TABLES_KV_RELEASE_4_PERFORMANCE", nameFlags);
MakeRptCmt(0x0001AC52, "Performance 4th gear TCC Release line table\nMPH");
MakeNameEx(0x0001AC74, "T_TCC_TABLES_KV_APPLY_2_NORM_ALT_OFFSET", nameFlags);
MakeNameEx(0x0001AC86, "T_TCC_TABLES_KV_APPLY_3_NORM_ALT_OFFSET", nameFlags);
MakeNameEx(0x0001AC98, "T_TCC_TABLES_KV_APPLY_4_NORM_ALT_OFFSET", nameFlags);
MakeNameEx(0x0001ACAA, "T_TCC_TABLES_KV_APPLY_2_CRUISE_ALT_OFFSET", nameFlags);
MakeRptCmt(0x0001ACAA, "Altitude compensation offset for TCC Apply Cruise.\nMPH");
MakeNameEx(0x0001ACBC, "T_TCC_TABLES_KV_APPLY_3_CRUISE_ALT_OFFSET", nameFlags);
MakeRptCmt(0x0001ACBC, "Altitude compensation offset for TCC Apply Cruise.\nMPH");
MakeNameEx(0x0001ACCE, "T_TCC_TABLES_KV_APPLY_4_CRUISE_ALT_OFFSET", nameFlags);
MakeRptCmt(0x0001ACCE, "Altitude compensation offset for TCC Apply Cruise.\nMPH");
MakeNameEx(0x0001ACE0, "T_TCC_TABLES_KV_APPLY_2_HOT_ALT_OFFSET", nameFlags);
MakeRptCmt(0x0001ACE0, "Altitude compensation offset for TCC Apply Hot.\nMPH");
MakeNameEx(0x0001ACF2, "T_TCC_TABLES_KV_APPLY_3_HOT_ALT_OFFSET", nameFlags);
MakeRptCmt(0x0001ACF2, "Altitude compensation offset for TCC Apply Hot.\nMPH");
MakeNameEx(0x0001AD04, "T_TCC_TABLES_KV_APPLY_4_HOT_ALT_OFFSET", nameFlags);
MakeRptCmt(0x0001AD04, "Altitude compensation offset for TCC Apply Hot.\nMPH");
MakeNameEx(0x0001AD16, "T_TCC_TABLES_KV_APPLY_2_PERF_ALT_OFFSET", nameFlags);
MakeRptCmt(0x0001AD16, "Altitude compensation offset for TCC Apply Performance.\nMPH");
MakeNameEx(0x0001AD28, "T_TCC_TABLES_KV_APPLY_3_PERF_ALT_OFFSET", nameFlags);
MakeRptCmt(0x0001AD28, "Altitude compensation offset for TCC Apply Performance.\nMPH");
MakeNameEx(0x0001AD3A, "T_TCC_TABLES_KV_APPLY_4_PERF_ALT_OFFSET", nameFlags);
MakeRptCmt(0x0001AD3A, "Altitude compensation offset for TCC Apply Performance.\nMPH");
MakeNameEx(0x0001AD4C, "T_TCC_TABLES_KV_RELEASE_2_NORMAL_ALT_OFFSET", nameFlags);
MakeNameEx(0x0001AD5E, "T_TCC_TABLES_KV_RELEASE_3_NORMAL_ALT_OFFSET", nameFlags);
MakeNameEx(0x0001AD70, "T_TCC_TABLES_KV_RELEASE_4_NORMAL_ALT_OFFSET", nameFlags);
MakeNameEx(0x0001AD82, "T_TCC_TABLES_KV_RELEASE_2_CRUISE_ALT_OFFSET", nameFlags);
MakeRptCmt(0x0001AD82, "Altitude compensation offset for TCC Release Cruise.\nMPH");
MakeNameEx(0x0001AD94, "T_TCC_TABLES_KV_RELEASE_3_CRUISE_ALT_OFFSET", nameFlags);
MakeRptCmt(0x0001AD94, "Altitude compensation offset for TCC Release Cruise.\nMPH");
MakeNameEx(0x0001ADA6, "T_TCC_TABLES_KV_RELEASE_4_CRUISE_ALT_OFFSET", nameFlags);
MakeRptCmt(0x0001ADA6, "Altitude compensation offset for TCC Release Cruise.\nMPH");
MakeNameEx(0x0001ADB8, "T_TCC_TABLES_KV_RELEASE_2_HOT_ALT_OFFSET", nameFlags);
MakeRptCmt(0x0001ADB8, "Altitude compensation offset for TCC Release Cruise.\nMPH");
MakeNameEx(0x0001ADCA, "T_TCC_TABLES_KV_RELEASE_3_HOT_ALT_OFFSET", nameFlags);
MakeRptCmt(0x0001ADCA, "Altitude compensation offset for TCC Release Hot.\nMPH");
MakeNameEx(0x0001ADDC, "T_TCC_TABLES_KV_RELEASE_4_HOT_ALT_OFFSET", nameFlags);
MakeRptCmt(0x0001ADDC, "Altitude compensation offset for TCC Release Hot.\nMPH");
MakeNameEx(0x0001ADEE, "T_TCC_TABLES_KV_RELEASE_2_PERF_ALT_OFFSET", nameFlags);
MakeRptCmt(0x0001ADEE, "Altitude compensation offset for TCC Release Performance.\nMPH");
MakeNameEx(0x0001AE00, "T_TCC_TABLES_KV_RELEASE_3_PERF_ALT_OFFSET", nameFlags);
MakeRptCmt(0x0001AE00, "Altitude compensation offset for TCC Release Performance.\nMPH");
MakeNameEx(0x0001AE12, "T_TCC_TABLES_KV_RELEASE_4_PERF_ALT_OFFSET", nameFlags);
MakeRptCmt(0x0001AE12, "Altitude compensation offset for TCC Release Performance.\nMPH");
MakeNameEx(0x0001AE24, "T_TCC_TABLES_KV_TCC_APPLY_2_HP_EP_OFFSET", nameFlags);
MakeRptCmt(0x0001AE24, "Max amount TCC apply point could be modified when in heater performance or engine protection mode.\nMPH");
MakeNameEx(0x0001AE46, "T_TCC_TABLES_KV_TCC_APPLY_3_HP_EP_OFFSET", nameFlags);
MakeRptCmt(0x0001AE46, "Max amount TCC apply point could be modified when in heater performance or engine protection mode.\nMPH");
MakeNameEx(0x0001AE68, "T_TCC_TABLES_KV_TCC_APPLY_4_HP_EP_OFFSET", nameFlags);
MakeRptCmt(0x0001AE68, "Max amount TCC apply point could be modified when inheater performance or engine protection mode.\nMPH");
MakeNameEx(0x0001AE8A, "T_TCC_TABLES_KV_TCC_RELEASE_2_HP_EP_OFFSET", nameFlags);
MakeRptCmt(0x0001AE8A, "Max amount TCC Release point could be modified when in heater performance or engine protection mode.\nMPH");
MakeNameEx(0x0001AEAC, "T_TCC_TABLES_KV_TCC_RELEASE_3_HP_EP_OFFSET", nameFlags);
MakeRptCmt(0x0001AEAC, "Max amount TCC Release point could be modified when in heater performance or engine protection mode.\nMPH");
MakeNameEx(0x0001AECE, "T_TCC_TABLES_KV_TCC_RELEASE_4_HP_EP_OFFSET", nameFlags);
MakeRptCmt(0x0001AECE, "Max amount TCC Release point could be modified when inheater performance or engine protection mode.\nMPH");
MakeNameEx(0x0001AEF0, "T_TCC_TABLES_KV_2_NORM_MAX_THR_BEFORE_REL", nameFlags);
MakeRptCmt(0x0001AEF0, "Used to determine maximum amount of throttle before a TCC release is commanded in second gear.\n%");
MakeNameEx(0x0001AF12, "T_TCC_TABLES_KV_3_NORM_MAX_THR_BEFORE_REL", nameFlags);
MakeRptCmt(0x0001AF12, "Used to determine maximum amount of throttle before a TCC release is commanded in third gear.\n%");
MakeNameEx(0x0001AF34, "T_TCC_TABLES_KV_4_NORM_MAX_THR_BEFORE_REL", nameFlags);
MakeRptCmt(0x0001AF34, "Used to determine maximum amount of throttle before a TCC release is commanded in fourth gear.\n%");
MakeNameEx(0x0001AF56, "T_TCC_TABLES_KV_2_CRS_MAX_THR_BEFORE_REL", nameFlags);
MakeRptCmt(0x0001AF56, "Used to determine maximum amount of throttle before a TCC release is commanded in second gear.\n%");
MakeNameEx(0x0001AF78, "T_TCC_TABLES_KV_3_CRS_MAX_THR_BEFORE_REL", nameFlags);
MakeRptCmt(0x0001AF78, "Used to determine maximum amount of throttle before a TCC release is commanded in third gear.\n%");
MakeNameEx(0x0001AF9A, "T_TCC_TABLES_KV_4_CRS_MAX_THR_BEFORE_REL", nameFlags);
MakeRptCmt(0x0001AF9A, "Used to determine maximum amount of throttle before a TCC release is commanded in fourth gear.\n%");
MakeNameEx(0x0001AFBC, "T_TCC_TABLES_KV_2_PERF_MAX_THR_BEFORE_REL", nameFlags);
MakeRptCmt(0x0001AFBC, "Used to determine maximum amount of throttle before a TCC release is commanded in second gear.\n%");
MakeNameEx(0x0001AFDE, "T_TCC_TABLES_KV_3_PERF_MAX_THR_BEFORE_REL", nameFlags);
MakeRptCmt(0x0001AFDE, "Used to determine maximum amount of throttle before a TCC release is commanded in third gear.\n%");
MakeNameEx(0x0001B000, "T_TCC_TABLES_KV_4_PERF_MAX_THR_BEFORE_REL", nameFlags);
MakeRptCmt(0x0001B000, "Used to determine maximum amount of throttle before a TCC release is commanded in fourth gear.\n%");
MakeNameEx(0x0001B022, "T_TIMING_TABLES_KV_1_2_NORMAL_DESIRED_SHIFT_TIME", nameFlags);
MakeRptCmt(0x0001B022, "Desired shift time for a 1-2 shift in normal mode.\nSeconds");
MakeNameEx(0x0001B044, "T_TIMING_TABLES_KV_2_3_NORMAL_DESIRED_SHIFT_TIME", nameFlags);
MakeRptCmt(0x0001B044, "Desired shift time for a 2-3 shift in normal mode.\nSeconds");
MakeNameEx(0x0001B066, "T_TIMING_TABLES_KV_3_4_NORMAL_DESIRED_SHIFT_TIME", nameFlags);
MakeRptCmt(0x0001B066, "Desired shift time for a 3-4 shift in normal mode.\nSeconds");
MakeNameEx(0x0001B088, "T_TIMING_TABLES_KV_1_2_PERF_DESIRED_SHIFT_TIME", nameFlags);
MakeRptCmt(0x0001B088, "Desired shift time for a 1-2 shift in performance mode.\nSeconds");
MakeNameEx(0x0001B0AA, "T_TIMING_TABLES_KV_2_3_PERF_DESIRED_SHIFT_TIME", nameFlags);
MakeRptCmt(0x0001B0AA, "Desired shift time for a 2-3 shift in performance mode.\nSeconds");
MakeNameEx(0x0001B0CC, "T_TIMING_TABLES_KV_3_4_PERF_DESIRED_SHIFT_TIME", nameFlags);
MakeRptCmt(0x0001B0CC, "Desired shift time for a 3-4 shift in performance mode.\nSeconds");
MakeNameEx(0x0001B0EE, "T_TIMING_TABLES_KV_1_2_PRESS_LOW_ADAPT_LIMIT", nameFlags);
MakeRptCmt(0x0001B0EE, "Adaptive pressure low limit for 1-2 shift.\nPSI");
MakeNameEx(0x0001B100, "T_TIMING_TABLES_KV_2_3_PRESS_LOW_ADAPT_LIMIT", nameFlags);
MakeRptCmt(0x0001B100, "Adaptive pressure low limit for 2-3 shift.\nPSI");
MakeNameEx(0x0001B112, "T_TIMING_TABLES_KV_3_4_PRESS_LOW_ADAPT_LIMIT", nameFlags);
MakeRptCmt(0x0001B112, "Adaptive pressure low limit for 3-4 shift.\nPSI");
MakeNameEx(0x0001B124, "T_TIMING_TABLES_KV_PRESS_HIGH_ADAPT_LIMIT", nameFlags);
MakeRptCmt(0x0001B124, "Adaptive pressure high limit.\nPSI");
MakeNameEx(0x0001B136, "T_TIMING_TABLES_KV_1_2_NORMAL_DST_OFFSET", nameFlags);
MakeRptCmt(0x0001B136, "Altitude compensation factor offset for 1-2 upshift in normalmode used within shift quality's Desired Shift Time algorithm.\nSeconds");
MakeNameEx(0x0001B158, "T_TIMING_TABLES_KV_2_3_NORMAL_DST_OFFSET", nameFlags);
MakeRptCmt(0x0001B158, "Altitude compensation factor offset for 2-3 upshift in normalmode used within shift quality's Desired Shift Time algorithm.\nSeconds");
MakeNameEx(0x0001B17A, "T_TIMING_TABLES_KV_3_4_NORMAL_DST_OFFSET", nameFlags);
MakeRptCmt(0x0001B17A, "Altitude compensation factor offset for 3-4 upshift in normalmode used within shift quality's Desired Shift Time algorithm.\nSeconds");
MakeNameEx(0x0001B19C, "T_TIMING_TABLES_KV_1_2_PERF_DST_OFFSET", nameFlags);
MakeNameEx(0x0001B1BE, "T_TIMING_TABLES_KV_2_3_PERF_DST_OFFSET", nameFlags);
MakeNameEx(0x0001B1E0, "T_TIMING_TABLES_KV_3_4_PERF_DST_OFFSET", nameFlags);
MakeNameEx(0x0001B202, "T_TIMING_TABLES_KV_1_2_DST_ALTITUDE_FACTOR", nameFlags);
MakeRptCmt(0x0001B202, "Multiplicative Altitude compensation factor based on barometricpressure for 1-2 shift normal mode within Desired Shift Times.\nFactor");
MakeNameEx(0x0001B208, "T_TIMING_TABLES_KV_2_3_DST_ALTITUDE_FACTOR", nameFlags);
MakeRptCmt(0x0001B208, "Multiplicative Altitude compensation factor based on barometricpressure for 2-3 shift normal mode within Desired Shift Times.\nFactor");
MakeNameEx(0x0001B20E, "T_TIMING_TABLES_KV_3_4_DST_ALTITUDE_FACTOR", nameFlags);
MakeRptCmt(0x0001B20E, "Multiplicative Altitude compensation factor based on barometricpressure for 3-4 shift normal mode within Desired Shift Times.\nFactor");
MakeNameEx(0x0001B213, "X_TCM_EXECUTION_KE_USE_SHIFT_STABILIZATION_ACCEL", nameFlags);
MakeRptCmt(0x0001B213, "Bypass shift stabilization accel routine if this is false.\nT/F");
MakeNameEx(0x0001B214, "T_FM_CONTROL_KE_FM_MIN_DUTY_CYCLE_MFD", nameFlags);
MakeRptCmt(0x0001B214, "Minimum force motor duty cycle required for MFD chip to accurately measure the actual force motor         current.\nPercent");
MakeNameEx(0x0001B216, "XMSN_IO_KE_MAX_PRESSURE", nameFlags);
MakeRptCmt(0x0001B216, "Max allowable force motor pressure used for limitingcalculations.\nPSI");
MakeNameEx(0x0001B218, "XMSN_IO_KE_DRIVE_SPROKET_RATIO", nameFlags);
MakeRptCmt(0x0001B218, "Turbine shaft and Input shaft interconnect chain ratio.\nRatio");
MakeNameEx(0x0001B21A, "XMSN_IO_KV_CONVERTER_TORQUE_RATIO", nameFlags);
MakeRptCmt(0x0001B21A, "Ratio used to determine gearbox torque.\nRatio");
MakeNameEx(0x0001B23C, "XMSN_IO_KE_FIRST_GEAR_RATIO", nameFlags);
MakeRptCmt(0x0001B23C, "Gear ratio for 1st gear.\nRatio");
MakeNameEx(0x0001B23E, "XMSN_IO_KE_SECOND_GEAR_RATIO", nameFlags);
MakeRptCmt(0x0001B23E, "Gear ratio for 2nd gear.\nRatio");
MakeNameEx(0x0001B240, "XMSN_IO_KE_REVERSE_GEAR_RATIO", nameFlags);
MakeRptCmt(0x0001B240, "Gear ratio for 1st gear.\nRatio");
MakeNameEx(0x0001B242, "XMSN_IO_KE_DIAG_SYS_VOLTS_LOW", nameFlags);
MakeRptCmt(0x0001B242, "The low thresholdof Ignition voltage range\nVolts");
MakeNameEx(0x0001B243, "XMSN_IO_KE_DIAG_SYS_VOLTS_HIGH", nameFlags);
MakeRptCmt(0x0001B243, "The high thresholdof Ignition voltage range\nVolts");
MakeNameEx(0x0001B244, "XMSN_IO_KE_BRAKE_DEBOUNCE_TIME", nameFlags);
MakeRptCmt(0x0001B244, "Amount of time to debounce the brake switch input.\nSeconds");
MakeNameEx(0x0001B246, "XMSN_IO_KE_DEFAULT_THROTTLE_POSITION", nameFlags);
MakeRptCmt(0x0001B246, "Default throttle to use when throttle is faulted.\nPercent");
MakeNameEx(0x0001B248, "XMSN_IO_KE_DEFAULT_THROTTLE_LOW", nameFlags);
MakeRptCmt(0x0001B248, "Negative delta for throttle recovery.\nPercent");
MakeNameEx(0x0001B24A, "XMSN_IO_KE_DEFAULT_THROTTLE_HIGH", nameFlags);
MakeRptCmt(0x0001B24A, "Positive delta for throttle recovery.\nPercent");
MakeNameEx(0x0001B24C, "XMSN_IO_KE_USE_ENGINE_TPS", nameFlags);
MakeRptCmt(0x0001B24C, "Determines whether to set default throttle position toa calibrated value or to an undefaulted throttle position.\nT/F");
MakeNameEx(0x0001B24E, "XMSN_IO_KE_THROTTLE_KICKDOWN_LOW_THRESH", nameFlags);
MakeRptCmt(0x0001B24E, "Exit throttle kickdown when throttle is below this.\nPercent");
MakeNameEx(0x0001B250, "XMSN_IO_KE_THROTTLE_KICKDOWN_HIGH_THRESH", nameFlags);
MakeRptCmt(0x0001B250, "Enter throttle kickdown when throttle is above this.\nPercent");
MakeNameEx(0x0001B252, "XMSN_IO_KE_THROT_KICKDN_4WDLOW_LO_THRESH", nameFlags);
MakeRptCmt(0x0001B252, "Defines the throttle position threshold below which the kickdown (detent) flag will be set to FALSE.\nPercent");
MakeNameEx(0x0001B254, "XMSN_IO_KE_THROT_KICKDN_4WDLOW_HI_THRESH", nameFlags);
MakeRptCmt(0x0001B254, "Defines the throttle position threshold above which the kickdown (detent) flag will be set to TRUE.\nPercent");
MakeNameEx(0x0001B256, "XMSN_IO_KE_THROT_KICKDN_CRUISE_LO_THRESH", nameFlags);
MakeRptCmt(0x0001B256, "Defines the throttle position threshold for cruise below which the kickdown (detent) flag will be set to FALSE.\nPercent");
MakeNameEx(0x0001B258, "XMSN_IO_KE_THROT_KICKDN_CRUISE_HI_THRESH", nameFlags);
MakeRptCmt(0x0001B258, "Defines the throttle position threshold for cruise above which the kickdown (detent) flag will be set to TRUE.\nPercent");
MakeNameEx(0x0001B25A, "XMSN_IO_KE_ENGINE_SPEED_KALMAN_GAIN_1", nameFlags);
MakeRptCmt(0x0001B25A, "Gain used in kalman filter associated with plant speed noise.\nGain");
MakeNameEx(0x0001B25C, "XMSN_IO_KE_ENGINE_SPEED_KALMAN_GAIN_2", nameFlags);
MakeRptCmt(0x0001B25C, "Gain used in kalman filter associated with plant acceleration noise.\nGain");
MakeNameEx(0x0001B25E, "XMSN_IO_KE_ENGINE_SPEED_KALMAN_GAIN_3", nameFlags);
MakeRptCmt(0x0001B25E, "Gain used in kalman filter associated with plant jerk noise.\nGain");
MakeNameEx(0x0001B260, "XMSN_IO_KE_ENGINE_SPEED_FILTER_COEFF", nameFlags);
MakeRptCmt(0x0001B260, "Filter Coefficient for filtering engine speed.\nCoeff");
MakeNameEx(0x0001B262, "XMSN_IO_KE_ENG_SPD_FILTER_COEFF", nameFlags);
MakeRptCmt(0x0001B262, "Filter coefficient for filtering Engine Speed at 6.25 ms for use in Modeled Ratio calculation.\nCoeff");
MakeNameEx(0x0001B264, "XMSN_IO_KE_OUTPUT_SPEED_FILTER_COEFF", nameFlags);
MakeRptCmt(0x0001B264, "Filter Coefficient for filtering output speed.\nCoeff");
MakeNameEx(0x0001B266, "XMSN_IO_KE_MPH_OUTPUT_SPEED_FILTER_COEFF", nameFlags);
MakeRptCmt(0x0001B266, "Filter Coefficient for filtering MPH output speed.\nCoeff");
MakeNameEx(0x0001B268, "XMSN_IO_KE_SLIP_FILTER_COEFF", nameFlags);
MakeRptCmt(0x0001B268, "Filter Coefficient for filtering Slip.\nCoeff");
MakeNameEx(0x0001B26A, "XMSN_IO_KE_TURBINE_SPEED_FILTER_COEFF", nameFlags);
MakeRptCmt(0x0001B26A, "Filter Coefficient for filtering turbine speed.\nCoeff");
MakeNameEx(0x0001B26C, "XMSN_IO_KE_ENGINE_TORQUE_FILTER_COEFF", nameFlags);
MakeRptCmt(0x0001B26C, "Filter Coefficient for filtering turbine speed.\nCoeff");
MakeNameEx(0x0001B26E, "XMSN_IO_KE_ECCC_ENGINE_TORQ_FILTER_CONST", nameFlags);
MakeRptCmt(0x0001B26E, "Filter Coefficient for determining ECCC_Engine_Torque.\nCoeff");
MakeNameEx(0x0001B270, "XMSN_IO_KE_SPANNED_TIME_ECCC_ENGINE_TORQ", nameFlags);
MakeRptCmt(0x0001B270, "Update Spanned_ECCC_Engine_Torq every this many seconds.\nSeconds");
MakeNameEx(0x0001B272, "XMSN_IO_KE_SLIP_LOW_THRESHOLD", nameFlags);
MakeRptCmt(0x0001B272, "Enter floating slip mode when slip is less than this.\nRPM");
MakeNameEx(0x0001B274, "XMSN_IO_KE_SLIP_HIGH_THRESHOLD", nameFlags);
MakeRptCmt(0x0001B274, "Exit floating slip mode when slip is greater than this.\nRPM");
MakeNameEx(0x0001B276, "XMSN_IO_KE_ENGINE_RUNNING_ENG_SPD_THRESH", nameFlags);
MakeRptCmt(0x0001B276, "Speed threshold above which engine is considered running.\nRPM");
MakeNameEx(0x0001B278, "XMSN_IO_KE_PWRTRAIN_MOVING_ENG_SPD_THRSH", nameFlags);
MakeRptCmt(0x0001B278, "Speed threshold below which engine speed is considered stopped.\nRPM");
MakeNameEx(0x0001B27A, "XMSN_IO_KE_STOPPED_POWERTRAIN_TIME_LIMIT", nameFlags);
MakeRptCmt(0x0001B27A, "When all speed inputs indicate zero motion for this amount of time, indicate that the powertrain is not moving.\nSeconds");
MakeNameEx(0x0001B27C, "XMSN_IO_KE_ENGINE_RUN_NOT_CUT_OFF_TIME", nameFlags);
MakeRptCmt(0x0001B27C, "The amount of time the engine must be running not in fuel cut off.\nSeconds");
MakeNameEx(0x0001B27E, "XMSN_IO_KE_OUTPUT_ACCEL_FILTER_COEFF", nameFlags);
MakeRptCmt(0x0001B27E, "Filter Coefficient for filtering output acceleration.\nCoeff");
MakeNameEx(0x0001B280, "XMSN_IO_KE_FAST_DECEL_THRESHOLD", nameFlags);
MakeRptCmt(0x0001B280, "If output acceleration below this, TCC is turned off.\nRPM_per_Sec");
MakeNameEx(0x0001B282, "XMSN_IO_KV_LINEAR_HOT_TEMPERATURE_TABLE", nameFlags);
MakeRptCmt(0x0001B282, "Table used to translate temperature sensor A/D counts into Degrees C.  This table is for the 348 Ohm pullup resistor.\nDeg C");
MakeNameEx(0x0001B2A4, "XMSN_IO_KV_LINEAR_COLD_TEMPERATURE_TABLE", nameFlags);
MakeRptCmt(0x0001B2A4, "Table used to translate temperature sensor A/D counts into Degrees C.  This table is for the 4K Ohm pullup resistor.\nDeg C");
MakeNameEx(0x0001B2C6, "XMSN_IO_KE_TEMPERATURE_FACTOR_SOURCE", nameFlags);
MakeRptCmt(0x0001B2C6, "Indicates the temperatue source used to calculate thetemperature factor for heater performance\nNONE");
MakeNameEx(0x0001B2C8, "XMSN_IO_KE_TRANS_TEMP_FILTER_COEFFICIENT", nameFlags);
MakeRptCmt(0x0001B2C8, "Filter coefficient for filtering Transmission Temperature.\nCoeff");
MakeNameEx(0x0001B2CA, "XMSN_IO_KE_DEFAULT_TRANS_TEMPERATURE", nameFlags);
MakeRptCmt(0x0001B2CA, "Default transmission temperature when sensor fails.\nDeg C");
MakeNameEx(0x0001B2CC, "XMSN_IO_KE_LOW_MAX_GEAR_INHIBIT_THRESH", nameFlags);
MakeRptCmt(0x0001B2CC, "When Coolant temperature falls below this value, inhibit max gear.\nDeg C");
MakeNameEx(0x0001B2CD, "XMSN_IO_KE_HIGH_MAX_GEAR_INHIBIT_THRESH", nameFlags);
MakeRptCmt(0x0001B2CD, "When Coolant temperature rises above this value, Enable max gear.\nDeg C");
MakeNameEx(0x0001B2CE, "XMSN_IO_KE_COLD_ENGINE_LOW_THRESHOLD", nameFlags);
MakeRptCmt(0x0001B2CE, "When Coolant temperature falls below this value, the engine cold indicator is set.\nDeg C");
MakeNameEx(0x0001B2CF, "XMSN_IO_KE_COLD_ENGINE_HIGH_THRESHOLD", nameFlags);
MakeRptCmt(0x0001B2CF, "When Coolant temperature rises above this value, the engine cold indicator is cleared.\nDeg C");
MakeNameEx(0x0001B2D0, "XMSN_IO_KE_HOT_ENGINE_LOW_THRESHOLD", nameFlags);
MakeRptCmt(0x0001B2D0, "When Coolant temperature falls below this value, the engine hot indicator is cleared.\nDeg C");
MakeNameEx(0x0001B2D1, "XMSN_IO_KE_HOT_ENGINE_HIGH_THRESHOLD", nameFlags);
MakeRptCmt(0x0001B2D1, "When Coolant temperature rises above this value, the engine Hot indicator is Set.\nDeg C");
MakeNameEx(0x0001B2D2, "XMSN_IO_KE_INTAKE_AIR_TEMP_LOW_OFFSET", nameFlags);
MakeRptCmt(0x0001B2D2, "Offset added to coolant temperature to determine defaulttrans temp when air temp is below a threshold.\nDeg C");
MakeNameEx(0x0001B2D4, "XMSN_IO_KE_INTAKE_AIR_TEMP_HIGH_OFFSET", nameFlags);
MakeRptCmt(0x0001B2D4, "Offset added to coolant temperature to determine defaulttrans temp when air temp is above a threshold.\nDeg C");
MakeNameEx(0x0001B2D6, "XMSN_IO_KE_TRANS_TEMP_COND_UNKNOWN", nameFlags);
MakeRptCmt(0x0001B2D6, "Default transmission temperature when a reliable engine coolant temperature is not available.\nDeg C");
MakeNameEx(0x0001B2D8, "XMSN_IO_KE_TRANS_TEMP_ENG_TEMP_LOW", nameFlags);
MakeRptCmt(0x0001B2D8, "Default transmission temperature when engine run time is above a cal and coolant temperature is below a cal.\nDeg C");
MakeNameEx(0x0001B2DA, "XMSN_IO_KE_TRANS_TEMP_STARTUP", nameFlags);
MakeRptCmt(0x0001B2DA, "Default transmission temperature when engine run time is below a cal and coolant temperature is below a cal.\nDeg C");
MakeNameEx(0x0001B2DC, "XMSN_IO_KE_MIN_ENGINE_RUN_TIME", nameFlags);
MakeRptCmt(0x0001B2DC, "Engine run time threshold for deteremining which default transmission temperature to use.\nSeconds");
MakeNameEx(0x0001B2E0, "XMSN_IO_KE_ENG_PROT_MODE_HIGH_THROT_THR", nameFlags);
MakeRptCmt(0x0001B2E0, "High threshold for the throttle position to switch  Heater Performance Mode to Engine Protection Mode.\nPercent");
MakeNameEx(0x0001B2E2, "XMSN_IO_KE_ENG_PROT_MODE_LOW_THROT_THR", nameFlags);
MakeNameEx(0x0001B2E4, "XMSN_IO_KE_COLD_DAY_LOW_TEMP_FACT_THR", nameFlags);
MakeRptCmt(0x0001B2E4, "If coolant temperature of a Cold Day is below this threshold then Temperature_Factor is 1\nDegrees_C");
MakeNameEx(0x0001B2E5, "XMSN_IO_KE_COLD_DAY_HIGH_TEMP_FACT_THR", nameFlags);
MakeRptCmt(0x0001B2E5, "If coolant temperature of a Cold Day is above this threshold then Temperature_Factor is 0\nDegrees_C");
MakeNameEx(0x0001B2E6, "XMSN_IO_KE_COOL_DAY_LOW_TEMP_FACT_THR", nameFlags);
MakeRptCmt(0x0001B2E6, "If coolant temperature of a Cool Day is below this threshold then Temperature_Factor is 1\nDegrees_C");
MakeNameEx(0x0001B2E7, "XMSN_IO_KE_COOL_DAY_HIGH_TEMP_FACT_THR", nameFlags);
MakeRptCmt(0x0001B2E7, "If coolant temperature of a Cool Day is above this threshold then Temperature_Factor is 0\nDegrees_C");
MakeNameEx(0x0001B2E8, "XMSN_IO_KE_COLD_DAY_KUM_THRESH", nameFlags);
MakeRptCmt(0x0001B2E8, "If Startup_Intake_Air_Temp is below this threshold then cold day is present\nDegrees_C");
MakeNameEx(0x0001B2E9, "XMSN_IO_KE_COOL_DAY_KUM_THRESH", nameFlags);
MakeRptCmt(0x0001B2E9, "If Startup_Intake_Air_Temp is below this threshold andthen cool day is present\nDegrees_C");
MakeNameEx(0x0001B2EA, "XMSN_IO_KV_ENGINE_PROTECTION_TEMP_FACTOR", nameFlags);
MakeRptCmt(0x0001B2EA, "Temperature Factor in Engine Protection Mode\nFactor 0_1");
MakeNameEx(0x0001B2FC, "XMSN_IO_KE_THIRD_GEAR_RATIO", nameFlags);
MakeRptCmt(0x0001B2FC, "Gear ratio for 1st gear.\nRatio");
MakeNameEx(0x0001B2FE, "XMSN_IO_KE_FOURTH_GEAR_RATIO", nameFlags);
MakeRptCmt(0x0001B2FE, "Gear ratio for 1st gear.\nRatio");
MakeNameEx(0x0001B300, "XMSN_IO_KE_DEFAULT_TEMP_ENG_TO_HOT", nameFlags);
MakeNameEx(0x0001B302, "XMSN_IO_KE_MIN_COOLANT_TEMP_THRESH", nameFlags);
MakeNameEx(0x0001B304, "XMSN_IO_KE_MAX_COOLANT_TEMP_THRESH", nameFlags);
MakeNameEx(0x0001B306, "XMSN_IO_KE_STARTUP_TEMP_LOW_THRESH", nameFlags);
MakeNameEx(0x0001B308, "XMSN_IO_KE_STARTUP_TEMP_HIGH_THRESH", nameFlags);
MakeNameEx(0x0001B30A, "XMSN_IO_KE_TRANS_STARTUP_DELAY_TIME", nameFlags);
MakeRptCmt(0x0001B30A, "The minimum amount of time engine must be running beforeStoring Trans_Temp_At_Engine_Start.\nSeconds");
MakeNameEx(0x0001B30E, "XMSN_IO_KE_USE_CONST_FOR_TRANS_TEMP", nameFlags);
MakeNameEx(0x0001B310, "XMSN_IO_KE_DIAG_SYS_VOLTS_RANGE_TIME", nameFlags);
MakeRptCmt(0x0001B310, "Amount of time that system voltage must be out of range before taking remedial action in transmission.\nSeconds");
MakeNameEx(0x0001B312, "XMSN_IO_KE_OUTPUT_SPEED_FREEZE_TIME", nameFlags);
MakeRptCmt(0x0001B312, "Freeze output speed for this long after the start of an upshift or downshift if an ISS is present.\nSeconds");
MakeNameEx(0x0001B314, "XMSN_IO_KE_IMS_DEBOUNCE_TIME", nameFlags);
MakeRptCmt(0x0001B314, "Time that the filtered IMS can be set to the last positive IMS value when the IMS value is Transition or Illegal_Range\nSeconds");
MakeNameEx(0x0001B316, "XMSN_IO_KE_STARTER_MOTOR_CONTROL", nameFlags);
MakeRptCmt(0x0001B316, "TRUE if starter motor control is from the PCM, FALSE otherwise.\nT/F");
MakeNameEx(0x0001B317, "XMSN_IO_KE_IMS_PREDICTIVE_STATE", nameFlags);
MakeRptCmt(0x0001B317, "TRUE if the predictive algorithm is to be used when the IMSstate is Transition or Illegal_Range, FALSE otherwise.\nT/F");
MakeNameEx(0x0001B318, "XMSN_IO_KE_IMS_DEFAULTED_DRIVE_RANGE", nameFlags);
MakeRptCmt(0x0001B318, "Default range used when IMS is requesting failsoft.\nRange");
MakeNameEx(0x0001B31A, "XMSN_IO_KA_PREDICTED_TRANS_FAILSOFT_IMS", nameFlags);
MakeRptCmt(0x0001B31A, "Used to derive Predicted Internal Mode Switch State from Last Positive IMS State and Current IMS State.\nIMS Type");
MakeNameEx(0x0001B39A, "XMSN_IO_KA_PREDICTED_ENG_FAILSOFT_IMS", nameFlags);
MakeRptCmt(0x0001B39A, "Used to derive Predicted Internal Mode Switch State from Last Positive IMS State and Current IMS State.\nIMS Type");
MakeNameEx(0x0001B41A, "XMSN_IO_KE_USE_TRANSMISSION_OIL_LIFE", nameFlags);
MakeRptCmt(0x0001B41A, "Bypass the oil life counter feature if this is false.\nT/F");
MakeNameEx(0x0001B41C, "XPRS_BRAKING_PRESSURE_KE_BRAKING_SLIP", nameFlags);
MakeRptCmt(0x0001B41C, "Slip accross Torque Converter used to determine if engine braking present torque being transmitted from transmission to engine.\nRPM_s");
MakeNameEx(0x0001B41E, "XPRS_BRAKING_PRESSURE_KE_BRAKING_PRESSURE_TPS_LIMIT", nameFlags);
MakeRptCmt(0x0001B41E, "Braking Pressure Throttle position opening for use in determining a coast or power-on shift.\nPercent");
MakeNameEx(0x0001B420, "XPRS_BRAKING_PRESSURE_KE_COAST_SOL_CHANGE_ENABLE", nameFlags);
MakeNameEx(0x0001B422, "XPRS_GARAGE_PRESSURE_KE_GS_PARK_NEUTRAL_MPH", nameFlags);
MakeNameEx(0x0001B424, "XPRS_GARAGE_PRESSURE_KE_GS_REVERSE_DRIVE_MPH", nameFlags);
MakeNameEx(0x0001B426, "XPRS_GARAGE_PRESSURE_KE_ABUSE_PRESS_RAMP_START_FORWRD", nameFlags);
MakeRptCmt(0x0001B426, "Pressure is used at the beginning of the initial abuseramp when in a forward range\nPSI");
MakeNameEx(0x0001B428, "XPRS_GARAGE_PRESSURE_KE_ABUSE_PRESS_RAMP_START_REVRS", nameFlags);
MakeRptCmt(0x0001B428, "Pressure is used at the beginning of the initial abuseramp when in a reverse range\nPSI");
MakeNameEx(0x0001B42A, "XPRS_GARAGE_PRESSURE_KE_ABUSE_PRESS_RAMP_END_FORWRD", nameFlags);
MakeRptCmt(0x0001B42A, "The end value for the torque signal pressure ramp in an initial abuse situation while in a forward range\nPSI");
MakeNameEx(0x0001B42C, "XPRS_GARAGE_PRESSURE_KE_ABUSE_PRESS_RAMP_END_REVRS", nameFlags);
MakeRptCmt(0x0001B42C, "The end value for the torque signal pressure ramp in an initial abuse situation while in a reverse range\nPSI");
MakeNameEx(0x0001B42E, "XPRS_GARAGE_PRESSURE_KE_GARAGE_SHIFT_SLIP_THRESH", nameFlags);
MakeRptCmt(0x0001B42E, "This calibration is used in determining the garageshift type when a garage shift occurs\nRPM");
MakeNameEx(0x0001B430, "XPRS_GARAGE_PRESSURE_KE_GS_CLUTCH_SLIP_HIGH_THRESH", nameFlags);
MakeNameEx(0x0001B432, "XPRS_GARAGE_PRESSURE_KE_GS_CLUTCH_SLIP_LOW_THRESH", nameFlags);
MakeNameEx(0x0001B434, "XPRS_GARAGE_PRESSURE_KE_GS_MAXIMUM_TIME", nameFlags);
MakeRptCmt(0x0001B434, "The maximum amount of time that a garageshift may take.\nSeconds");
MakeNameEx(0x0001B436, "XPRS_GARAGE_PRESSURE_KA_GS_DRIVE_ROLLING_MODIFIER", nameFlags);
MakeRptCmt(0x0001B436, "Rolling modifier to account for a garage shift made into drive with a moving powertrain\nPSI_s");
MakeNameEx(0x0001B468, "XPRS_GARAGE_PRESSURE_KA_GS_REVERSE_ROLLING_MODIFIER", nameFlags);
MakeRptCmt(0x0001B468, "Rolling modifier to account for a garage shift made into reverse with a moving powertrain\nPSI_s");
MakeNameEx(0x0001B49A, "XPRS_GARAGE_PRESSURE_KA_GS_REVERSE_TO_DRIVE_BASE_PRES", nameFlags);
MakeRptCmt(0x0001B49A, "Three dimensional table determining base garage pressurewhen a reverse to drive garage shift occurs\nPSI");
MakeNameEx(0x0001B53C, "XPRS_GARAGE_PRESSURE_KA_GS_DRIVE_TO_REVERSE_BASE_PRES", nameFlags);
MakeRptCmt(0x0001B53C, "Three dimensional table determining base garage pressurewhen a Drive to reverse garage shift occurs\nPSI");
MakeNameEx(0x0001B5DE, "XPRS_GARAGE_PRESSURE_KA_GS_PN_TO_DRIVE_BASE_PRES", nameFlags);
MakeRptCmt(0x0001B5DE, "Three dimensional table determining base garage pressurewhen a park/neutral to drive garage shift occurs\nPSI");
MakeNameEx(0x0001B680, "XPRS_GARAGE_PRESSURE_KA_GS_PN_TO_REVERSE_BASE_PRES", nameFlags);
MakeRptCmt(0x0001B680, "Three dimensional table determining base garage pressurewhen a park/neutral to drive garage shift occurs\nPSI");
MakeNameEx(0x0001B722, "XPRS_GARAGE_PRESSURE_KA_GS_DRIVE_TO_REV_PULSE_TIME", nameFlags);
MakeRptCmt(0x0001B722, "The sum of this calibration and the adapt table is thetotal pulse time commanded for garage shit type Drive_To_Reverse\nSeconds");
MakeNameEx(0x0001B7C4, "XPRS_GARAGE_PRESSURE_KA_GS_PN_TO_DRIVE_PULSE_TIME", nameFlags);
MakeRptCmt(0x0001B7C4, "The sum of this calibration and the adapt table is thetotal pulse time commanded for garage shit type Park_Neutral_To_Drive\nSeconds");
MakeNameEx(0x0001B866, "XPRS_GARAGE_PRESSURE_KA_GS_PN_TO_REVERSE_PULSE_TIME", nameFlags);
MakeRptCmt(0x0001B866, "The sum of this calibration and the adapt table is thetotal pulse time commanded for garage shit type Park_Neutral_To_Reverse\nSeconds");
MakeNameEx(0x0001B908, "XPRS_GARAGE_PRESSURE_KA_GS_REV_TO_DRIVE_PULSE_TIME", nameFlags);
MakeRptCmt(0x0001B908, "The sum of this calibration and the adapt table is thetotal pulse time commanded for garage shit typeReverse_To_Drive\nSeconds");
MakeNameEx(0x0001B9AA, "XPRS_GARAGE_PRESSURE_KV_GS_LAST_DRIVE_TIME_THRESH", nameFlags);
MakeRptCmt(0x0001B9AA, "The time since last drive range must be greater than orequal to this calibration in order for a pulse to becommanded\nSeconds");
MakeNameEx(0x0001B9BC, "XPRS_GARAGE_PRESSURE_KV_GS_LAST_REVERSE_TIME_THRESH", nameFlags);
MakeRptCmt(0x0001B9BC, "The time since last reverse range must be greater thanor equal to this calibration in order for a pulse to becommanded\nSeconds");
MakeNameEx(0x0001B9CE, "XPRS_GARAGE_PRESSURE_KE_GS_DRIVE_TO_REVERSE_PULSE", nameFlags);
MakeRptCmt(0x0001B9CE, "This calibraions returns a pressure pulse value for garageshift type of Drive_To_Reverse\nPSI");
MakeNameEx(0x0001B9D0, "XPRS_GARAGE_PRESSURE_KE_GS_PN_TO_DRIVE_PULSE", nameFlags);
MakeRptCmt(0x0001B9D0, "This calibrations returns a pressure pulse value forgarage shift type of Park_Neutral_To_Drive\nPSI");
MakeNameEx(0x0001B9D2, "XPRS_GARAGE_PRESSURE_KE_GS_PN_TO_REVERSE_PULSE", nameFlags);
MakeRptCmt(0x0001B9D2, "This calibrations returns a pressure pulse value forgarage shift type of Park_Neutral_To_Reverse\nPSI");
MakeNameEx(0x0001B9D4, "XPRS_GARAGE_PRESSURE_KE_GS_REVERSE_TO_DRIVE_PULSE", nameFlags);
MakeRptCmt(0x0001B9D4, "This calibrations returns a pressure pulse value forgarage shift type of Reverse_To_Drive\nPSI");
MakeNameEx(0x0001B9D6, "XPRS_GARAGE_PRESSURE_KE_GS_DELAY_TIME_MAX", nameFlags);
MakeRptCmt(0x0001B9D6, "Garage shift delay time must be less than this calibrationin order for garage shift fill pulse time adapt to bemodified\nSeconds");
MakeNameEx(0x0001B9D8, "XPRS_GARAGE_PRESSURE_KE_GS_ENGINE_SPEED_HIGH", nameFlags);
MakeRptCmt(0x0001B9D8, "The high limit of engine speed for garage shift fillpulse time adapt to be modified\nRPM");
MakeNameEx(0x0001B9DA, "XPRS_GARAGE_PRESSURE_KE_GS_ENGINE_SPEED_LOW", nameFlags);
MakeRptCmt(0x0001B9DA, "The low limit of engine speed for garage shift fillpulse time adapt to be modified\nRPM");
MakeNameEx(0x0001B9DC, "XPRS_GARAGE_PRESSURE_KE_GS_TRANS_TEMP_HIGH", nameFlags);
MakeRptCmt(0x0001B9DC, "The high limit of transmission temperature for garageshift fill pulse time adapt to be modified\nDegreesC");
MakeNameEx(0x0001B9DE, "XPRS_GARAGE_PRESSURE_KE_GS_TRANS_TEMP_LOW", nameFlags);
MakeRptCmt(0x0001B9DE, "The low limit of transmission temperature for garageshift fill pulse time adapt to be modified\nDegreesC");
MakeNameEx(0x0001B9E0, "XPRS_GARAGE_PRESSURE_KE_GS_PROFILE_PHASE_1_RATE", nameFlags);
MakeRptCmt(0x0001B9E0, "Value that iscontinuously added to garage shift pressure profilemodifier until phase 1 time has been reached\nPSI/Second");
MakeNameEx(0x0001B9E2, "XPRS_GARAGE_PRESSURE_KE_GS_PROFILE_PHASE_1_TIME", nameFlags);
MakeRptCmt(0x0001B9E2, "Time limit for phase 1 of the garage shift pressureprofile\nSeconds");
MakeNameEx(0x0001B9E4, "XPRS_GARAGE_PRESSURE_KE_GS_PROFILE_PHASE_2_RATE", nameFlags);
MakeRptCmt(0x0001B9E4, "Value that iscontinuously added to garage shift pressure profilemodifier until phase 2 time has been reached\nPSI/Second");
MakeNameEx(0x0001B9E6, "XPRS_GARAGE_PRESSURE_KE_GS_PROFILE_PHASE_2_TIME", nameFlags);
MakeRptCmt(0x0001B9E6, "Time limit for phase 2 of the garage shift pressureprofile\nSeconds");
MakeNameEx(0x0001B9E8, "XPRS_GARAGE_PRESSURE_KE_GS_PROFILE_PHASE_3_RATE", nameFlags);
MakeNameEx(0x0001B9EA, "XPRS_GARAGE_PRESSURE_KE_GS_PROFILE_PHASE_3_TIME", nameFlags);
MakeRptCmt(0x0001B9EA, "Time limit for phase 3 of the garage shift pressureprofile\nSeconds");
MakeNameEx(0x0001B9EC, "XPRS_GARAGE_PRESSURE_KE_GS_INPUT_SPEED_ACCEL_THRESH", nameFlags);
MakeRptCmt(0x0001B9EC, "This calibration is used to determine the start of thegarage shift when turbine speed acceleration drops belowthis calibration\nRPM/Second");
MakeNameEx(0x0001B9EE, "XPRS_GARAGE_PRESSURE_KE_GS_RD_TO_DR_INPUT_ACCEL_HIGH", nameFlags);
MakeNameEx(0x0001B9F0, "XPRS_GARAGE_PRESSURE_KE_GS_RD_TO_DR_INPUT_ACCEL_LOW", nameFlags);
MakeNameEx(0x0001B9F2, "XPRS_GARAGE_PRESSURE_KE_GS_PN_TO_RD_INPUT_ACCEL_THRE", nameFlags);
MakeNameEx(0x0001B9F4, "XPRS_GARAGE_PRESSURE_KE_GS_PROFILE_MAX_TPS", nameFlags);
MakeRptCmt(0x0001B9F4, "Maximum throttle position for disabling garage profile.\nPercent");
MakeNameEx(0x0001B9F6, "XPRS_GARAGE_PRESSURE_KE_GS_PROFILE_TEMP_HIGH", nameFlags);
MakeRptCmt(0x0001B9F6, "This calibration is for setting the Garage PressureModifier to 0.\nDegrees C");
MakeNameEx(0x0001B9F8, "XPRS_GARAGE_PRESSURE_KE_GS_PROFILE_TEMP_LOW", nameFlags);
MakeRptCmt(0x0001B9F8, "This calibration is for setting the Garage PressureModifier to 0.\nDegrees C");
MakeNameEx(0x0001B9FA, "XPRS_GARAGE_PRESSURE_KE_GS_ADAPT_TOTAL_PULSE_TIME_MAX", nameFlags);
MakeNameEx(0x0001B9FC, "XPRS_GARAGE_PRESSURE_KE_GS_PULSE_TIME_PERCENT_DRV", nameFlags);
MakeRptCmt(0x0001B9FC, "This calibrationis the desired pulse time percent of the shift delayfor Park-Neutral to Drive shifts.\nFactor");
MakeNameEx(0x0001B9FD, "XPRS_GARAGE_PRESSURE_KE_GS_PULSE_TIME_PERCENT_RVRS", nameFlags);
MakeRptCmt(0x0001B9FD, "This calibrationis the desired pulse time percent of the shift delayfor Park-Neutral to Reverse shifts.\nFactor");
MakeNameEx(0x0001B9FE, "XPRS_GARAGE_PRESSURE_KV_GS_ADAPT_CELL_WEIGHT_FACTOR", nameFlags);
MakeNameEx(0x0001BA04, "XPRS_GARAGE_PRESSURE_KV_GS_PULSE_MOD_DRIVE_TABLE", nameFlags);
MakeRptCmt(0x0001BA04, "Pulse time adapt modifier table for a drive garage shift\nSeconds");
MakeNameEx(0x0001BA26, "XPRS_GARAGE_PRESSURE_KV_GS_PULSE_MOD_REVERSE_TABLE", nameFlags);
MakeRptCmt(0x0001BA26, "Pulse time adapt modifier table for a reverse garage shift\nSeconds");
MakeNameEx(0x0001BA48, "XPRS_GARAGE_PRESSURE_KV_GS_FIRST_SHIFT_COLD_DRV_MOD", nameFlags);
MakeRptCmt(0x0001BA48, "Offset added to Garage Pressure when First Garage Shift Cold Drive is indicated.\nPSI");
MakeNameEx(0x0001BA5A, "XPRS_GARAGE_PRESSURE_KV_GS_FIRST_SHIFT_COLD_RVRS_MOD", nameFlags);
MakeRptCmt(0x0001BA5A, "Offset added to Garage Pressure when First Garage Shift Cold Reverse is indicated.\nPSI");
MakeNameEx(0x0001BA6C, "XPRS_GARAGE_PRESSURE_KE_GS_PWRON_MIN_TEMP", nameFlags);
MakeRptCmt(0x0001BA6C, "Transmission temperature must be greater than thisfor power-on garage shifts to be activated.\nDegreesC");
MakeNameEx(0x0001BA6E, "XPRS_GARAGE_PRESSURE_KE_GS_PWRON_MIN_TPS", nameFlags);
MakeRptCmt(0x0001BA6E, "Throttle must be greater than thisfor power-on garage shifts to be activated.\nPercent");
MakeNameEx(0x0001BA70, "XPRS_GARAGE_PRESSURE_KE_GS_PWRON_CLUTCH_SLIP_HI", nameFlags);
MakeRptCmt(0x0001BA70, "Clutch_Slip must exceed this before Power-On GarageBase Pressure is allowed to start ramping.\nRPM");
MakeNameEx(0x0001BA72, "XPRS_GARAGE_PRESSURE_KE_GS_PWRON_DRV_MAX_PLS_TIME", nameFlags);
MakeNameEx(0x0001BA74, "XPRS_GARAGE_PRESSURE_KE_GS_PWRON_REV_MAX_PLS_TIME", nameFlags);
MakeNameEx(0x0001BA76, "XPRS_GARAGE_PRESSURE_KE_GS_PWRON_DRV_PROF_CLSLIP", nameFlags);
MakeRptCmt(0x0001BA76, "If Clutch_Slip is less than this, Power-On Garage BasePressure starts to ramp for P/N to Drive or Reverse toDrive Pwron GS.\nRPM");
MakeNameEx(0x0001BA78, "XPRS_GARAGE_PRESSURE_KE_GS_PWRON_REV_PROF_CLSLIP", nameFlags);
MakeRptCmt(0x0001BA78, "If Clutch_Slip is less than this, Power-On Garage BasePressure starts to ramp for P/N to Reverse or Drive toReverse Pwron GS.\nRPM");
MakeNameEx(0x0001BA7A, "XPRS_GARAGE_PRESSURE_KE_GS_PWRON_END_TIME", nameFlags);
MakeRptCmt(0x0001BA7A, "If GS_Pwron_End_Timer is greater than this, the Power-OnGarage Shift Pressure Calculation is terminated.\nSeconds");
MakeNameEx(0x0001BA7C, "XPRS_GARAGE_PRESSURE_KE_GS_PWRON_END_PTS", nameFlags);
MakeRptCmt(0x0001BA7C, "If Pwron_Clutch_Slip_Status is equal to End_Triggered,Pwron_Garage_Pressure_Base is set equal to this.\nPSI");
MakeNameEx(0x0001BA7E, "XPRS_GARAGE_PRESSURE_KV_GS_PWRON_BASE_TEMP_FACTOR", nameFlags);
MakeRptCmt(0x0001BA7E, "Temperature compensation factor used in base pressurecalculation for Power-On Garage Shift Pressure.\nFactor");
MakeNameEx(0x0001BA8E, "XPRS_GARAGE_PRESSURE_KV_GS_PWRON_DRV_END_CLSLIP", nameFlags);
MakeRptCmt(0x0001BA8E, "If Clutch_Slip is less than this, Status is End_Triggeredfor P/N to drive or reverse to drive garage shift.\nRPM");
MakeNameEx(0x0001BAA4, "XPRS_GARAGE_PRESSURE_KV_GS_PWRON_REV_END_CLSLIP", nameFlags);
MakeRptCmt(0x0001BAA4, "If Clutch_Slip is less than this, Status is End_Triggeredfor P/N to reverse or drive to reverse garage shift.\nRPM");
MakeNameEx(0x0001BABA, "XPRS_GARAGE_PRESSURE_KV_GS_PWRON_DRV_PROFILE", nameFlags);
MakeRptCmt(0x0001BABA, "Pressure_Ramp_Rate when P/N to drive or reverse to drivegarage shift occurs.\nPSI/Sec");
MakeNameEx(0x0001BACC, "XPRS_GARAGE_PRESSURE_KV_GS_PWRON_REV_PROFILE", nameFlags);
MakeRptCmt(0x0001BACC, "Pressure_Ramp_Rate when P/N to reverse or drive to reversegarage shift occurs.\nPSI/Sec");
MakeNameEx(0x0001BADE, "XPRS_GARAGE_PRESSURE_KV_GS_PWRON_PLS_TEMP_FACTOR", nameFlags);
MakeRptCmt(0x0001BADE, "Pressure pulse temperature compensation factorfor Power-On Garage Shift Pressure control.\nFactor");
MakeNameEx(0x0001BAEE, "XPRS_GARAGE_PRESSURE_KA_GS_PWRON_DRV_BASE", nameFlags);
MakeRptCmt(0x0001BAEE, "Base Pressure for Power-On Garage Shift for aP/N to drive or a reverse to drive garage shift.\nPSI");
MakeNameEx(0x0001BB90, "XPRS_GARAGE_PRESSURE_KA_GS_PWRON_REV_BASE", nameFlags);
MakeRptCmt(0x0001BB90, "Base Pressure for Power-On Garage Shift for aP/N to reverse or a drive to reverse garage shift.\nPSI");
MakeNameEx(0x0001BC32, "XPRS_GARAGE_PRESSURE_KA_GS_PWRON_DRV_PULSE", nameFlags);
MakeRptCmt(0x0001BC32, "Pulse Magnitude for Power-On Garage Shift for aP/N to drive or a reverse to drive garage shift.\nPSI");
MakeNameEx(0x0001BC64, "XPRS_GARAGE_PRESSURE_KA_GS_PWRON_REV_PULSE", nameFlags);
MakeRptCmt(0x0001BC64, "Pulse Magnitude for Power-On Garage Shift for aP/N to drive or a reverse to drive garage shift.\nPSI");
MakeNameEx(0x0001BC96, "XPRS_GARAGE_PRESSURE_KA_GS_PWRON_DRV_PULSE_MOD_TIME", nameFlags);
MakeNameEx(0x0001BCC8, "XPRS_GARAGE_PRESSURE_KA_GS_PWRON_REV_PULSE_MOD_TIME", nameFlags);
MakeNameEx(0x0001BCFA, "XPRS_GARAGE_PRESSURE_KA_ATM_PWRON_DRV_RDCTN_MAG", nameFlags);
MakeRptCmt(0x0001BCFA, "Reduction Magnitude for Power-On Garage Shift TorqueManagement for P/N to drive or reverse to drive shift.\nPercent");
MakeNameEx(0x0001BD2C, "XPRS_GARAGE_PRESSURE_KA_ATM_PWRON_REV_RDCTN_MAG", nameFlags);
MakeRptCmt(0x0001BD2C, "Reduction Magnitude for Power-On Garage Shift TorqueManagement for P/N to reverse or drive to reverse shift.\nPercent");
MakeNameEx(0x0001BD5E, "XPRS_GARAGE_PRESSURE_KE_ATM_PWRON_CLSLIP_HI", nameFlags);
MakeRptCmt(0x0001BD5E, "Clutch_Slip must exceed this before Power-On GarageShift Torque Control is activated.\nRPM");
MakeNameEx(0x0001BD60, "XPRS_GARAGE_PRESSURE_KE_ATM_PWRON_DRV_CLSLIP_LO", nameFlags);
MakeRptCmt(0x0001BD60, "Clutch_Slip must be below this for PowerOn_GS_Reductionto start to ramp for a P/N to drive or a reverseto drive shift.\nRPM");
MakeNameEx(0x0001BD62, "XPRS_GARAGE_PRESSURE_KE_ATM_PWRON_REV_CLSLIP_LO", nameFlags);
MakeRptCmt(0x0001BD62, "Clutch_Slip must be below this for PowerOn_GS_Reductionto start to ramp for a P/N to reverse or a driveto reverse shift.\nRPM");
MakeNameEx(0x0001BD64, "XPRS_GARAGE_PRESSURE_KE_ATM_PWRON_DRV_RAMP_TIME", nameFlags);
MakeRptCmt(0x0001BD64, "This is the time duration that PowerOn_GS_Reductionis linearly ramped during a P/N to drive or a reverseto drive shift.\nSeconds");
MakeNameEx(0x0001BD66, "XPRS_GARAGE_PRESSURE_KE_ATM_PWRON_REV_RAMP_TIME", nameFlags);
MakeRptCmt(0x0001BD66, "This is the time duration that PowerOn_GS_Reductionis linearly ramped during a P/N to reverse or a driveto reverse shift.\nSeconds");
MakeNameEx(0x0001BD68, "XPRS_GARAGE_PRESSURE_KE_ATM_PWRON_MIN_COOLANT", nameFlags);
MakeRptCmt(0x0001BD68, "Coolant_Temperature must be greater than this forpower-on garage shift torque control to be activated.\nDegreesC");
MakeNameEx(0x0001BD6A, "XPRS_GARAGE_PRESSURE_KE_ATM_PWRON_MIN_RUNTIME", nameFlags);
MakeRptCmt(0x0001BD6A, "Engine_Run_Time must be greater than this forpower-on garage shift torque control to be activated.\nSeconds");
MakeNameEx(0x0001BD6E, "XPRS_RATIO_KA_PRESSURE_PROFILE_INIT_OFFSET", nameFlags);
MakeRptCmt(0x0001BD6E, "To add an initial offset to thePressure_Profile_Modifier before it begins ramping with the1st offset\nPSI_s");
MakeNameEx(0x0001BDBC, "XPRS_RATIO_KA_PRESSURE_PROFILE_1ST_OFFSET", nameFlags);
MakeRptCmt(0x0001BDBC, "Used to determine pressure profile modifier.\nPSI_s");
MakeNameEx(0x0001BE0A, "XPRS_RATIO_KA_PRESSURE_PROFILE_2ND_OFFSET", nameFlags);
MakeNameEx(0x0001BE58, "XPRS_RATIO_KA_PRESS_PROFILE_START_RATIO", nameFlags);
MakeRptCmt(0x0001BE58, "Contains the starting gear ratio values for upshift timing.\nRatio");
MakeNameEx(0x0001BEA6, "XPRS_RATIO_KA_PRESS_PROFILE_MIDDLE_RATIO", nameFlags);
MakeRptCmt(0x0001BEA6, "Ratio values used to trigger 2nd pressure profile modifier to Shift_Pressure.\nRatio");
MakeNameEx(0x0001BEF4, "XPRS_RATIO_KA_PRESS_PROFILE_END_RATIO", nameFlags);
MakeRptCmt(0x0001BEF4, "Contains the ending gear ratio values for upshift timing.\nRatio");
MakeNameEx(0x0001BF42, "XPRS_RATIO_KV_12_DLOW_ACCUM_PROF_OFFSET", nameFlags);
MakeNameEx(0x0001BF64, "XPRS_RATIO_KV_12_DLOW_ACCUM_PROF_RATE", nameFlags);
MakeNameEx(0x0001BF86, "XPRS_RATIO_KV_DLOW_ACCUM_PROF_START", nameFlags);
MakeRptCmt(0x0001BF86, "Time threshold for the start of the 1-2 drive low urban shift accumulator ramp\nSeconds");
MakeNameEx(0x0001BFA8, "XPRS_SHIFT_KE_ENABLE_G_I_TRQ_RATIO_MULT", nameFlags);
MakeRptCmt(0x0001BFA8, "Enables base pressure modification for upshifts based on ratio of gearbox and inertia torque.\nT/F");
MakeNameEx(0x0001BFAA, "XPRS_SHIFT_KA_DOWNSHIFT_PRESS_MODIFICATION", nameFlags);
MakeRptCmt(0x0001BFAA, "Used to find Inertia_Torque\nPSI_S");
MakeNameEx(0x0001BFFE, "XPRS_SHIFT_KA_JUMP_DS_PRESS_OFFSET", nameFlags);
MakeNameEx(0x0001C036, "XPRS_SHIFT_KV_JUMP_DS_MOD_TIME_LIMIT", nameFlags);
MakeRptCmt(0x0001C036, "The amount of time to limit Jump_Down_Modifier to seejump downshift.\nSeconds");
MakeNameEx(0x0001C03A, "XPRS_SHIFT_KA_JUMP_DS_BASE_PRESS_OFFSET", nameFlags);
MakeRptCmt(0x0001C03A, "\n");
MakeNameEx(0x0001C07E, "XPRS_SHIFT_KV_DRIVE2_PRESS_OFFSET_TABLE", nameFlags);
MakeRptCmt(0x0001C07E, "Offset addedto Base_Pressure during 1-2 and 2-1 shifts in Drive_2\nPSI_S");
MakeNameEx(0x0001C0A0, "XPRS_SHIFT_KV_WHEEL_SLIP_RATIO", nameFlags);
MakeRptCmt(0x0001C0A0, "Contains the wheel slipgear ratio value FOR calculating the wheel slip modifier\nRatio");
MakeNameEx(0x0001C0A6, "XPRS_SHIFT_KV_WHEEL_SLIP_PRESSURE", nameFlags);
MakeRptCmt(0x0001C0A6, "Used to determinethe wheel slip modifier\nPSI");
MakeNameEx(0x0001C0AC, "XPRS_SHIFT_KE_ELIMINATE_DN_TURB_MOD_ELE_ON", nameFlags);
MakeRptCmt(0x0001C0AC, "When TRUE, eliminate the use of the downshift pressuremodifier when the braking element is applied.\nT/F");
MakeNameEx(0x0001C0AE, "XPRS_SHIFT_KA_FIRST_UPSHIFT_COLD_FACTOR", nameFlags);
MakeRptCmt(0x0001C0AE, "Factor multiplied by Base Pressure when First Upshift Cold  is indicated.\nFactor");
MakeNameEx(0x0001C0E4, "XPRS_STEADY_STATE_KE_SS_DISABLE_ADAPT_TIME", nameFlags);
MakeRptCmt(0x0001C0E4, "Amount of time an adapt cell update will be delayed after a previous adapt update.\nSeconds");
MakeNameEx(0x0001C0E6, "XPRS_STEADY_STATE_KE_SS_ADAPT_RANGE_CHANGE_TIME", nameFlags);
MakeRptCmt(0x0001C0E6, "The amount of time that Time_Since_Last_Range_Change must be greater than in order to allow a SS adapt.\nSeconds");
MakeNameEx(0x0001C0E8, "XPRS_STEADY_STATE_KE_SS_ADAPT_OUTPUT_SPEED_VALID", nameFlags);
MakeRptCmt(0x0001C0E8, "Vehicle speed must be greater than this for a valid steady state adapts update.\nMPH");
MakeNameEx(0x0001C0EA, "XPRS_STEADY_STATE_KE_SS_ADAPT_CC_HIGH", nameFlags);
MakeRptCmt(0x0001C0EA, "This calibration defines a minimum limit of clutchcontrol capacity before allowing steady state adapts.\nScaler");
MakeNameEx(0x0001C0EC, "XPRS_STEADY_STATE_KE_SS_ADAPT_COUNT_HIGH", nameFlags);
MakeRptCmt(0x0001C0EC, "Update steady state adapt up pressure cells when slip counter exceeds this cal.\nCounts");
MakeNameEx(0x0001C0EE, "XPRS_STEADY_STATE_KE_SS_ADAPT_COUNT_LOW", nameFlags);
MakeRptCmt(0x0001C0EE, "Update steady state adapt down pressure cells when slip counter exceeds this cal.\nCounts");
MakeNameEx(0x0001C0F0, "XPRS_STEADY_STATE_KV_SS_ADAPTIVE_CELLS_DOWN", nameFlags);
MakeRptCmt(0x0001C0F0, "This is subtracted from the steady state adaptive pressure cells when adapt down conditions are met.\nPSI");
MakeNameEx(0x0001C100, "XPRS_STEADY_STATE_KV_SS_ADAPTIVE_CELLS_UP", nameFlags);
MakeRptCmt(0x0001C100, "This is added to the steady state adaptive pressure cells when adapt up conditions are met.\nPSI");
MakeNameEx(0x0001C110, "XPRS_STEADY_STATE_KV_LINE_CLUTCH_GAIN", nameFlags);
MakeRptCmt(0x0001C110, "Gain used to calculate steady state line pressure.\nGain");
MakeNameEx(0x0001C118, "XPRS_STEADY_STATE_KV_BRK_ELEMENT_LINE_CLUTCH_GAIN", nameFlags);
MakeRptCmt(0x0001C118, "Amount of clutch gain to be used in steady state linedetermination when in coast braking.\nGain");
MakeNameEx(0x0001C120, "XPRS_STEADY_STATE_KV_SS_LINE_TEMP_COMP", nameFlags);
MakeRptCmt(0x0001C120, "Temperature compensation factor to steady state line pressure.\nPSI/Ftlb");
MakeNameEx(0x0001C132, "XPRS_STEADY_STATE_KV_LINE_CLUTCH_OFFSET", nameFlags);
MakeRptCmt(0x0001C132, "Offset used to calculate steady state line pressure.\nPSI");
MakeNameEx(0x0001C142, "XPRS_STEADY_STATE_KV_BRK_ELEMENT_LINE_CLUTCH_OFST", nameFlags);
MakeRptCmt(0x0001C142, "Offset used to calculate steady state line pressure.\nPSI");
MakeNameEx(0x0001C152, "XPRS_STEADY_STATE_KV_PRESSURE_OFFSET", nameFlags);
MakeRptCmt(0x0001C152, "Pressure offset used in steady state pressure calculation.\nPSI");
MakeNameEx(0x0001C160, "XPRS_STEADY_STATE_KV_LINE_TCC_OFFSET_PRESSURE", nameFlags);
MakeRptCmt(0x0001C160, "Clutch pressure offset used in steady state pressure calculation when TCC is on.\nPSI");
MakeNameEx(0x0001C182, "XPRS_STEADY_STATE_KV_PRESSURE_GAIN", nameFlags);
MakeRptCmt(0x0001C182, "Pressure gain used in steady state pressure calculation.\nGain");
MakeNameEx(0x0001C190, "XPRS_STEADY_STATE_KE_SS_ADAPT_CLUTCH_SLIP_HIGH", nameFlags);
MakeRptCmt(0x0001C190, "This determines if clutch slip is high enough to adapt up steady state pressure.\nRPM");
MakeNameEx(0x0001C192, "XPRS_STEADY_STATE_KE_SS_ADAPT_CLUTCH_SLIP_LOW", nameFlags);
MakeRptCmt(0x0001C192, "This determines if clutch slip is low enough to adapt down steady state pressure.\nRPM");
MakeNameEx(0x0001C194, "XPRS_STEADY_STATE_KE_SS_ADAPT_SLIP_HIGH", nameFlags);
MakeRptCmt(0x0001C194, "This determines if TCC slip is high enough to adapt up steady state pressure.\nRPM");
MakeNameEx(0x0001C196, "XPRS_STEADY_STATE_KE_SS_ADAPT_SLIP_LOW", nameFlags);
MakeRptCmt(0x0001C196, "This determines if TCC slip is low enough to adapt down steady state pressure.\nRPM");
MakeNameEx(0x0001C198, "XPRS_STEADY_STATE_KV_CLUTCH_SLIP_ADAPT_UP_COUNTER", nameFlags);
MakeRptCmt(0x0001C198, "Amount to increment slip counter by when clutch slip conditions are met for steady state adapt up pressure.\nCounts");
MakeNameEx(0x0001C1A2, "XPRS_STEADY_STATE_KV_TCC_SLIP_ADAPT_UP", nameFlags);
MakeRptCmt(0x0001C1A2, "Amount to increment slip counter by when TCC slip conditions are met for steady state adapt up pressure.\nCounts");
MakeNameEx(0x0001C1AC, "XPRS_STEADY_STATE_KV_SS_ADAPT_DOWN_COUNTER", nameFlags);
MakeRptCmt(0x0001C1AC, "Amount to decrement slip counter by when slip conditions are met for steady state adapt down pressure.\nCounts");
MakeNameEx(0x0001C1BC, "XPRS_STEADY_STATE_KE_SS_BRAKING_TORQUE", nameFlags);
MakeNameEx(0x0001C1BE, "XPRS_STEADY_STATE_KA_SS_BRAKING_ADAPT_ENABLED", nameFlags);
MakeNameEx(0x0001C1CE, "XPRS_STEADY_STATE_KV_D1_BRAKING_ELEMENT_ON_RANGE", nameFlags);
MakeRptCmt(0x0001C1CE, "Indicates if braking element is applied for Drive_Low dueto the hydromechanical design of the transmission.\nBOOLEAN");
MakeNameEx(0x0001C1D2, "XPRS_STEADY_STATE_KV_D2_BRAKING_ELEMENT_ON_RANGE", nameFlags);
MakeRptCmt(0x0001C1D2, "Indicates if braking element is applied for Drive_Low dueto the hydromechanical design of the transmission.\nBOOLEAN");
MakeNameEx(0x0001C1D6, "XPRS_STEADY_STATE_KV_D3_BRAKING_ELEMENT_ON_RANGE", nameFlags);
MakeRptCmt(0x0001C1D6, "Indicates if braking element is applied for Drive_Low dueto the hydromechanical design of the transmission.\nBOOLEAN");
MakeNameEx(0x0001C1DA, "XPRS_STEADY_STATE_KV_D4_BRAKING_ELEMENT_ON_RANGE", nameFlags);
MakeRptCmt(0x0001C1DA, "Indicates if braking element is applied for Drive_Low dueto the hydromechanical design of the transmission.\nBOOLEAN");
MakeNameEx(0x0001C1DE, "XPRS_STEADY_STATE_KE_SS_DELTA_THROTTLE_FILTER_COEF", nameFlags);
MakeRptCmt(0x0001C1DE, "Lag filter coefficient used to achieve the filtered steadystate throttle.\nCoeff");
MakeNameEx(0x0001C1E0, "XPRS_STEADY_STATE_KE_SS_DELTA_THROTTLE_GAIN", nameFlags);
MakeRptCmt(0x0001C1E0, "This calibration is multiplied with the steady state deltathrotttle to yield steady state delta throttle modifier.\nPSI/Percent");
MakeNameEx(0x0001C1E4, "XPRS_STEADY_STATE_KE_SS_DELTA_THROTTLE_MOD_LIMIT", nameFlags);
MakeRptCmt(0x0001C1E4, "The steady state delta throttle modifier is limited to thisvalue.\nPSI");
MakeNameEx(0x0001C1E6, "XPRS_STEADY_STATE_KE_SS_DELTA_THROTTLE_THRESHOLD", nameFlags);
MakeNameEx(0x0001C1E8, "XPRS_STEADY_STATE_KE_SS_CLOSED_THROT_MIN_TPS", nameFlags);
MakeRptCmt(0x0001C1E8, "\n");
MakeNameEx(0x0001C1EA, "XPRS_STEADY_STATE_KE_SS_CLOSED_THROT_MIN_MPH", nameFlags);
MakeRptCmt(0x0001C1EA, "Do Closed Throttle calculation of steady state pressure if MPH is less than this.\nMPH");
MakeNameEx(0x0001C1EC, "XPRS_STEADY_STATE_KA_SS_CLOSED_THROT_LINE_PRES", nameFlags);
MakeRptCmt(0x0001C1EC, "Steady state line pressure in Closed Throttle mode.\nPSI");
MakeNameEx(0x0001C26A, "XPRS_STEADY_STATE_KE_USE_STEADY_STATE_ADAPTS", nameFlags);
MakeRptCmt(0x0001C26A, "Bypass the steady state adapt update if this is false.\nT/F");
MakeNameEx(0x0001C26C, "XSEM_ABUSE_TORQUE_KE_DRIVE_RAMP_OUT_TIME", nameFlags);
MakeRptCmt(0x0001C26C, "Amount of time to ramp the torque reduction to stall torquereduction when range = Drive\nSeconds");
MakeNameEx(0x0001C26E, "XSEM_ABUSE_TORQUE_KE_REVERSE_RAMP_OUT_TIME", nameFlags);
MakeRptCmt(0x0001C26E, "Amount of time to ramp the torque reduction to stall torquereduction when range = Reverse\nSeconds");
MakeNameEx(0x0001C270, "XSEM_ABUSE_TORQUE_KE_SEM_ENGINE_SPD_ABUSE_LIMIT", nameFlags);
MakeRptCmt(0x0001C270, "Engine speed limit for detecting abuse conditions\nRPM");
MakeNameEx(0x0001C272, "XSEM_ABUSE_TORQUE_KE_SEM_INPUT_SPEED_LIMIT", nameFlags);
MakeRptCmt(0x0001C272, "Minimum input speed limit used to determine  garage shiftinformation\nRPM");
MakeNameEx(0x0001C274, "XSEM_ABUSE_TORQUE_KE_SEM_THROTTLE_ABUSE_LIMIT", nameFlags);
MakeRptCmt(0x0001C274, "Percent throttle limit for detecting abuse conditions\nPercent");
MakeNameEx(0x0001C276, "XSEM_ABUSE_TORQUE_KE_SPEED_RAMP_OUT_TIME", nameFlags);
MakeRptCmt(0x0001C276, "Amount of time to ramp the torque reduction to stall torquereduction when input speed becomes less thanKE_SEM_Input_Speed_Limit\nSeconds");
MakeNameEx(0x0001C278, "XSEM_ABUSE_TORQUE_KE_VEHICLE_SPEED_THRESHOLD", nameFlags);
MakeRptCmt(0x0001C278, "Vehicle speed threshold used to determine abuse mode\nMPH");
MakeNameEx(0x0001C27A, "XSEM_ABUSE_TORQUE_KV_ABUSE_TORQUE_REDUCTION", nameFlags);
MakeRptCmt(0x0001C27A, "Amount of abuse torque reduction as function of engine speed\nPercent");
MakeNameEx(0x0001C29E, "XSEM_ABUSE_TORQUE_KV_ABUSE_RAMP_TIME", nameFlags);
MakeRptCmt(0x0001C29E, "Duration of the abuse ramp for the Torque_Signal_Pressure for the initial occurance of the abuse mode.\nSeconds");
MakeNameEx(0x0001C2AE, "XSEM_RATIO_KA_DNSHFT_SEM_RAMP_OUT_STRT_TIME", nameFlags);
MakeRptCmt(0x0001C2AE, "Ramp out begin time used to determine when maximum torquereduction should end and begin ramping from maximum to zero\nSeconds");
MakeNameEx(0x0001C314, "XSEM_RATIO_KA_DNSHIFT_SEM_RAMP_IN_END_RATIO", nameFlags);
MakeNameEx(0x0001C37A, "XSEM_RATIO_KA_DWN_SEM_STRT_RAMP_IN_RATIO", nameFlags);
MakeRptCmt(0x0001C37A, "Ramp in start ratio limit used to determine when downshifttorque reduction ramping up should be begin\nRatio");
MakeNameEx(0x0001C3E0, "XSEM_RATIO_KA_UPSHFT_SEM_RMP_OUT_STRT_RATIO", nameFlags);
MakeRptCmt(0x0001C3E0, "Ratio thresholds that decide when torque reduction shouldbegin ramping from maximum to zero\nRatio");
MakeNameEx(0x0001C446, "XSEM_RATIO_KA_UPSHIFT_SEM_RMP_OUT_END_RATIO", nameFlags);
MakeRptCmt(0x0001C446, "Ratio thresholds that decide when torque reduction shouldstop ramping from maximum to zero\nRatio");
MakeNameEx(0x0001C4AC, "XSEM_RATIO_KA_UPSHIFT_SEM_RMP_IN_STRT_RATIO", nameFlags);
MakeRptCmt(0x0001C4AC, "Ratio thresholds that decide when torque reduction shouldbegin ramping from zero to maximum\nRatio");
MakeNameEx(0x0001C512, "XSEM_RATIO_KA_UPSHIFT_SEM_RAMP_IN_END_RATIO", nameFlags);
MakeRptCmt(0x0001C512, "Ratio thresholds that decide when torque reduction shouldstop ramping from zero to maximum and stay at maximum\nRatio");
MakeNameEx(0x0001C578, "XSEM_RATIO_KA_SEM_END_TIME_THRESHOLD", nameFlags);
MakeRptCmt(0x0001C578, "End time threshold table used to end ratio-based torque management for a downshift.\nSeconds");
MakeNameEx(0x0001C5DE, "XSEM_RATIO_KV_BRK_TRQ_MGT_MIN_ENGINE_SPEED", nameFlags);
MakeRptCmt(0x0001C5DE, "Minimum engine speed to enable brake torque management.\nRPM");
MakeNameEx(0x0001C5E4, "XSEM_RATIO_KV_BRK_TRQ_MGT_UNDERLAP_RATIO_A", nameFlags);
MakeRptCmt(0x0001C5E4, "Ratio value to start requesting brake torque management for an underlap manual downshift.\nRatio");
MakeNameEx(0x0001C5EA, "XSEM_RATIO_KV_BRK_TRQ_MGT_RATIO_A", nameFlags);
MakeRptCmt(0x0001C5EA, "Ratio value to start requesting brake torque management for a regular manual downshift.\nRatio");
MakeNameEx(0x0001C5F0, "XSEM_RATIO_KV_BRK_TRQ_MGT_RATIO_B", nameFlags);
MakeRptCmt(0x0001C5F0, "Ratio value to finish requesting brake torque management for a regular manual downshift.\nRatio");
MakeNameEx(0x0001C5F6, "XSEM_RATIO_KV_BRK_TRQ_MGT_END_TIME", nameFlags);
MakeRptCmt(0x0001C5F6, "Amount of time to continue brake torque management after a ratio reaches KV_Brk_Trq_Mgt_Ratio_B for a manual downshift.\nSeconds");
MakeNameEx(0x0001C5FC, "XSEM_SHIFT_TORQUE_KE_SEM_PN_DISABLE_TPS", nameFlags);
MakeRptCmt(0x0001C5FC, "Defines the highest throttle pedal position allowed forsetting the percent of reduction torque equal to zero.\nPercent");
MakeNameEx(0x0001C5FE, "XSEM_SHIFT_TORQUE_KV_DNSHFT_SEM_MPH_SPEED_DISABLE", nameFlags);
MakeRptCmt(0x0001C5FE, "The vehicle speed limits to disable downshift torque management.\nMPH");
MakeNameEx(0x0001C604, "XSEM_SHIFT_TORQUE_KE_SEM_START_TIME_LIMIT", nameFlags);
MakeRptCmt(0x0001C604, "\n");
MakeNameEx(0x0001C606, "XSEM_STALL_TORQUE_KE_SEM_STALL_ENGINE_SPEED_HIGH", nameFlags);
MakeRptCmt(0x0001C606, "Engine speed limit above which stall could be selected\nRPM");
MakeNameEx(0x0001C608, "XSEM_STALL_TORQUE_KE_SEM_STALL_ENGINE_SPEED_LOW", nameFlags);
MakeRptCmt(0x0001C608, "Engine speed below which stall will not be selected\nRPM");
MakeNameEx(0x0001C60A, "XSEM_STALL_TORQUE_KE_SEM_STALL_THROTTLE_HIGH", nameFlags);
MakeRptCmt(0x0001C60A, "Throttle limit above which stall could be selected\nPercent");
MakeNameEx(0x0001C60C, "XSEM_STALL_TORQUE_KE_SEM_STALL_THROTTLE_LOW", nameFlags);
MakeRptCmt(0x0001C60C, "Throttle below which stall will not be selected\nPercent");
MakeNameEx(0x0001C60E, "XSHFT_3RD_GEAR_DEFAULT_KE_ENGINE_SPEED_DEFAULT_LIMIT", nameFlags);
MakeRptCmt(0x0001C60E, "When soft landing is in affect and desired gear is second gear and engine speed is greater than this, don't allow shifts.\nRPM");
MakeNameEx(0x0001C610, "XSHFT_ADAPT_KE_1_2_DETENT_ADAPT_UP_ENABLE", nameFlags);
MakeRptCmt(0x0001C610, "Adapt Enabling timer for 1-2 detent upshifts.\nSeconds");
MakeNameEx(0x0001C612, "XSHFT_ADAPT_KE_2_3_DETENT_ADAPT_UP_ENABLE", nameFlags);
MakeRptCmt(0x0001C612, "Adapt Enabling timer for 2-3 detent upshifts.\nSeconds");
MakeNameEx(0x0001C614, "XSHFT_ADAPT_KE_3_4_DETENT_ADAPT_UP_ENABLE", nameFlags);
MakeRptCmt(0x0001C614, "Adapt Enabling timer for 3-4 detent upshifts.\nSeconds");
MakeNameEx(0x0001C616, "XSHFT_ADAPT_KE_1_2_DETENT_ADAPT_DOWN_ENABLE", nameFlags);
MakeRptCmt(0x0001C616, "Used as an enabling contingency for performing a 1-2 detent upshift adapt.\nSeconds");
MakeNameEx(0x0001C618, "XSHFT_ADAPT_KE_2_3_DETENT_ADAPT_DOWN_ENABLE", nameFlags);
MakeRptCmt(0x0001C618, "Used as an enabling contingency for performing a 2-3 detent upshift adapt.\nSeconds");
MakeNameEx(0x0001C61A, "XSHFT_ADAPT_KE_3_4_DETENT_ADAPT_DOWN_ENABLE", nameFlags);
MakeRptCmt(0x0001C61A, "Used as an enabling contingency for performing a 3-4 detent upshift adapt.\nSeconds");
MakeNameEx(0x0001C61C, "XSHFT_ADAPT_KE_1_2_DETENT_ADAPT_ERROR", nameFlags);
MakeRptCmt(0x0001C61C, "Enable 1-2 detent upshift adatps when Delay_Time_Error is greater than or equal to this.\nSeconds");
MakeNameEx(0x0001C61E, "XSHFT_ADAPT_KE_2_3_DETENT_ADAPT_ERROR", nameFlags);
MakeRptCmt(0x0001C61E, "Enable 2-3 detent upshift adatps when Delay_Time_Error is greater than or equal to this.\nSeconds");
MakeNameEx(0x0001C620, "XSHFT_ADAPT_KE_3_4_DETENT_ADAPT_ERROR", nameFlags);
MakeRptCmt(0x0001C620, "Enable 3-4 detent upshift adatps when Delay_Time_Error is greater than or equal to this.\nSeconds");
MakeNameEx(0x0001C622, "XSHFT_ADAPT_KE_1_2_DETENT_ERROR_MIN", nameFlags);
MakeRptCmt(0x0001C622, "Minimum value of adapt cells for a 1-2 detent upshift.\nSeconds");
MakeNameEx(0x0001C624, "XSHFT_ADAPT_KE_2_3_DETENT_ERROR_MIN", nameFlags);
MakeRptCmt(0x0001C624, "Minimum value of adapt cells for a 2-3 detent upshift.\nSeconds");
MakeNameEx(0x0001C626, "XSHFT_ADAPT_KE_3_4_DETENT_ERROR_MIN", nameFlags);
MakeRptCmt(0x0001C626, "Minimum value of adapt cells for a 3-4 detent upshift.\nSeconds");
MakeNameEx(0x0001C628, "XSHFT_ADAPT_KE_1_2_DETENT_ERROR_MAX", nameFlags);
MakeRptCmt(0x0001C628, "Maximum value of adapt cells for a 1-2 detent upshift.\nSeconds");
MakeNameEx(0x0001C62A, "XSHFT_ADAPT_KE_2_3_DETENT_ERROR_MAX", nameFlags);
MakeRptCmt(0x0001C62A, "Maximum value of adapt cells for a 2-3 detent upshift.\nSeconds");
MakeNameEx(0x0001C62C, "XSHFT_ADAPT_KE_3_4_DETENT_ERROR_MAX", nameFlags);
MakeRptCmt(0x0001C62C, "Maximum value of adapt cells for a 3-4 detent upshift.\nSeconds");
MakeNameEx(0x0001C62E, "XSHFT_ADAPT_KE_1_2_DETENT_HIGH_TEMP_ENABLE", nameFlags);
MakeRptCmt(0x0001C62E, "Upper limitthat Transmission Temperature can be during a 1 2 shiftand still adapt\nDegreesC");
MakeNameEx(0x0001C630, "XSHFT_ADAPT_KE_2_3_DETENT_HIGH_TEMP_ENABLE", nameFlags);
MakeRptCmt(0x0001C630, "Upper limitthat Transmission Temperature can be during a 2 3 shiftand still adapt\nDegreesC");
MakeNameEx(0x0001C632, "XSHFT_ADAPT_KE_3_4_DETENT_HIGH_TEMP_ENABLE", nameFlags);
MakeRptCmt(0x0001C632, "Upper limitthat Transmission Temperature can be during a 3 4 shiftand still adapt\nDegreesC");
MakeNameEx(0x0001C634, "XSHFT_ADAPT_KE_1_2_DETENT_LOW_TEMP_ENABLE", nameFlags);
MakeRptCmt(0x0001C634, "Lower limitthat Transmission Temperature can be during a 1 2 shiftand still adapt\nDegreesC");
MakeNameEx(0x0001C636, "XSHFT_ADAPT_KE_2_3_DETENT_LOW_TEMP_ENABLE", nameFlags);
MakeRptCmt(0x0001C636, "Lower limitthat Transmission Temperature can be during a 2 3 shiftand still adapt\nDegreesC");
MakeNameEx(0x0001C638, "XSHFT_ADAPT_KE_3_4_DETENT_LOW_TEMP_ENABLE", nameFlags);
MakeRptCmt(0x0001C638, "Lower limitthat Transmission Temperature can be during a 3 4 shiftand still adapt\nDegreesC");
MakeNameEx(0x0001C63A, "XSHFT_ADAPT_KE_DETENT_LOW_CELL_WEIGHT_FACTOR", nameFlags);
MakeRptCmt(0x0001C63A, "To scale the amount the lower cell is adapted by\nNONE");
MakeNameEx(0x0001C63B, "XSHFT_ADAPT_KE_DETENT_CELL_WEIGHT_FACTOR", nameFlags);
MakeRptCmt(0x0001C63B, "To scale the amount the target cell is adapted by\nNONE");
MakeNameEx(0x0001C63C, "XSHFT_ADAPT_KE_DETENT_HIG_CELL_WEIGHT_FACTOR", nameFlags);
MakeRptCmt(0x0001C63C, "To scale the amount the upper cell is adapted by\nNONE");
MakeNameEx(0x0001C63E, "XSHFT_ADAPT_KV_DETENT_ADAPT_ERROR", nameFlags);
MakeRptCmt(0x0001C63E, "\n");
MakeNameEx(0x0001C650, "XSHFT_ADAPT_KV_1_2_DETENT_UPSHIFT_MODIFIER", nameFlags);
MakeRptCmt(0x0001C650, "Delay line time modifier for 1-2 detent upshifts.\nSeconds");
MakeNameEx(0x0001C662, "XSHFT_ADAPT_KV_1_2_DETENT_UPSHIFT_DELAY", nameFlags);
MakeRptCmt(0x0001C662, "Predicted delay time for a 1-2 detent upshift.\nSeconds");
MakeNameEx(0x0001C674, "XSHFT_ADAPT_KV_2_3_DETENT_UPSHIFT_DELAY", nameFlags);
MakeRptCmt(0x0001C674, "Predicted delay time for a 2-3 detent upshift.\nSeconds");
MakeNameEx(0x0001C686, "XSHFT_ADAPT_KV_3_4_DETENT_UPSHIFT_DELAY", nameFlags);
MakeRptCmt(0x0001C686, "Predicted delay time for a 3-4 detent upshift.\nSeconds");
MakeNameEx(0x0001C698, "XSHFT_ADAPT_KV_WHLSLP_INH_DETENT_ADAPT_LOW", nameFlags);
MakeRptCmt(0x0001C698, "Disable detent adapts if wheel slip accel is less than this.\nMPH/Sec");
MakeNameEx(0x0001C69E, "XSHFT_ADAPT_KV_WHLSLP_INH_DETENT_ADAPT_HIGH", nameFlags);
MakeRptCmt(0x0001C69E, "Disable detent adapts if wheel slip accel is greater than this.\nMPH/Sec");
MakeNameEx(0x0001C6A4, "XSHFT_MODIFICATIONS_KE_DOWNSHIFT_TCC_DELAY_TIME", nameFlags);
MakeRptCmt(0x0001C6A4, "Delay a downshift until TCC has been off for this amount of time.\nSeconds");
MakeNameEx(0x0001C6A6, "XSHFT_MODIFICATIONS_KE_DOWNSHIFT_DELAY_SLIP_THRESH", nameFlags);
MakeRptCmt(0x0001C6A6, "Delay a downshift until TCC slip is less than this RPM threshold.\nRPM_s");
MakeNameEx(0x0001C6A8, "XSHFT_MODIFICATIONS_KE_DOWNSHIFT_42_LOW_TIME", nameFlags);
MakeRptCmt(0x0001C6A8, "Delay a 3-2 downshift when the gear change time is greater than this low window time and less than the high window time.\nSeconds");
MakeNameEx(0x0001C6AA, "XSHFT_MODIFICATIONS_KE_DOWNSHIFT_42_HIGH_TIME", nameFlags);
MakeRptCmt(0x0001C6AA, "Delay a 3-2 downshift when the gear change time is less thanthis high window time and greater than the low window time.\nSeconds");
MakeNameEx(0x0001C6AC, "XSHFT_MODIFICATIONS_KE_DOWNSHIFT_SEQ_DELAY_MAX_TIME", nameFlags);
MakeRptCmt(0x0001C6AC, "The maximum downshift delay used with the 4-3-2 downshiftsequencing delay\nSeconds");
MakeNameEx(0x0001C6AE, "XSHFT_MODIFICATIONS_KE_DOWNSHIFT_SEQ_DELAY_MIN_TIME", nameFlags);
MakeRptCmt(0x0001C6AE, "The minimum downshift delay used with the 4-3-2 downshiftsequencing delay\nSeconds");
MakeNameEx(0x0001C6B0, "XSHFT_MODIFICATIONS_KE_DOWNSHIFT_DELAY_HI_MPH_THRESH", nameFlags);
MakeRptCmt(0x0001C6B0, "Vehicle speed low threshold used to determine the downshiftdelay time used with the 4-3-2 downshift sequencing delay\nMPH");
MakeNameEx(0x0001C6B2, "XSHFT_MODIFICATIONS_KE_DOWNSHIFT_DELAY_LO_MPH_THRESH", nameFlags);
MakeRptCmt(0x0001C6B2, "Vehicle speed high threshold used to determine the downshiftdelay time used with the 4-3-2 downshift sequencing delay\nMPH");
MakeNameEx(0x0001C6B4, "XSHFT_MODIFICATIONS_KE_2_1_INHIBIT_MIN_MPH", nameFlags);
MakeNameEx(0x0001C6B6, "XSHFT_MODIFICATIONS_KE_2_1_INHIBIT_POS_DELTA_THR", nameFlags);
MakeRptCmt(0x0001C6B6, "Used in comparison with Positive_Delta_Throttle toinhibit a 2-1 downshift.\nPercent");
MakeNameEx(0x0001C6B8, "XSHFT_MODIFICATIONS_KE_2_1_INHIBIT_THR_THRESHOLD", nameFlags);
MakeNameEx(0x0001C6BA, "XSHFT_MODIFICATIONS_KE_2_1_INHIBIT_ACC_THRESH_LO", nameFlags);
MakeRptCmt(0x0001C6BA, "If the vehicle acceleration falls below this value,the 2-1 downshift inhibit is disabled.\nMPH_per_Second_S");
MakeNameEx(0x0001C6BC, "XSHFT_MODIFICATIONS_KE_2_1_INHIBIT_ACC_THRESH_HI", nameFlags);
MakeRptCmt(0x0001C6BC, "If the filtered vehicle acceleration is above this value,the 2-1 downshift inhibit is enabled.\nMPH_per_Second_S");
MakeNameEx(0x0001C6BE, "XSHFT_MODIFICATIONS_KE_1_3_UPSHIFT_SEQUENCING_TIME", nameFlags);
MakeRptCmt(0x0001C6BE, "Total time required to be in second gear before allowing a shift to third.\nSeconds");
MakeNameEx(0x0001C6C0, "XSHFT_MODIFICATIONS_KE_1_4_UPSHIFT_SEQUENCING_TIME", nameFlags);
MakeRptCmt(0x0001C6C0, "Total time required to be in second and third gear before allowing a shift to fourth.\nSeconds");
MakeNameEx(0x0001C6C2, "XSHFT_MODIFICATIONS_KE_2_4_UPSHIFT_SEQUENCING_TIME", nameFlags);
MakeRptCmt(0x0001C6C2, "Total time required to be in third gear before allowing a shift to fourth.\nSeconds");
MakeNameEx(0x0001C6C4, "XSHFT_MODIFICATIONS_KE_INHIBIT_DOWN_TO_SECOND_MPH", nameFlags);
MakeRptCmt(0x0001C6C4, "Used to determine if the downshift to second should beinhibited if the diagnostic malf has occurred.\nMPH");
MakeNameEx(0x0001C6C6, "XSHFT_MODIFICATIONS_KV_MANUAL_DWNSHFT_42_DELAY_TIME", nameFlags);
MakeRptCmt(0x0001C6C6, "Total time required to be in third gear before allowing a shift to fourth.\nSeconds");
MakeNameEx(0x0001C6D0, "XSHFT_MODIFICATIONS_KE_INHIBIT_2_1_SINCE_1ST_GEAR", nameFlags);
MakeNameEx(0x0001C6D2, "XSHFT_MODIFICATIONS_KE_INHIBIT_2_1_SINCE_1ST_MPH_THR", nameFlags);
MakeRptCmt(0x0001C6D2, "Inhibit a 2-1 downshift after a 1-2 upshift only if vehicle speed is greater than this value.\nMPH");
MakeNameEx(0x0001C6D4, "XTEMP_STATUS_KE_COLD_TRANS_LOW_THRESHOLD", nameFlags);
MakeRptCmt(0x0001C6D4, "When Transmission temperature falls below this value, the transmission cold indicator is set.\nDeg C");
MakeNameEx(0x0001C6D6, "XTEMP_STATUS_KV_HOT_MODE_STATOR_ENTRANCE", nameFlags);
MakeNameEx(0x0001C718, "XTEMP_STATUS_KE_HOT_MODE_STATOR_SPD_RATIO_MAX", nameFlags);
MakeRptCmt(0x0001C718, "TCC Speed ratio value at which Hot_Mode_Stator_Entrance_Timer gets reset to zero, in hot mode stator temperature test\nFactor");
MakeNameEx(0x0001C719, "XTEMP_STATUS_KE_HOT_MODE_STATOR_SPD_RATIO_MIN", nameFlags);
MakeRptCmt(0x0001C719, "Minimum TCC speed ratio value to enable hot mode stator  temperature test.\nFactor");
MakeNameEx(0x0001C71A, "XTEMP_STATUS_KE_HOT_MODE_STATOR_DELAY_TIMER", nameFlags);
MakeRptCmt(0x0001C71A, "Maximum amount of time before Hot_Mode_Stator_Delay_Timer  and Hot_Mode_Stator_Entrance_Timer are reset to zero.\nSeconds");
MakeNameEx(0x0001C71C, "XTEMP_STATUS_KE_HOT_MODE_STATOR_EXIT_TEMP", nameFlags);
MakeRptCmt(0x0001C71C, "Transmission sump temperature threshold value to exit      hot mode stator temperature test (static).\nDeg C");
MakeNameEx(0x0001C71E, "XTEMP_STATUS_KE_HOT_MODE_STATOR_TEMP_MIN", nameFlags);
MakeRptCmt(0x0001C71E, "Minimum transmission sump temperature value to enable   hot mode stator temperature test.\nDeg C");
MakeNameEx(0x0001C720, "XTEMP_STATUS_KE_HOT_MODE_STATOR_VEHSPD_MIN", nameFlags);
MakeRptCmt(0x0001C720, "Minimum vehicle speed value to enable hot mode stator    temperature test.\nMPH");
MakeNameEx(0x0001C722, "XTEMP_STATUS_KE_HOT_STATOR_LOW_THRESHOLD", nameFlags);
MakeRptCmt(0x0001C722, "Temperature above which stator hot mode is exited.\nDeg C");
MakeNameEx(0x0001C724, "XTEMP_STATUS_KE_HOT_STATOR_HIGH_THRESHOLD", nameFlags);
MakeRptCmt(0x0001C724, "Temperature above which stator hot mode is activated.\nDeg C");
MakeNameEx(0x0001C726, "XTEMP_STATUS_KE_HOT_STATOR_MIN_TIME_LIMIT", nameFlags);
MakeRptCmt(0x0001C726, "Amount of time stator hot mode is active before returning  to normal operation.\nSeconds");
MakeNameEx(0x0001C728, "XTEMP_STATUS_KV_HOT_MODE_BASE_DELTA_TABLE", nameFlags);
MakeRptCmt(0x0001C728, "Determine base transmission fluid temperature rate of change  during normal mode in order to enter transmission hot mode\nDegC/Min");
MakeNameEx(0x0001C737, "XTEMP_STATUS_KE_HOT_MODE_DESIRED_PEAK_TEMP", nameFlags);
MakeRptCmt(0x0001C737, "Desired hot mod peak transmission fluid sump temperature\nDeg C");
MakeNameEx(0x0001C738, "XTEMP_STATUS_KE_KALMAN_RATE_OF_CHANGE_GAIN", nameFlags);
MakeRptCmt(0x0001C738, "Kalman filter rate of change of  transmission sump temperature.\nInverse_Minute");
MakeNameEx(0x0001C73A, "XTEMP_STATUS_KE_HOT_MODE_EXIT_TIMER", nameFlags);
MakeNameEx(0x0001C73C, "XTEMP_STATUS_KV_HOT_MODE_EXIT_TEMP_TABLE", nameFlags);
MakeRptCmt(0x0001C73C, "Determine transmission fluid sump temperature threshold  to exit hot mode return to normal mode.\nDeg C");
MakeNameEx(0x0001C75A, "XTEMP_STATUS_KE_HOT_MODE_SUMP_TEMP_MIN", nameFlags);
MakeRptCmt(0x0001C75A, "Minimum transmission sump temperature  value to enable hot  mode sump temperature test.\nDeg C");
MakeNameEx(0x0001C75C, "XTEMP_STATUS_KV_HOT_MODE_ADAPT_MOD_TABLE", nameFlags);
MakeRptCmt(0x0001C75C, "Hot mode adaptive outputs modifier table.\nDegC_per_Min_vs_DegC_Delta_Table");
MakeNameEx(0x0001C76E, "XTEMP_STATUS_KE_KALMAN_TEMPERATURE_GAIN", nameFlags);
MakeRptCmt(0x0001C76E, "Kalman filter gain of transmission sump  temperature.\nGain");
MakeNameEx(0x0001C770, "XTEMP_STATUS_KE_TCC_TEMP_DIAG_LOW_THRESH", nameFlags);
MakeRptCmt(0x0001C770, "When trans. temperature falls below this value, the TCC Off diagnostic override is cleared.\nDeg C");
MakeNameEx(0x0001C772, "XTEMP_STATUS_KE_TCC_TEMP_DIAG_HIGH_THRESH", nameFlags);
MakeRptCmt(0x0001C772, "When trans. temperature rises below this value, the TCC Off diagnostic override is set.\nDeg C");
MakeNameEx(0x0001C774, "XTEMP_STATUS_KE_COLD_TRANS_HIGH_THRESHOLD", nameFlags);
MakeRptCmt(0x0001C774, "When Transmission temperature rises above this value, the transmission cold indicator is cleared.\nDeg C");
MakeNameEx(0x0001C776, "XTCC_CONTROL_KE_TCC_BRAKE_VEHICLE_SPEED_HIGH", nameFlags);
MakeNameEx(0x0001C778, "XTCC_CONTROL_KE_TCC_BRAKE_THROTTLE_HIGH", nameFlags);
MakeNameEx(0x0001C77A, "XTCC_CONTROL_KE_HOT_MODE_FULL_LOCK_ENABLE", nameFlags);
MakeRptCmt(0x0001C77A, "Flag that indicates whether to allow ECCC full lockup inHot Mode.\nBOOLEAN");
MakeNameEx(0x0001C77C, "XTCC_CONTROL_KE_TCC_ENABLE_ON_DELAY_TIME", nameFlags);
MakeRptCmt(0x0001C77C, "TCC Enable is turned on after this amount of time has elapsed from the start of an apply.\nSeconds");
MakeNameEx(0x0001C77E, "XTCC_CONTROL_KE_TCC_APPLY_RAMP_DELAY_TIME", nameFlags);
MakeRptCmt(0x0001C77E, "TCC apply ramping begins after this amount of time has elapsed from when TCC Enable was turned on.\nSeconds");
MakeNameEx(0x0001C780, "XTCC_CONTROL_KE_TCC_ENABLE_OFF_DELAY_TIME", nameFlags);
MakeRptCmt(0x0001C780, "Used by release logic to help enable Failsafe Delay Phase.\nSeconds");
MakeNameEx(0x0001C782, "XTCC_CONTROL_KE_TCC_APPLY_SLIP_DIFFERENCE", nameFlags);
MakeRptCmt(0x0001C782, "TCC apply is completed when KE_TCC_Apply_Slip_Difference + TCC_On_Reference_Slip >= Slip.\nRPM");
MakeNameEx(0x0001C784, "XTCC_CONTROL_KE_TCC_LOW_FAILSAFE_THRESHOLD", nameFlags);
MakeNameEx(0x0001C786, "XTCC_CONTROL_KE_TCC_HIGH_FAILSAFE_THRESHOLD", nameFlags);
MakeNameEx(0x0001C788, "XTCC_CONTROL_KE_TCC_FAILSAFE_DELAY_TIME", nameFlags);
MakeRptCmt(0x0001C788, "Maximum time that the Release Failsafe Phase is in affect.\nSeconds");
MakeNameEx(0x0001C78A, "XTCC_CONTROL_KE_TCC_MAX_RELEASE_DELAY", nameFlags);
MakeRptCmt(0x0001C78A, "TCC release is completed when release time exceeds this amount of time.\nSeconds");
MakeNameEx(0x0001C78C, "XTCC_CONTROL_KE_TCC_MAX_RAMP_OFF_TIME", nameFlags);
MakeRptCmt(0x0001C78C, "TCC release is completed when release time exceeds this amount of time.\nSeconds");
MakeNameEx(0x0001C78E, "XTCC_CONTROL_KE_TCC_RELEASE_SLIP_THRESHOLD", nameFlags);
MakeRptCmt(0x0001C78E, "TCC release complete when Slip > KE_TCC_Release_Slip_Threshold\nRPM");
MakeNameEx(0x0001C790, "XTCC_CONTROL_KE_AC_LOCKED_MODE_ENABLE", nameFlags);
MakeRptCmt(0x0001C790, "Enable AC Locked Mode Cal.\nBOOLEAN");
MakeNameEx(0x0001C792, "XTCC_CONTROL_KE_LOCK_HIGH_VEHICLE_SPEED", nameFlags);
MakeRptCmt(0x0001C792, "Reenable Full Lockup possible when Vehicle Speed > this cal.\nMPH");
MakeNameEx(0x0001C794, "XTCC_CONTROL_KE_LOCK_LOW_VEHICLE_SPEED", nameFlags);
MakeRptCmt(0x0001C794, "Enable Full Lockup if Vehicle Speed > this cal.\nMPH");
MakeNameEx(0x0001C796, "XTCC_CONTROL_KE_LOCK_REENABLE_TIME", nameFlags);
MakeRptCmt(0x0001C796, "Time-Out for TCC_Lock_Reenable_Timer.\nSeconds");
MakeNameEx(0x0001C798, "XTCC_CONTROL_KE_LOCKED_OFF_SLIP_OFFSET", nameFlags);
MakeRptCmt(0x0001C798, "Offset KV_TCC_On_Reference_Slip in TCC Full Lockup Select Logic.\nRPM_s");
MakeNameEx(0x0001C79A, "XTCC_CONTROL_KE_LOCKED_ON_SLIP_OFFSET", nameFlags);
MakeRptCmt(0x0001C79A, "Offset KV_TCC_On_Reference_Slip in TCC Full Lockup Select Logic.\nRPM_s");
MakeNameEx(0x0001C79C, "XTCC_CONTROL_KE_LOCKED_OFF_TIME", nameFlags);
MakeRptCmt(0x0001C79C, "Time-Out for Locked_Off_Timer.\nSeconds");
MakeNameEx(0x0001C79E, "XTCC_CONTROL_KE_LOCKED_ON_TIME", nameFlags);
MakeRptCmt(0x0001C79E, "Time-Out for Locked_On_Timer.\nSeconds");
MakeNameEx(0x0001C7A0, "XTCC_CONTROL_KE_SHIFT_STABILIZATION_ENABLE", nameFlags);
MakeRptCmt(0x0001C7A0, "Boolean calibration to show if the shift stabilization is enabled or disabled.\nBOOLEAN");
MakeNameEx(0x0001C7A1, "XTCC_CONTROL_KE_FULL_LOCK_ON_UPSHIFT", nameFlags);
MakeNameEx(0x0001C7A2, "XTCC_CONTROL_KE_LOCK_ENGINE_TORQUE_LOW", nameFlags);
MakeRptCmt(0x0001C7A2, "If Engine Torque is less than this cal and Vehicle speed is less than KE_Lock_Low_Vehicle_Speed then Lock mode is exited.\nFtLb");
MakeNameEx(0x0001C7A4, "XTCC_CONTROL_KE_LOCK_ENGINE_TORQUE_HIGH", nameFlags);
MakeRptCmt(0x0001C7A4, "One contingencies that must be met before entering ECCC full lockup is that Engine Torque must be greater than this cal.\nFtLb");
MakeNameEx(0x0001C7A6, "XTCC_CONTROL_KE_TCC_ON_SLIP_MIN", nameFlags);
MakeNameEx(0x0001C7A8, "XTCC_CONTROL_KE_TCC_ON_MIN_REF_SLIP", nameFlags);
MakeNameEx(0x0001C7AA, "XTCC_CONTROL_KE_TCC_UPSHIFT_SLIP_MIN", nameFlags);
MakeNameEx(0x0001C7AC, "XTCC_CONTROL_KV_TCC_RAMP_HOLD_DELAY", nameFlags);
MakeRptCmt(0x0001C7AC, "When this time is reached, the Ramp freeze is cleared which allows the ramp to be adjusted(if not frozen due to an upshift).\nSec");
MakeNameEx(0x0001C7B2, "XTCC_CONTROL_KV_UPSHIFT_TCC_RAMP_DELAY", nameFlags);
MakeRptCmt(0x0001C7B2, "Amount of time to freeze the ramp after an upshift has completed.\nSec");
MakeNameEx(0x0001C7B8, "XTCC_CONTROL_KE_TCC_APPLY_CROWD_DELAY_TIME", nameFlags);
MakeNameEx(0x0001C7BA, "XTCC_CONTROL_KE_TCC_LOW_BARO_DELAY_ENABLE", nameFlags);
MakeRptCmt(0x0001C7BA, "Apply_Delay_Timer is set to a cal if Barometric Pressure  is less than this.\nKPA");
MakeNameEx(0x0001C7BB, "XTCC_CONTROL_KE_TCC_HIGH_BARO_DELAY_DISABLE", nameFlags);
MakeRptCmt(0x0001C7BB, "Apply_Delay_Timer is set to Reapply_Delay_Timer if Barometric Pressure is greater than this.\nKPA");
MakeNameEx(0x0001C7BC, "XTCC_CONTROL_KE_ALT_APPLY_DELAY_TIME", nameFlags);
MakeRptCmt(0x0001C7BC, "Extend apply delay by this at altitude.\nSeconds");
MakeNameEx(0x0001C7BE, "XTCC_CONTROL_KE_TCC_COAST_WHILE_MANUAL_DNSHFT", nameFlags);
MakeRptCmt(0x0001C7BE, "If true, manual downshifts will continue to stay in coast mode if in coast mode at start of shift.\nT/F");
MakeNameEx(0x0001C7BF, "XTCC_CONTROL_KE_TCC_COAST_WHILE_BRAKE_ENGAGED", nameFlags);
MakeNameEx(0x0001C7C0, "XTCC_CONTROL_KA_COAST_MODE_RANGE_GEAR_ENABLE", nameFlags);
MakeRptCmt(0x0001C7C0, "TRUE enables coast mode for this gear and range combination.\nT/F");
MakeNameEx(0x0001C7CC, "XTCC_CONTROL_KE_TCC_LO_DRIVE2_OFF", nameFlags);
MakeRptCmt(0x0001C7CC, "Enables Drive 2 Range Check.\nBoolean");
MakeNameEx(0x0001C7CD, "XTCC_CONTROL_KE_TCC_DRIVE3_OFF", nameFlags);
MakeRptCmt(0x0001C7CD, "Enables Drive 3 Range Check.\nBoolean");
MakeNameEx(0x0001C7CE, "XTCC_CONTROL_KE_TCC_DRIVE4_OFF", nameFlags);
MakeRptCmt(0x0001C7CE, "Enables Drive 4 Range Check.\nBoolean");
MakeNameEx(0x0001C7CF, "XTCC_CONTROL_KE_TCC_UPSHIFT_OFF", nameFlags);
MakeNameEx(0x0001C7D0, "XTCC_CONTROL_KE_SCHEDULED_RELEASE_DELAY", nameFlags);
MakeRptCmt(0x0001C7D0, "Re-apply delay for scheduled release.\nSeconds");
MakeNameEx(0x0001C7D2, "XTCC_CONTROL_KE_SCH_REL_BUSY_DETECT_TIME", nameFlags);
MakeRptCmt(0x0001C7D2, "Re-apply delay for scheduled release.\nSeconds");
MakeNameEx(0x0001C7D4, "XTCC_CONTROL_KE_SCH_REL_BUSY_DELAY_TIME", nameFlags);
MakeRptCmt(0x0001C7D4, "Business added re-apply delay for scheduled release.\nSeconds");
MakeNameEx(0x0001C7D6, "XTCC_CONTROL_KE_INC_BUSYNESS_DELAY", nameFlags);
MakeRptCmt(0x0001C7D6, "Amount of time a TCC minimum throttle release re-applyshould be incremented due to busyness.\nSeconds");
MakeNameEx(0x0001C7D8, "XTCC_CONTROL_KE_DEC_BUSYNESS_DELAY", nameFlags);
MakeRptCmt(0x0001C7D8, "Amount of time a TCC minimum throttle release re-applyshould be decremented due to busyness.\nSeconds");
MakeNameEx(0x0001C7DA, "XTCC_CONTROL_KE_APPLY_COUNTER_STEP", nameFlags);
MakeRptCmt(0x0001C7DA, "Amount of steps the apply counter must increment in orderfor the lock delay to be decremented by cal. value.\nSHORTCARD");
MakeNameEx(0x0001C7DC, "XTCC_CONTROL_KV_TCC_UPSHIFT_OFF_TIME", nameFlags);
MakeRptCmt(0x0001C7DC, "Specifies the amount of time that TCC will be turned off for when an upshift is desired.\nSeconds");
MakeNameEx(0x0001C7E4, "XTCC_CONTROL_KV_TCC_DOWNSHIFT_OFF_TIME", nameFlags);
MakeRptCmt(0x0001C7E4, "Specifies the amount of time that TCC will be turned off for when a downshift is desired.\nSeconds");
MakeNameEx(0x0001C7EC, "XTCC_CONTROL_KV_TCC_AC_ON_HIGH_LIMIT", nameFlags);
MakeRptCmt(0x0001C7EC, "Upper speed limit at which TCC is enabled when AC is on.\nMPH");
MakeNameEx(0x0001C7F2, "XTCC_CONTROL_KV_TCC_AC_ON_LOW_LIMIT", nameFlags);
MakeRptCmt(0x0001C7F2, "Lower speed limit at which TCC is disabled when AC is on.\nMPH");
MakeNameEx(0x0001C7F8, "XTCC_CONTROL_KE_MIN_THROTTLE_DELAY_TIME", nameFlags);
MakeRptCmt(0x0001C7F8, "Base Re-apply delay time after a minimum throttle release.\nSeconds");
MakeNameEx(0x0001C7FA, "XTCC_CONTROL_KE_BUSYNESS_DETECTION_TIME", nameFlags);
MakeRptCmt(0x0001C7FA, "Amount of time after a minimum throttle release to detect throttle busyness\nSeconds");
MakeNameEx(0x0001C7FE, "XTCC_CONTROL_KE_COAST_STOP_TIME", nameFlags);
MakeRptCmt(0x0001C7FE, "Maximum time in Coast Mode if Slip > KE_Coast_Slip_High.\nSeconds");
MakeNameEx(0x0001C800, "XTCC_CONTROL_KE_COAST_SLIP_HIGH", nameFlags);
MakeRptCmt(0x0001C800, "Maximum time in Coast Mode if Slip > KE_Coast_Slip_High.\nRPM_s");
MakeNameEx(0x0001C802, "XTCC_CONTROL_KE_TCC_COAST_THROTTLE_HIGH", nameFlags);
MakeRptCmt(0x0001C802, "Exit Coast Mode if Throttle > KE_Coast_Slip_High.\nPercent");
MakeNameEx(0x0001C804, "XTCC_CONTROL_KE_TCC_COAST_THROTTLE_LOW", nameFlags);
MakeRptCmt(0x0001C804, "Enter Coast Mode if Throttle < KE_Coast_Slip_Low and no Minimum Throttle.\nPercent");
MakeNameEx(0x0001C806, "XTCC_CONTROL_KE_TCC_ALT_APPLY_OFFSET", nameFlags);
MakeRptCmt(0x0001C806, "TCC Apply point offset during third gear and baro pressure below a threshold.\nMPH_s");
MakeNameEx(0x0001C808, "XTCC_CONTROL_KE_TCC_ALT_RELEASE_OFFSET", nameFlags);
MakeRptCmt(0x0001C808, "TCC Release point offset during third gear and baro pressure below a threshold.\nMPH_s");
MakeNameEx(0x0001C80A, "XTCC_CONTROL_KE_TCC_BARO_APPLY_LOW", nameFlags);
MakeRptCmt(0x0001C80A, "Lower baro pressure threshold below which TCC will not apply.\nKPa");
MakeNameEx(0x0001C80B, "XTCC_CONTROL_KE_TCC_BARO_APPLY_HIGH", nameFlags);
MakeRptCmt(0x0001C80B, "Upper baro pressure threshold above which TCC will apply.\nKPa");
MakeNameEx(0x0001C80C, "XTCC_CONTROL_KE_MIN_THROTTLE_SPEED_LOW", nameFlags);
MakeRptCmt(0x0001C80C, "When vehicle speed is less than this, use min throttle threshold 1.\nMPH");
MakeNameEx(0x0001C80E, "XTCC_CONTROL_KE_MIN_THROTTLE_SPEED_HIGH", nameFlags);
MakeRptCmt(0x0001C80E, "When vehicle speed is greater than this, use min throttle threshold 2.\nMPH");
MakeNameEx(0x0001C810, "XTCC_CONTROL_KE_MIN_THROTTLE_1_LOW_THRESHOLD", nameFlags);
MakeRptCmt(0x0001C810, "Enter minimum throttle mode when throttle is below this.\nPercent");
MakeNameEx(0x0001C812, "XTCC_CONTROL_KE_MIN_THROTTLE_1_HIGH_THRESHOLD", nameFlags);
MakeRptCmt(0x0001C812, "Exit minimum throttle mode when throttle is above this.\nPercent");
MakeNameEx(0x0001C814, "XTCC_CONTROL_KE_MIN_THROTTLE_2_LOW_THRESHOLD", nameFlags);
MakeRptCmt(0x0001C814, "Enter minimum throttle mode when throttle is below this.\nPercent");
MakeNameEx(0x0001C816, "XTCC_CONTROL_KE_MIN_THROTTLE_2_HIGH_THRESHOLD", nameFlags);
MakeRptCmt(0x0001C816, "Exit minimum throttle mode when throttle is above this.\nPercent");
MakeNameEx(0x0001C818, "XTCC_CONTROL_KE_TCC_BRAKE_THROTTLE_LOW", nameFlags);
MakeNameEx(0x0001C81A, "XTCC_CONTROL_KE_TCC_BRAKE_VEHICLE_SPEED_LOW", nameFlags);
MakeNameEx(0x0001C81C, "XTCC_CONTROL_KE_NEGDELTHR_OFF_TIME_FROM_ECCC", nameFlags);
MakeRptCmt(0x0001C81C, "Amount of time off mode is selected after negative delta throttle and previously TCC is On or applying.\nSec");
MakeNameEx(0x0001C81E, "XTCC_CONTROL_KE_NEGDELTHR_OFF_TIME_FROM_OFF", nameFlags);
MakeRptCmt(0x0001C81E, "Amount of time off mode is selected after negative delta throttle and previously TCC is Off or releasing.\nSec");
MakeNameEx(0x0001C820, "XTCC_CONTROL_KE_POS_DELTA_THROT_SPEED", nameFlags);
MakeNameEx(0x0001C822, "XTCC_CONTROL_KE_POSDELTHR_HIMPH_OFF_TIME_ECCC", nameFlags);
MakeNameEx(0x0001C824, "XTCC_CONTROL_KE_POSDELTHR_HIMPH_OFF_TIME_OFF", nameFlags);
MakeNameEx(0x0001C826, "XTCC_CONTROL_KE_POSDELTHR_LOMPH_OFF_TIME_ECCC", nameFlags);
MakeNameEx(0x0001C828, "XTCC_CONTROL_KE_POSDELTHR_LOMPH_OFF_TIME_OFF", nameFlags);
MakeNameEx(0x0001C82A, "XTCC_CONTROL_KE_POSDELTHR_RELEASE_TIME", nameFlags);
MakeRptCmt(0x0001C82A, "Amount of release time after positive delta throttle condition has occurred and previously TCC is On or Releasing.\nSec");
MakeNameEx(0x0001C82C, "XTCC_CONTROL_KE_NEG_DELTA_OFF_THROTTLE_THRESH", nameFlags);
MakeNameEx(0x0001C82E, "XTCC_CONTROL_KE_NEG_DELTA_ON_THROTTLE_THRESH", nameFlags);
MakeNameEx(0x0001C830, "XTCC_CONTROL_KE_POS_DEL_THR_OFF_THRESH_HIMPH", nameFlags);
MakeNameEx(0x0001C832, "XTCC_CONTROL_KE_POS_DEL_THR_OFF_THRESH_LOMPH", nameFlags);
MakeNameEx(0x0001C834, "XTCC_CONTROL_KE_POS_DEL_THR_ON_THRESH_HIMPH", nameFlags);
MakeNameEx(0x0001C836, "XTCC_CONTROL_KE_POS_DEL_THR_ON_THRESH_LOMPH", nameFlags);
MakeNameEx(0x0001C838, "XTCC_CONTROL_KV_TCC_REFERENCE_SLIP_2", nameFlags);
MakeRptCmt(0x0001C838, "TCC on mode reference slip for second gear.\nRPM");
MakeNameEx(0x0001C84A, "XTCC_CONTROL_KV_TCC_REFERENCE_SLIP_3", nameFlags);
MakeRptCmt(0x0001C84A, "TCC on mode reference slip for third gear.\nRPM");
MakeNameEx(0x0001C85C, "XTCC_CONTROL_KV_TCC_REFERENCE_SLIP_4", nameFlags);
MakeRptCmt(0x0001C85C, "TCC on mode reference slip for fourth gear.\nRPM");
MakeNameEx(0x0001C86E, "XTCC_CONTROL_KE_COAST_MODE_ENABLE", nameFlags);
MakeRptCmt(0x0001C86E, "Enables the coast mode conditions.\nBoolean");
MakeNameEx(0x0001C870, "XTCC_CONTROL_KE_COAST_VEH_SPD_HIGH", nameFlags);
MakeRptCmt(0x0001C870, "Output Speed must exceed this value to meet coast speed conditions.\nMPH");
MakeNameEx(0x0001C872, "XTCC_CONTROL_KE_COAST_VEH_SPD_LOW", nameFlags);
MakeRptCmt(0x0001C872, "Minimum Output Speed to meet coast speed conditions.\nMPH");
MakeNameEx(0x0001C874, "XTCC_EXECUTION_KE_TCC_TRQ_POS_TPS_RELEASE_RATE", nameFlags);
MakeRptCmt(0x0001C874, "Rate off TCC release when Pos. Delta Throttle.\nPSI/Sec");
MakeNameEx(0x0001C876, "XTCC_EXECUTION_KE_TCC_MINIMUM_PRESSURE", nameFlags);
MakeRptCmt(0x0001C876, "TCC pressure set to this in off mode.\nPSI");
MakeNameEx(0x0001C878, "XTCC_EXECUTION_KE_TCC_APPLY_PRESSURE_GAIN", nameFlags);
MakeRptCmt(0x0001C878, "Used to find Torque based Apply Operating Point.\nPSI/FtLB");
MakeNameEx(0x0001C87A, "XTCC_EXECUTION_KV_TCC_APPLY_PRESSURE_OFFSET", nameFlags);
MakeRptCmt(0x0001C87A, "Used to find Torque based Apply Operating Point.\nPSI_s");
MakeNameEx(0x0001C89C, "XTCC_EXECUTION_KE_TCC_FULL_LOCKUP_OFFSET_TRQ", nameFlags);
MakeRptCmt(0x0001C89C, "Used to find Torque based Locked Point.\nPSI_s");
MakeNameEx(0x0001C89E, "XTCC_EXECUTION_KE_TCC_RELEASE_RAMP_RATE", nameFlags);
MakeRptCmt(0x0001C89E, "Ramp rate for Release mode.\nPSI/Sec");
MakeNameEx(0x0001C8A0, "XTCC_EXECUTION_KE_TCC_MAX_ALLOWED_PRESSURE", nameFlags);
MakeRptCmt(0x0001C8A0, "Maximum TCC pressure.\nPSI");
MakeNameEx(0x0001C8A2, "XTCC_EXECUTION_KA_TCC_MAXIMUM_CAPACITY", nameFlags);
MakeRptCmt(0x0001C8A2, "Sets maximum duty cycle for Control TCC Solenoids.\nCapacity");
MakeNameEx(0x0001C94C, "XTCC_EXECUTION_KV_TCC_MAXIMUM_PRESSURE", nameFlags);
MakeRptCmt(0x0001C94C, "Used to find TCC_PSI Pressure from Pressure.\nPSI");
MakeNameEx(0x0001C96E, "XTCC_EXECUTION_KA_TCC_MINIMUM_CAPACITY", nameFlags);
MakeRptCmt(0x0001C96E, "Used to find minimum duty cycle for Control TCC Solenoids.\nPercent");
MakeNameEx(0x0001CA18, "XTCC_EXECUTION_KV_TCC_ON_RATE_TRQ", nameFlags);
MakeRptCmt(0x0001CA18, "TCC On mode pressure ramp rate.\nPSI/Sec");
MakeNameEx(0x0001CA3A, "XTCC_EXECUTION_KV_COAST_PRESS_OP_PT", nameFlags);
MakeRptCmt(0x0001CA3A, "Used during Coast mode to set initial operating point.\nPSI_vs_RPM");
MakeNameEx(0x0001CA5C, "XTCC_EXECUTION_KE_TCC_LOW_SLIP_RATE_TRQ", nameFlags);
MakeNameEx(0x0001CA5E, "XTCC_EXECUTION_KE_ADAPT_COMPLETE_CONF", nameFlags);
MakeNameEx(0x0001CA60, "XTCC_EXECUTION_KE_ECCC_ANTI_LOCK_GAIN", nameFlags);
MakeRptCmt(0x0001CA60, "Used in determining changes in TCC_Ramp value when there is a significant ECCC engien torque increase over the previous loop.\nPSI/Ft_Lb");
MakeNameEx(0x0001CA62, "XTCC_EXECUTION_KE_ANTI_LOCK_TORQUE_STEP", nameFlags);
MakeRptCmt(0x0001CA62, "Used to determine if there is a significant increase or decrease in ECCC engine torque over the previous loop\nFt_Lb");
MakeNameEx(0x0001CA64, "XTCC_EXECUTION_KA_TCC_ADAPT_MEMBERSHIP", nameFlags);
MakeRptCmt(0x0001CA64, "Membership variable for each cell used as an index into KV_TCC_Adapt_Cell_Weight.\nFactor");
MakeNameEx(0x0001CA96, "XTCC_EXECUTION_KV_TCC_ADAPT_CELL_WEIGHT", nameFlags);
MakeRptCmt(0x0001CA96, "Adapt Cell Weight value used in the calculations of each of the TCC Adapt Cells.\nFactor");
MakeNameEx(0x0001CAA0, "XTCC_EXECUTION_KA_TCC_ADAPT_CONF_FACT_GAIN", nameFlags);
MakeRptCmt(0x0001CAA0, "Adapt confidence factor gain used in the calculations of each of the TCC Adapt Cells.\nFactor");
MakeNameEx(0x0001CAFA, "XTCC_EXECUTION_KE_TCC_ADAPT_DEADBAND", nameFlags);
MakeRptCmt(0x0001CAFA, "If the ECCC adapt modification value for a cell is BELOW this threshold, then no adapting is performed on that particular cell.\nPSI");
MakeNameEx(0x0001CAFC, "XTCC_EXECUTION_KE_TCC_ADAPT_MIN", nameFlags);
MakeRptCmt(0x0001CAFC, "Each individual adapt cell is limited to this minimum value.\nPSI");
MakeNameEx(0x0001CAFE, "XTCC_EXECUTION_KE_TCC_ADAPT_MAX", nameFlags);
MakeRptCmt(0x0001CAFE, "Each individual adapt cell is limited to this maximum value.\nPSI");
MakeNameEx(0x0001CB00, "XTCC_EXECUTION_KE_TCC_CONF_FACT_INC", nameFlags);
MakeRptCmt(0x0001CB00, "Percentage used in calculating the increased value for the neighboring cellswhen  updating TCC_Adapt_Conf_Factor cells\n%");
MakeNameEx(0x0001CB02, "XTCC_EXECUTION_KV_TCC_CONF_FACT_DEC", nameFlags);
MakeRptCmt(0x0001CB02, "Used in calculating the decreased value of the neighboring cells when updating TCC_Adapt_Conf_Factor cells.\n%");
MakeNameEx(0x0001CB0C, "XTCC_EXECUTION_KE_TCC_ADAPT_TEMP_LOW", nameFlags);
MakeNameEx(0x0001CB0D, "XTCC_EXECUTION_KE_TCC_ADAPT_TEMP_HIGH", nameFlags);
MakeNameEx(0x0001CB0E, "XTCC_EXECUTION_KE_TCC_ADAPT_SS_ADAPT_LOW", nameFlags);
MakeRptCmt(0x0001CB0E, "When the steady state adapts in the current mode is above this, the ECCC adapts are disabled.\nPSI");
MakeNameEx(0x0001CB10, "XTCC_EXECUTION_KE_TCC_ADAPT_TPS_LOW", nameFlags);
MakeRptCmt(0x0001CB10, "When throttle is below this value, the ECCC adapts are disabled.\n%");
MakeNameEx(0x0001CB12, "XTCC_EXECUTION_KE_TCC_ADAPT_TPS_HIGH", nameFlags);
MakeRptCmt(0x0001CB12, "When throttle is below this value, the ECCC adapts are disabled.\n%");
MakeNameEx(0x0001CB14, "XTCC_EXECUTION_KE_TCC_ADAPT_TORQUE_LOW", nameFlags);
MakeRptCmt(0x0001CB14, "ECCC adapts are disabled if ECCC engine torque is below this.\nFt_Lb");
MakeNameEx(0x0001CB16, "XTCC_EXECUTION_KE_TCC_ADAPT_TORQUE_HIGH", nameFlags);
MakeRptCmt(0x0001CB16, "ECCC adapts are disabled if ECCC engine torque is above this.\nFt_Lb");
MakeNameEx(0x0001CB18, "XTCC_EXECUTION_KE_TCC_ADAPT_VSPD_LOW", nameFlags);
MakeRptCmt(0x0001CB18, "ECCC adapts are disabled if MPH Output speed is below this.\nMPH");
MakeNameEx(0x0001CB1A, "XTCC_EXECUTION_KE_TCC_ADAPT_VSPD_HIGH", nameFlags);
MakeRptCmt(0x0001CB1A, "ECCC adapts are disabled if MPH Output speed is above this.\nMPH");
MakeNameEx(0x0001CB1C, "XTCC_EXECUTION_KE_TCC_ADAPT_UPDATE_TIME", nameFlags);
MakeRptCmt(0x0001CB1C, "Conditions must be valid for this long before ECCC adapts are allowed.\nSeconds");
MakeNameEx(0x0001CB1E, "XTCC_EXECUTION_KA_TCC_ADAPT_RANGE_GEAR", nameFlags);
MakeRptCmt(0x0001CB1E, "Enable ECCC adapts by Range and Gear.\nT/F");
MakeNameEx(0x0001CB2E, "XTCC_EXECUTION_KE_TCC_STABLE_RAMP_FILT", nameFlags);
MakeRptCmt(0x0001CB2E, "Filter coefficient used in determining TCC_On_Ramp_Avg.\nCoeff");
MakeNameEx(0x0001CB30, "XTCC_EXECUTION_KE_TCC_STABLE_TORQUE_FILT", nameFlags);
MakeRptCmt(0x0001CB30, "Filter coefficient used in determining TCC_Eng_Torque_Avg.\nCoeff");
MakeNameEx(0x0001CB32, "XTCC_EXECUTION_KE_TCC_STABLE_THROTTLE_FILT", nameFlags);
MakeRptCmt(0x0001CB32, "Filter coefficient used in determining TCC_Throttle_Avg.\nCoeff");
MakeNameEx(0x0001CB34, "XTCC_EXECUTION_KE_TCC_RAMP_STABILITY_LOW", nameFlags);
MakeRptCmt(0x0001CB34, "Reset ramp stability variables if Ramp_Stability is above this.\nPSI");
MakeNameEx(0x0001CB36, "XTCC_EXECUTION_KE_TCC_TORQUE_STABILITY_LOW", nameFlags);
MakeRptCmt(0x0001CB36, "Reset torque stability variables if Torque_Stability is above this.\nFt_Lb");
MakeNameEx(0x0001CB38, "XTCC_EXECUTION_KE_TCC_THROTTLE_STABILITY_LOW", nameFlags);
MakeRptCmt(0x0001CB38, "Reset throttle stability variables if Throttle_Stability is above this.\n%");
MakeNameEx(0x0001CB3A, "XTCC_EXECUTION_KE_TCC_SLIPERR_STABILITY_LOW", nameFlags);
MakeRptCmt(0x0001CB3A, "Reset TCC_Stability_Timer if abs ( slip_error ) is above this.\nRPM");
MakeNameEx(0x0001CB3C, "XTCC_EXECUTION_KE_TCC_STABLE_TIME", nameFlags);
MakeRptCmt(0x0001CB3C, "ECCC must be stable this long before updating ECCC adapts.\nSeconds");
MakeNameEx(0x0001CB3E, "XTCC_EXECUTION_KE_TCC_ADAPT_CONTROL", nameFlags);
MakeRptCmt(0x0001CB3E, "Select which ECCC adapt algorithms will run.\nENUM");
MakeNameEx(0x0001CB40, "XTCC_EXECUTION_KA_TCC_LESS_CONF_FACTOR", nameFlags);
MakeRptCmt(0x0001CB40, "Used in determining changes in TCC_Ramp value when there is a significant change in engine torque.\nFactor");
MakeNameEx(0x0001CB60, "XTCC_EXECUTION_KV_ECCC_POS_ANTI_LOCK_FACTOR", nameFlags);
MakeRptCmt(0x0001CB60, "Used in determining changes in TCC_Ramp value when there is a significant change in engine torque.\nFactor");
MakeNameEx(0x0001CB6A, "XTCC_EXECUTION_KV_ECCC_NEG_ANTI_LOCK_FACTOR", nameFlags);
MakeRptCmt(0x0001CB6A, "Used in determining changes in TCC_Ramp value when there is a significant change in engine torque.\nFactor");
MakeNameEx(0x0001CB74, "XTCC_EXECUTION_KV_NEG_TORQ_CONF_FACTOR", nameFlags);
MakeRptCmt(0x0001CB74, "Used in determining changes in TCC_Ramp value when there is a significant change in engine torque.\nFactor");
MakeNameEx(0x0001CB7E, "XTCC_EXECUTION_KV_TCC_APPLY_CONF_OFFSET", nameFlags);
MakeRptCmt(0x0001CB7E, "TCC Apply Confidence Factor based offset used in determining TCC_Apply_Init_Offset.\nPSI");
MakeNameEx(0x0001CB88, "XTCC_EXECUTION_KV_TCC_APPLY_TEMP_OFFSET", nameFlags);
MakeRptCmt(0x0001CB88, "TCC Apply Temperature based offset used in determining TCC_Apply_Init_Offset.\nPSI");
MakeNameEx(0x0001CB9A, "XTCC_EXECUTION_KA_TCC_APPLY_BASE_OFFSET_2", nameFlags);
MakeRptCmt(0x0001CB9A, "TCC Apply Base offset for 2nd gear used in determining TCC_Apply_Init_Offset.\nPSI");
MakeNameEx(0x0001CBF4, "XTCC_EXECUTION_KA_TCC_APPLY_BASE_OFFSET_3", nameFlags);
MakeRptCmt(0x0001CBF4, "TCC Apply Base offset for 3rd gear used in determining TCC_Apply_Init_Offset.\nPSI");
MakeNameEx(0x0001CC4E, "XTCC_EXECUTION_KA_TCC_APPLY_BASE_OFFSET_4", nameFlags);
MakeRptCmt(0x0001CC4E, "TCC Apply Base offset for 4th gear used in determining TCC_Apply_Init_Offset.\nPSI");
MakeNameEx(0x0001CCA8, "XTCC_EXECUTION_KE_TCC_TORQUE_STEP_OFFSET", nameFlags);
MakeRptCmt(0x0001CCA8, "Offset for the ECCC adapt and confidence factor cells.\nFt_Lb");
MakeNameEx(0x0001CCAA, "XTCC_EXECUTION_KE_TCC_TORQUE_STEP_SIZE", nameFlags);
MakeRptCmt(0x0001CCAA, "Spacing  value of the ECCC adapt and confidence factor cells.\nFt_Lb");
MakeNameEx(0x0001CCAC, "XTIM_ADAPT_KV_ADAPT_CELL_WEIGHT_FACTOR", nameFlags);
MakeRptCmt(0x0001CCAC, "Weighting factors for adaptive cells\nFactor");
MakeNameEx(0x0001CCB2, "XTIM_ADAPT_KV_LONG_SHIFT_TIME_ERROR", nameFlags);
MakeRptCmt(0x0001CCB2, "Shift time error to be considered as a long shift.\nSeconds");
MakeNameEx(0x0001CCB8, "XTIM_ADAPT_KA_PRESSURE_ADAPT_CELL_MODIFIER", nameFlags);
MakeRptCmt(0x0001CCB8, "Amount of pressure to add to adaptive cells.\nPSI_s");
MakeNameEx(0x0001CCEE, "XTIM_ADAPT_KV_LONG_SHIFT_ADAPTIVE_MODIFIER", nameFlags);
MakeRptCmt(0x0001CCEE, "Modifiers for long shifts adaption.\nPSI_s");
MakeNameEx(0x0001CCF2, "XTIM_ADAPT_KA_SHIFT_DELAY_BASE_CORRECTION", nameFlags);
MakeRptCmt(0x0001CCF2, "Long shift delay base correction used in calculatinglong delay adaptive modifier.\nPSI");
MakeNameEx(0x0001CD28, "XTIM_ADAPT_KA_SHIFT_DELAY_MULT_COEF", nameFlags);
MakeRptCmt(0x0001CD28, "Long shift delay multiplier used in calculating longdelay adaptive modifier.\nFactor");
MakeNameEx(0x0001CD46, "XTIM_ADAPT_KA_SHIFT_DELAY_LIMIT", nameFlags);
MakeRptCmt(0x0001CD46, "Long shift delay error limit used to determine whento calculate long delay adaptive modifier.\nSeconds");
MakeNameEx(0x0001CD7C, "XTIM_ADAPT_KE_SHIFT_DELAY_MOD_HYSTERESIS", nameFlags);
MakeRptCmt(0x0001CD7C, "This is the maximum long shift delay time allowedin using the long shift delay modifier.\nPSI");
MakeNameEx(0x0001CD7E, "XTIM_ADAPT_KE_FACTOR_MIN_TEMP_RISE", nameFlags);
MakeRptCmt(0x0001CD7E, "Low limit transmission temperature rise used to determineshift adapt factor due to temperature rise\nDegree C");
MakeNameEx(0x0001CD80, "XTIM_ADAPT_KE_FACTOR_TEMP_RISE", nameFlags);
MakeNameEx(0x0001CD82, "XTIM_ADAPT_KE_FACTOR_WARM_TEMP_A", nameFlags);
MakeRptCmt(0x0001CD82, "Lower limit transmission temperature in warm state for shiftadapt factor rising point A\nDegree C");
MakeNameEx(0x0001CD84, "XTIM_ADAPT_KE_FACTOR_WARM_TEMP_B", nameFlags);
MakeNameEx(0x0001CD86, "XTIM_ADAPT_KE_FACTOR_WARM_TEMP_C", nameFlags);
MakeNameEx(0x0001CD88, "XTIM_ADAPT_KE_FACTOR_WARM_TEMPERATURE", nameFlags);
MakeNameEx(0x0001CD8A, "XTIM_ADAPT_KE_FACTOR_TPS_1_MINUS_PERCENT", nameFlags);
MakeRptCmt(0x0001CD8A, "Limit shift throttle deviation for shift adapt factorfalling down\nFactor");
MakeNameEx(0x0001CD8B, "XTIM_ADAPT_KE_SHIFT_ADAPT_TEMP_RISE_WEIGHT", nameFlags);
MakeRptCmt(0x0001CD8B, "Weight factor for shift adapt factor due to transmissiontemperature rise\nFactor");
MakeNameEx(0x0001CD8C, "XTIM_ADAPT_KE_SHIFT_ADAPT_WARM_TEMP_WEIGHT", nameFlags);
MakeRptCmt(0x0001CD8C, "Weight factor for shift adapt factor due to transmissiontemperature in warm state\nFactor");
MakeNameEx(0x0001CD8E, "XTIM_ADAPT_KA_PRESSURE_ADAPT_TORQUE_FACTOR", nameFlags);
MakeRptCmt(0x0001CD8E, "Shift torque compensation factor.\nFactor");
MakeNameEx(0x0001CDC4, "XTIM_ADAPT_KE_ADAPTIVE_PRELOAD_CHECKSUM", nameFlags);
MakeRptCmt(0x0001CDC4, "Preload Checksum value for Shift Adaptive Cells.\nCardinal");
MakeNameEx(0x0001CDC6, "XTIM_ADAPT_KA_ADAPTIVE_CELL_PRELOADS", nameFlags);
MakeRptCmt(0x0001CDC6, "These define preloadable values for the Adaptive_Cells; There are 17 cells per shift.\nPSI_s");
MakeNameEx(0x0001CDFC, "XTIM_DOWNSHIFT_KE_DOWNSHIFT_DELAY_TIME_LIMIT", nameFlags);
MakeRptCmt(0x0001CDFC, "Maximum delay time period to wait for starting engine speed acceleration to be reached.\nSeconds");
MakeNameEx(0x0001CDFE, "XTIM_DOWNSHIFT_KV_DOWNSHIFT_TIME", nameFlags);
MakeRptCmt(0x0001CDFE, "Amount of time to apply downshift pressure modifiers.\nSeconds");
MakeNameEx(0x0001CE04, "XTIM_RATIO_KV_UPSHIFT_START_RATIO", nameFlags);
MakeRptCmt(0x0001CE04, "Ratio used to start timing the upshift time\nRatio");
MakeNameEx(0x0001CE0A, "XTIM_RATIO_KV_UPSHIFT_END_RATIO", nameFlags);
MakeRptCmt(0x0001CE0A, "Ratio used to determine if a new gear is reached\nRatio");
MakeNameEx(0x0001CE10, "XTIM_RATIO_KV_DOWNSHIFT_START_RATIO", nameFlags);
MakeRptCmt(0x0001CE10, "Ratio used to start timing the downshift time.\nRatio");
MakeNameEx(0x0001CE16, "XTIM_RATIO_KV_DOWNSHIFT_END_RATIO", nameFlags);
MakeRptCmt(0x0001CE16, "Ratio used to determine if a new gear is reached.\nRatio");
MakeNameEx(0x0001CE1C, "XTIM_RATIO_KV_DS_END_OF_SHIFT_TIME", nameFlags);
MakeRptCmt(0x0001CE1C, "Time used to determine if end of downshift reached.\nSeconds");
MakeNameEx(0x0001CE22, "XTIM_RATIO_KV_DOWNSHIFT_MAX_TIME", nameFlags);
MakeRptCmt(0x0001CE22, "End of downshift time. If exceeded, this timer will always end the current downshift.\nSeconds");
MakeNameEx(0x0001CE28, "XTIM_UPSHIFT_KV_UPSHIFT_MAX_TIME", nameFlags);
MakeNameEx(0x0001CE2E, "XTIM_UPSHIFT_KV_END_OF_SHIFT_TIME", nameFlags);
MakeRptCmt(0x0001CE2E, "The amount of time after shift complete is set until end of shift flag is set.\nSeconds");
MakeNameEx(0x0001CE34, "XTIM_VALIDATION_KV_THROTTLE_VARIATION_LIMIT", nameFlags);
MakeNameEx(0x0001CE3E, "XTIM_VALIDATION_KE_TRANSMISSION_TEMP_LOW_VALID", nameFlags);
MakeRptCmt(0x0001CE3E, "The lowest transmission temperature to be considered valid.\nDegrees_C");
MakeNameEx(0x0001CE40, "XTIM_VALIDATION_KE_TRANSMISSION_TEMP_HIGH_VALID", nameFlags);
MakeRptCmt(0x0001CE40, "The highest transmission temperature to be considered valid.\nDegrees_C");
MakeNameEx(0x0001CE42, "XTIM_VALIDATION_KV_WHEEL_SLIP_ACCEL_HI", nameFlags);
MakeRptCmt(0x0001CE42, "If wheel slipacceleration is greater than this cal then the wheel isslipping\nMPH/Sec");
MakeNameEx(0x0001CE48, "XTIM_VALIDATION_KV_WHEEL_SLIP_ACCEL_LO", nameFlags);
MakeRptCmt(0x0001CE48, "If wheel slipacceleration is less than this cal then the wheel isslipping\nMPH/Sec");
MakeNameEx(0x0001CE4E, "XTIM_VALIDATION_KV_ALLOWED_SHIFT_DELAY", nameFlags);
MakeNameEx(0x0001CE54, "XTIM_VALIDATION_KE_HOT_MODE_ADAPT_VALID", nameFlags);
MakeRptCmt(0x0001CE54, "Allow adapts when transmission is in hot mode if this is true.\nT/F");
MakeNameEx(0x0001CE55, "XTIM_VALIDATION_KE_INHIBIT_PERFORMANCE_ADAPT", nameFlags);
MakeRptCmt(0x0001CE55, "When TRUE, performance mode adapts are NOT allowed.\nTrue/False");
MakeNameEx(0x0001CE56, "XTIM_VALIDATION_KE_GEAR_CHANGE_TIME_VALID", nameFlags);
MakeRptCmt(0x0001CE56, "Time for between-gear change to be a valid Upshift.\nSeconds");
MakeNameEx(0x0001CE58, "XTIM_VALIDATION_KE_RANGE_CHANGE_TIME_VALID", nameFlags);
MakeRptCmt(0x0001CE58, "Time for between-range change to be a valid Upshift.\nSeconds");
MakeNameEx(0x0001CE5A, "XTIM_VALIDATION_KE_ADAPTIVE_TORQUE_LIMIT_LOW", nameFlags);
MakeRptCmt(0x0001CE5A, "The lower limit of shift torque for a shift to be considered valid.\nFt_lb");
MakeNameEx(0x0001CE5C, "XTIM_VALIDATION_KE_ADAPTIVE_TORQUE_LIMIT_HIGH", nameFlags);
MakeRptCmt(0x0001CE5C, "The upper limit of shift torque for a shift to be considered valid.\nFt_lb");
MakeNameEx(0x0001CE5E, "XTIM_VALIDATION_KV_THROTTLE_LOW_LIMIT_VALID", nameFlags);
MakeRptCmt(0x0001CE5E, "The lowest throttle position for an upshift to be considered valid.\nPercent");
MakeNameEx(0x0001CE64, "XTIM_VALIDATION_KV_VEHICLE_SPEED_VARIATION", nameFlags);
MakeRptCmt(0x0001CE64, "The maximum vehicle speed variation for an upshift to be considered valid.\nMPH");
MakeNameEx(0x0001CE6A, "XTIM_VALIDATION_KV_LONG_UPSHIFT_TIME", nameFlags);
MakeRptCmt(0x0001CE6A, "Actual shift time to be considered long.\nSeconds");
MakeNameEx(0x0001CE70, "XTIM_VALIDATION_KE_INITIAL_UPSHIFT_TIME", nameFlags);
MakeRptCmt(0x0001CE70, "The minimum time allowed before the ratio or engine acceleration reaches the starting point.\nSeconds");
MakeNameEx(0x0001CE72, "XTIM_VALIDATION_KV_SHORT_UPSHIFT_TIME", nameFlags);
MakeRptCmt(0x0001CE72, "Actual shift time to be considered short.\nSeconds");
MakeNameEx(0x0001CE78, "XTIM_VALIDATION_KA_ENABLE_UPSHIFT_ADAPT_TABLE", nameFlags);
MakeRptCmt(0x0001CE78, "This table indicates whether shift adapts are enabled for eachtype of shift, based on Gear and Range.\nBoolean");
MakeNameEx(0x0001CE84, "X_D32_CONTROL_KE_32_VEHICLE_SPEED", nameFlags);
MakeRptCmt(0x0001CE84, "Used to select adapt table and solenoid status at start of the 3-2 downshift.\nMPH");
MakeNameEx(0x0001CE86, "X_D32_CONTROL_KE_32_SOLENOID_TEMP", nameFlags);
MakeRptCmt(0x0001CE86, "Transmission temperature threshold FOR determining the 3-2 solenoid status.\nDegrees_C");
MakeNameEx(0x0001CE88, "X_D32_CONTROL_KE_D32_DIAGNOSTIC_MODE_PRESSURE", nameFlags);
MakeRptCmt(0x0001CE88, "Pressure modifier when Mode = Diagnostic.\nPSI");
MakeNameEx(0x0001CE8A, "X_D32_CONTROL_KE_D32_RANGE_MODE_PRESSURE", nameFlags);
MakeRptCmt(0x0001CE8A, "Pressure modifier when Mode = Range.\nPSI");
MakeNameEx(0x0001CE8C, "X_D32_CONTROL_KA_D32_LOW_SPEED_MAIN_PRESSURE", nameFlags);
MakeRptCmt(0x0001CE8C, "Used to determine the base 3-2 pressure when the 3-2 vehicle speed is less than the 3-2 vehicle speed check value.\nPSI");
MakeNameEx(0x0001CFBE, "X_D32_CONTROL_KA_D32_HIGH_SPEED_MAIN_PRESSURE", nameFlags);
MakeRptCmt(0x0001CFBE, "Used to determine the base 3-2 pressure when the 3-2 vehicle speed is greater than the 3-2 vehicle speed check value.\nPSI");
MakeNameEx(0x0001D0F0, "X_D32_CONTROL_KA_D32_LOW_SPD_ENG_SPD_MODIFIER", nameFlags);
MakeRptCmt(0x0001D0F0, "Used to modify 3-2 base pressure as a function of engine speed.\nPSI_s");
MakeNameEx(0x0001D160, "X_D32_CONTROL_KA_D32_HIGH_SPD_ENG_SPD_MODIFIER", nameFlags);
MakeRptCmt(0x0001D160, "Used to modify 3-2 base pressure as a function of engine speed.\nPSI_s");
MakeNameEx(0x0001D1D0, "X_D32_CONTROL_KV_D32_TRANS_TEMP_PRESS_MODIFIER", nameFlags);
MakeRptCmt(0x0001D1D0, "Used to determine 3-2 shift pressure modifications due to temperature.\nPSI_s");
MakeNameEx(0x0001D1E2, "X_D32_CONTROL_KE_32_COASTDOWN_SPEED", nameFlags);
MakeRptCmt(0x0001D1E2, "Vehicle speed condition for 3-2 downshift to coastdown mode.\nMPH");
MakeNameEx(0x0001D1E4, "X_D32_CONTROL_KE_32_COASTDOWN_THROTTLE", nameFlags);
MakeRptCmt(0x0001D1E4, "Throttle condition for 3-2 downshift to coastdown mode.\nPercent");
MakeNameEx(0x0001D1E6, "X_D32_CONTROL_KE_32_COASTDOWN_SOL_STATE", nameFlags);
MakeRptCmt(0x0001D1E6, "This calibration is used to determine the 3-2 solenoid state when it is in coastdown mode.\nENUM");
MakeNameEx(0x0001D1E8, "X_FM_CONTROL_KE_FM_CURRENT_OVER_LIMIT_TIME", nameFlags);
MakeRptCmt(0x0001D1E8, "Time in which force motor current is over range before the force motor is considered out of control.\nSeconds");
MakeNameEx(0x0001D1EA, "X_FM_CONTROL_KE_FM_CURRENT_UNDER_LIMIT_TIME", nameFlags);
MakeRptCmt(0x0001D1EA, "Time in which force motor current is under range before the force motor is considered out of control.\nSeconds");
MakeNameEx(0x0001D1EC, "X_FM_CONTROL_KE_FM_ENABLE_RETEST", nameFlags);
MakeRptCmt(0x0001D1EC, "When TRUE, will enable the Force Motor Retest Logic.\nT/F");
MakeNameEx(0x0001D1ED, "X_FM_CONTROL_KE_FM_HIGH_CURRENT_THRSH_GAIN", nameFlags);
MakeRptCmt(0x0001D1ED, "\nGain used when calculating the F");
MakeNameEx(0x0001D1EE, "X_FM_CONTROL_KE_FM_HIGH_CURRENT_THRSH_OFFSET", nameFlags);
MakeRptCmt(0x0001D1EE, "Offset used when calculating the Force Motor HIGH current threshold.\nAmps");
MakeNameEx(0x0001D1EF, "X_FM_CONTROL_KE_FM_HIGH_VOLT_THRSH_DISABLE", nameFlags);
MakeRptCmt(0x0001D1EF, "The high voltage threshold used in determining if ignition voltage is out of range.\nVolts");
MakeNameEx(0x0001D1F0, "X_FM_CONTROL_KE_FM_LOW_CURRENT_THRSH_GAIN", nameFlags);
MakeRptCmt(0x0001D1F0, "Gain used when calculating the Force Motor LOW current threshold.\nAmps");
MakeNameEx(0x0001D1F2, "X_FM_CONTROL_KE_FM_LOW_CURRENT_THRSH_OFFSET", nameFlags);
MakeRptCmt(0x0001D1F2, "Offset used when calculating the Force Motor LOW current threshold.\nAmps");
MakeNameEx(0x0001D1F4, "X_FM_CONTROL_KE_FM_LOW_VOLT_THRSH_DISABLE_HI", nameFlags);
MakeRptCmt(0x0001D1F4, "The HIGH value used in calculating the low voltage threshold used to determine if ignition voltage is out of range.\nVolts");
MakeNameEx(0x0001D1F5, "X_FM_CONTROL_KE_FM_LOW_VOLT_THRSH_DISABLE_LO", nameFlags);
MakeRptCmt(0x0001D1F5, "The LOW value used in calculating the low voltage threshold used to determine if ignition voltage is out of range.\nVolts");
MakeNameEx(0x0001D1F6, "X_FM_CONTROL_KE_FM_LOW_VOLT_THRSH_ENABLE_HI", nameFlags);
MakeRptCmt(0x0001D1F6, "The HIGH value used in calculating the low voltage threshold used to determine if ignition voltage is within range.\nVolts");
MakeNameEx(0x0001D1F7, "X_FM_CONTROL_KE_FM_LOW_VOLT_THRSH_ENABLE_LO", nameFlags);
MakeNameEx(0x0001D1F8, "X_FM_CONTROL_KE_FM_MAX_FAIL_IN_RETEST", nameFlags);
MakeRptCmt(0x0001D1F8, "This calibration defines the limit for the number of times that the force motor can fail while in the retest operating state.\nCounts");
MakeNameEx(0x0001D1FA, "X_FM_CONTROL_KE_FM_OFF_BEFORE_RETEST_TIME", nameFlags);
MakeNameEx(0x0001D1FC, "X_FM_CONTROL_KE_FM_VOLTAGE_LIMIT_TIME", nameFlags);
MakeNameEx(0x0001D1FE, "X_FM_CONTROL_KE_FM_MAX_TRANSITION_TO_RETEST", nameFlags);
MakeNameEx(0x0001D200, "X_FM_CONTROL_KE_FM_RETEST_PASS_TIME", nameFlags);
MakeNameEx(0x0001D202, "X_FM_CONTROL_KV_FORCE_MOTOR_GAIN_TABLE_1", nameFlags);
MakeRptCmt(0x0001D202, "Table 1 of force motor gains.\nGain");
MakeNameEx(0x0001D212, "X_FM_CONTROL_KV_FORCE_MOTOR_GAIN_TABLE_2", nameFlags);
MakeRptCmt(0x0001D212, "Table 2 of force motor gains.\nGain");
MakeNameEx(0x0001D222, "X_FM_CONTROL_KE_FM_RETEST_DESIRED_CURRENT", nameFlags);
MakeRptCmt(0x0001D222, "Desired Force Motor current in retest mode.\nAmps");
MakeNameEx(0x0001D223, "X_FM_CONTROL_KE_FM_FDBCK_CRTN_CURR_ENABLE", nameFlags);
MakeRptCmt(0x0001D223, "Above this value, full compensation applied.\nAmps");
MakeNameEx(0x0001D224, "X_FM_CONTROL_KE_FM_FDBCK_CRTN_CURR_DISABLE", nameFlags);
MakeRptCmt(0x0001D224, "Below this value, no compensation applied.\nAmps");
MakeNameEx(0x0001D225, "X_FM_CONTROL_KE_FM_CRTD_DSRD_CURR_LIMIT_MAX", nameFlags);
MakeRptCmt(0x0001D225, "Maximum value of corrected desired current.\nAmps");
MakeNameEx(0x0001D226, "X_FM_CONTROL_KE_FM_CRTD_DSRD_CURR_LIMIT_MIN", nameFlags);
MakeRptCmt(0x0001D226, "Minimum value of corrected desired current.\nAmps");
MakeNameEx(0x0001D228, "X_FM_CONTROL_KE_FM_FDBCK_CRTN_CURR_FAILSOFT", nameFlags);
MakeRptCmt(0x0001D228, "Value of FM ckt characterization offset incase of a checksum failure or other failsoftingcondition.\nAmps_s");
MakeNameEx(0x0001D22A, "X_FM_CONTROL_KA_FM_PRESSURE_TO_CURRENT", nameFlags);
MakeRptCmt(0x0001D22A, "FM current converted FROM pressure.\nAmps");
MakeNameEx(0x0001D35C, "X_INP_SPEED_KE_INPUT_SPEED_FILTER_COEFF", nameFlags);
MakeRptCmt(0x0001D35C, "Filter Coefficient for filtering input speed.\nCoeff");
MakeNameEx(0x0001D35E, "X_INP_SPEED_KE_INPUT_SPEED_KALMAN_GAIN_1", nameFlags);
MakeRptCmt(0x0001D35E, "This is a gain used in the Kalman Filter routine, and isassociated with plant speed noise\nGain");
MakeNameEx(0x0001D360, "X_INP_SPEED_KE_INPUT_SPEED_KALMAN_GAIN_2", nameFlags);
MakeRptCmt(0x0001D360, "This is a gain used in the Kalman Filter routine, and isassociated with plant acceleration noise\nGain");
MakeNameEx(0x0001D362, "X_INP_SPEED_KE_INPUT_SPEED_KALMAN_GAIN_3", nameFlags);
MakeRptCmt(0x0001D362, "This is a gain used in the Kalman Filter routine, and isassociated with plant jerk noise\nGain");
MakeNameEx(0x0001D364, "X_LIBRARY_KV_ALTITUDE_FACTOR", nameFlags);
MakeRptCmt(0x0001D364, "Shift point altitude compensation gain factor\nFactor 0-1");
MakeNameEx(0x0001D36A, "X_LOOKUP_PROCEDURES_KE_SHIFT_TORQUE_STEP_SIZE", nameFlags);
MakeRptCmt(0x0001D36A, "This calibration is used to determine the range and step size of tables that have shift torque as the independant variable.\nFt_lb");
MakeNameEx(0x0001D36C, "X_OVERRIDES_KE_C2_SHIFT_ENG_SPEED_ALLOWABLE", nameFlags);
MakeRptCmt(0x0001D36C, "The limit of engine speed for a Class II gear shift\nRPM");
MakeNameEx(0x0001D36E, "X_OVERRIDES_KE_C2_SHIFT_MPH_SPEED_ALLOWABLE", nameFlags);
MakeRptCmt(0x0001D36E, "The limit of vehicle speed for a Class II gear shift\nMPH");
MakeNameEx(0x0001D370, "X_OVERRIDES_KE_C2_32_DOWN_SPEED_ALLOWABLE", nameFlags);
MakeRptCmt(0x0001D370, "The limit of vehicle speed for a Class II 32 downshift\nMPH");
MakeNameEx(0x0001D372, "X_OVERRIDES_KE_C2_21_DOWN_SPEED_ALLOWABLE", nameFlags);
MakeRptCmt(0x0001D372, "The limit of vehicle speed for a Class II 21 downshift\nMPH");
MakeNameEx(0x0001D374, "X_OVERRIDES_KE_C2_FM_ENG_LIMIT", nameFlags);
MakeRptCmt(0x0001D374, "The limit of engine speed for a Class II force motor\nRPM");
MakeNameEx(0x0001D376, "X_OVERRIDES_KE_C2_FM_OVERRIDE_HI_LIMIT", nameFlags);
MakeRptCmt(0x0001D376, "The high threshold of Force Motor current for theClass II Device Control Limits\nAmps");
MakeNameEx(0x0001D377, "X_OVERRIDES_KE_C2_FM_OVERRIDE_LO_LIMIT", nameFlags);
MakeRptCmt(0x0001D377, "The low threshold of Force Motor current for theClass II Device Control Limits\nAmps");
MakeNameEx(0x0001D378, "X_OVERRIDES_KE_C2_TCC_OVERRIDE_OFF_TIME", nameFlags);
MakeRptCmt(0x0001D378, "The limit amount of time that TCC can be commanded OFFwhen using the Class II Device\nSeconds");
MakeNameEx(0x0001D37A, "X_PRESSURE_KE_FIRST_SHIFT_COLD_ENABLED", nameFlags);
MakeRptCmt(0x0001D37A, "This ca;ibration is used to enable First Cold Garage Pressure and Base Upshift Pressure Logic.\nT/F");
MakeNameEx(0x0001D37B, "X_PRESSURE_KE_FIRST_SHIFT_COLD_DELTA_1", nameFlags);
MakeRptCmt(0x0001D37B, "Temperature below which First Upshift Cold is indicated.\nDeg_C");
MakeNameEx(0x0001D37C, "X_PRESSURE_KE_FIRST_SHIFT_COLD_DELTA_2", nameFlags);
MakeRptCmt(0x0001D37C, "Temperature below which First Upshift Cold is indicated.\nDeg_C");
MakeNameEx(0x0001D37E, "X_PRESSURE_KE_PRESSURE_OFFSET_MALF", nameFlags);
MakeRptCmt(0x0001D37E, "Offset added to Pressure when Torque PressureOffset Malf present.\nPSI_S");
MakeNameEx(0x0001D380, "X_PRESSURE_KA_LUBE_PRESSURE", nameFlags);
MakeRptCmt(0x0001D380, "Lube pressure based on the gear and output speed.\nPSI");
MakeNameEx(0x0001D3C8, "X_PRESSURE_KE_UPSHFT_VS_SS_PRES_OFFSET", nameFlags);
MakeNameEx(0x0001D3CA, "X_PRESSURE_KE_DNSHFT_VS_SS_PRES_OFFSET", nameFlags);
MakeNameEx(0x0001D3CC, "X_PRESSURE_KV_DNSHFT_VS_BRAKING_PRES_OFFSET", nameFlags);
MakeNameEx(0x0001D3D4, "X_PRESSURE_KV_UPSHFT_VS_BRAKING_PRES_OFFSET", nameFlags);
MakeNameEx(0x0001D3DC, "X_PRESSURE_KE_BRAKING_VS_SS_PRES_OFFSET", nameFlags);
MakeNameEx(0x0001D3DE, "X_PRESSURE_KE_GS_PRESSURE_DIFFERENCE", nameFlags);
MakeNameEx(0x0001D3E0, "X_RATIO_KV_UPSHIFT_DELAY_TIME_MIN", nameFlags);
MakeRptCmt(0x0001D3E0, "Minimum time allowed fro shift delay. If Time_Since_Shift _Init is greater than this, shift_State is set to  shifting.\nSeconds");
MakeNameEx(0x0001D3E6, "X_RATIO_KE_USE_ACTUAL_ENGINE_TORQUE", nameFlags);
MakeRptCmt(0x0001D3E6, "IF true, set MRatio_Engine_Torque to Actual_Engine_Torque, otherwise, set to Unmanaged_Engine_Out_Torque.\nT/F");
MakeNameEx(0x0001D3E8, "X_RATIO_KE_MRATIO_ENG_TORQ_FILTER_COEFF", nameFlags);
MakeRptCmt(0x0001D3E8, "Filter coefficient for filtering MRatio_Engine_Torque.\nCoeff");
MakeNameEx(0x0001D3EA, "X_RATIO_KE_TCC_PRESSURE_FILTER_COEFF", nameFlags);
MakeRptCmt(0x0001D3EA, "Filter coefficient for filtering calculated TCC Pressure.\nCoeff");
MakeNameEx(0x0001D3EC, "X_RATIO_KE_MRATIO_SLIP_FILTER_COEFF", nameFlags);
MakeRptCmt(0x0001D3EC, "Filter coefficient for filtering calculated TCC slip.\nCoeff");
MakeNameEx(0x0001D3EE, "X_RATIO_KE_RATIO_ERROR_FILTER_COEFF", nameFlags);
MakeRptCmt(0x0001D3EE, "Filter coefficient for filtering ratio error.\nCoeff");
MakeNameEx(0x0001D3F0, "X_RATIO_KE_ENG_INERTIA", nameFlags);
MakeRptCmt(0x0001D3F0, "Moment of inertia for calculating Inertia Torque.\nKg-m-m");
MakeNameEx(0x0001D3F2, "X_RATIO_KE_TCC_OFFSET", nameFlags);
MakeRptCmt(0x0001D3F2, "Pressure offset subtracted from filtered TCC Pressure.\nPSI");
MakeNameEx(0x0001D3F4, "X_RATIO_KE_TCC_GAIN", nameFlags);
MakeRptCmt(0x0001D3F4, "Gain multiplied with filtered TCC Pressure minus offset to yield TCC Torque.\nFtlb/PSI");
MakeNameEx(0x0001D3F6, "X_RATIO_KE_KFACT_E_TORQUE_HI", nameFlags);
MakeRptCmt(0x0001D3F6, "Calibration above which K Factor Torque Compensation is set to zero.\nFtlb");
MakeNameEx(0x0001D3F8, "X_RATIO_KE_KFACT_E_TORQUE_LO", nameFlags);
MakeRptCmt(0x0001D3F8, "Calibration below which K Factor Torque Compensation is set to KE_KFact_Offset_At_Lo_Torq.\nFtlb");
MakeNameEx(0x0001D3FA, "X_RATIO_KE_KFACT_OFFSET_AT_LO_TORQ", nameFlags);
MakeRptCmt(0x0001D3FA, "K Factor Torque Compensation when MRatio_Engine_Torque is less than a calibration.\nRPM/SQRTNM");
MakeNameEx(0x0001D3FC, "X_RATIO_KE_TEMP_COMP_AT_MINUS_40", nameFlags);
MakeRptCmt(0x0001D3FC, "K Factor Temperature Compensation at minus 40 degrees.\nRPM/SQRTNM");
MakeNameEx(0x0001D3FE, "X_RATIO_KE_TEMP_COMP_START", nameFlags);
MakeRptCmt(0x0001D3FE, "Transmission Temperature above which K Factor Temperature compensation returns to zero.\nDegrees_C");
MakeNameEx(0x0001D400, "X_RATIO_KE_SQRT_STEP", nameFlags);
MakeRptCmt(0x0001D400, "Used to determine the step size of KV_Sqrt_Torque Table\nN_Meter");
MakeNameEx(0x0001D402, "X_RATIO_KV_SQRT_TORQUE", nameFlags);
MakeRptCmt(0x0001D402, "Square root of torque (in Newton-meters) used in the calculation for K_Factor_wo_Compensation.\nSQRT_N_Meter");
MakeNameEx(0x0001D424, "X_RATIO_KE_ADAPT_AT_OR_ABOVE_GEAR", nameFlags);
MakeRptCmt(0x0001D424, "Gear below which adapt of K_Factor is disabled.\nGear");
MakeNameEx(0x0001D426, "X_RATIO_KE_ADAPT_HI_TORQUE", nameFlags);
MakeRptCmt(0x0001D426, "MRatio_Engine_Torque above which adapt of the K_Factor is disabled.\nFtlb");
MakeNameEx(0x0001D428, "X_RATIO_KE_ADAPT_LO_TORQUE", nameFlags);
MakeRptCmt(0x0001D428, "MRatio_Engine_Torque below which adapt of the K_Factor is disabled.\nFtlb");
MakeNameEx(0x0001D42A, "X_RATIO_KE_ADAPT_MIN_S_RATIO", nameFlags);
MakeRptCmt(0x0001D42A, "Speed Ratio below which adapt of the K_Factor is disabled.\nFactor_0_To_2");
MakeNameEx(0x0001D42C, "X_RATIO_KE_ADAPT_MIN_TRANS_TEMP", nameFlags);
MakeRptCmt(0x0001D42C, "Transmission Temperature below which adapt of the K_Factor is disabled.\nDegrees_C");
MakeNameEx(0x0001D42E, "X_RATIO_KE_ADAPT_RATIO_LOW_MULT", nameFlags);
MakeRptCmt(0x0001D42E, "The Adapt_Time_Counter is decremented when modeled ratio is less than Ratio multiplied by this calibration.\nFactor_0_T0_2");
MakeNameEx(0x0001D42F, "X_RATIO_KE_ADAPT_RATIO_HIGH_MULT", nameFlags);
MakeRptCmt(0x0001D42F, "The Adapt_Time_Counter is incremented when modeled ratio is greater than Ratio multiplied by this calibration.\nFactor_0_To_2");
MakeNameEx(0x0001D430, "X_RATIO_KE_ADAPT_TIME_COUNTER", nameFlags);
MakeNameEx(0x0001D432, "X_RATIO_KE_ADAPT_LIMIT", nameFlags);
MakeRptCmt(0x0001D432, "The Adapt_K_Factor is limited to this value.\nRPM/SQRTNM");
MakeNameEx(0x0001D434, "X_RATIO_KE_ADAPT_RANGE", nameFlags);
MakeNameEx(0x0001D436, "X_RATIO_KE_COUPLING_KFACT_OR_ABV", nameFlags);
MakeNameEx(0x0001D438, "X_RATIO_KE_KFACT_STEP", nameFlags);
MakeRptCmt(0x0001D438, "Used to determine the step size of KV_Trq_Cnv_SRatio Table.\nRPM/SQRTNM");
MakeNameEx(0x0001D43A, "X_RATIO_KV_TRQ_CNV_SRATIO", nameFlags);
MakeRptCmt(0x0001D43A, "This calibration is used in the calculation of Speed Ratio.\nFactor_0_To_2");
MakeNameEx(0x0001D44C, "X_RATIO_KE_SNGLE_CAL_COUPLING_APPROX", nameFlags);
MakeNameEx(0x0001D44E, "X_SEM_KE_SEM_NO_REDUCTION", nameFlags);
MakeRptCmt(0x0001D44E, "Amount of total torque reduction requested if no reductionis desired. Should probably always be 0.0\nPercent");
MakeNameEx(0x0001D450, "X_SHIFT_KE_VEHICLE_SPEED_RATIO", nameFlags);
MakeRptCmt(0x0001D450, "Output_Speed / Vehicle_Speed Ratio.\n60 RPMI");
MakeNameEx(0x0001D452, "X_SHIFT_KV_MAX_GEAR_TABLE", nameFlags);
MakeRptCmt(0x0001D452, "Maximum allowable gear based of range selector.\nGear");
MakeNameEx(0x0001D456, "X_SHIFT_KE_SHIFT_CAUSED_BY_RANGE_TIME", nameFlags);
MakeRptCmt(0x0001D456, "Time used to determine a shift caused be a range change.\nSeconds");
MakeNameEx(0x0001D458, "X_SHIFT_KE_URBAN_ABOVE_MPH", nameFlags);
MakeRptCmt(0x0001D458, "This calibration disables urban conditions if you are above this cal for KE_Urban_Above_MPH_Time.\nMPH");
MakeNameEx(0x0001D45A, "X_SHIFT_KE_URBAN_ABOVE_MPH_TIME", nameFlags);
MakeRptCmt(0x0001D45A, "This calibration is used to disable the Urban Pattern if time has expired.\nSecs");
MakeNameEx(0x0001D45C, "X_SHIFT_KE_URBAN_BARO", nameFlags);
MakeNameEx(0x0001D45D, "X_SHIFT_KE_URBAN_COOLANT_TEMP", nameFlags);
MakeNameEx(0x0001D45E, "X_SHIFT_KE_URBAN_HI_TIME", nameFlags);
MakeNameEx(0x0001D460, "X_SHIFT_KE_URBAN_LO_TIME", nameFlags);
MakeNameEx(0x0001D462, "X_SHIFT_KE_URBAN_MPH_HIGH", nameFlags);
MakeRptCmt(0x0001D462, "This calibration is used as an upper bound for the range that vehicle speed must be in to meet a condition for the urban tests.\nMPH");
MakeNameEx(0x0001D464, "X_SHIFT_KE_URBAN_MPH_LOW", nameFlags);
MakeRptCmt(0x0001D464, "This calibration is used as a lower bound for the range that vehicle speed must be in to meet a condition for the urban tests.\nMPH");
MakeNameEx(0x0001D466, "X_SHIFT_KE_DISABLE_URBAN_DUE_TO_4WD_LO", nameFlags);
MakeNameEx(0x0001D467, "X_SHIFT_KE_DISABLE_URBAN_DUE_TO_CRUISE", nameFlags);
MakeNameEx(0x0001D468, "X_SHIFT_KE_URBAN_ENG_BRAKE_MPH", nameFlags);
MakeRptCmt(0x0001D468, "This is the threshold which Urban_Vehicle_Speed must be greater than in order to satisfy urban engine braking conditions.\nMPH");
MakeNameEx(0x0001D46A, "X_SHIFT_KE_URBAN_ENG_BRAKE_THR", nameFlags);
MakeNameEx(0x0001D46C, "X_SHIFT_KE_URBAN_ENG_BRAKE_TIME", nameFlags);
MakeRptCmt(0x0001D46C, "This specifies how long the vehicle must be in urban engine braking conditions before exiting urban conditions.\nSecs");
MakeNameEx(0x0001D46E, "X_SHIFT_KE_DRIVE_LOW_URBAN_TEST_ENABLE", nameFlags);
MakeNameEx(0x0001D470, "X_SHIFT_KE_URBAN_THROTTLE", nameFlags);
MakeRptCmt(0x0001D470, "If throttle is greater than this cal and Urban conditions are met we want to delay downshift to reduce noise emmisions.\n%");
MakeNameEx(0x0001D472, "X_SHIFT_KE_VEH_ACCELERATION_FILTER_COEFF", nameFlags);
MakeRptCmt(0x0001D472, "Lag filter coefficient for filtering vehicle acceleration.\nCoeff");
MakeNameEx(0x0001D474, "X_SHIFT_KE_WHEEL_SLIP_FILTER_COEFF", nameFlags);
MakeRptCmt(0x0001D474, "The filter coefficient for filtering the wheel slip acceleration\nNone");
MakeNameEx(0x0001D476, "X_SHIFT_KV_DELAY_DOWNSHIFT_TIMER", nameFlags);
MakeRptCmt(0x0001D476, "Amount of time to delay downshift when noise cond. met.\nSeconds");
MakeNameEx(0x0001D47C, "X_SHIFT_KV_SHIFT_STABLE_OVERALL_RATIO", nameFlags);
MakeNameEx(0x0001D484, "X_SHIFT_KV_TRQ_CONV_K_FACTOR", nameFlags);
MakeRptCmt(0x0001D484, "Used to calculate the current torque converter K factor.\nKFactor");
MakeNameEx(0x0001D4A6, "X_SHIFT_KV_UPSHIFT_K_FACTOR_RATIO", nameFlags);
MakeRptCmt(0x0001D4A6, "Used to calculate predicted ( after upshift ) torque converter K factor from the current K factor.\nRatio");
MakeNameEx(0x0001D4AA, "X_SHIFT_KV_PRED_TRQ_CONV_SPD_RATIO", nameFlags);
MakeRptCmt(0x0001D4AA, "Used to calculate the predicted torque converter speed ratio.\nRatio");
MakeNameEx(0x0001D4CC, "X_SHIFT_KV_DS_SOLENOID_DELAY_TIME", nameFlags);
MakeRptCmt(0x0001D4CC, "The amount of time to delay the state change of the shift solenoidfor downshift.\nSeconds");
MakeNameEx(0x0001D4D0, "X_SHIFT_KV_DS_JUMP_SOLENOID_DELAY_TIME", nameFlags);
MakeRptCmt(0x0001D4D0, "The amount of time to delay the state change of the shift solenoidfor a jump downshift.\nSeconds");
MakeNameEx(0x0001D4D2, "X_SHIFT_KV_URBAN_TEST_ENABLED", nameFlags);
MakeRptCmt(0x0001D4D2, "This is a calibration table based on Range which will enable the urban test for the specified PRNDL Range.\nT/F");
MakeNameEx(0x0001D4D6, "X_SHIFT_KV_STABIL_DISABLE_VEH_ACCEL_HI", nameFlags);
MakeRptCmt(0x0001D4D6, "If Vehicle acceleration is grater than this cal then shift stabilization is disabled.\nMPH_per_Second_S");
MakeNameEx(0x0001D4DE, "X_SHIFT_KV_STABIL_DISABLE_VEH_ACCEL_LO", nameFlags);
MakeRptCmt(0x0001D4DE, "If Vehicle acceleration is less than this cal then shift stabilization is enabled.\nMPH_per_Second_S");
MakeNameEx(0x0001D4E6, "X_SHIFT_KA_SHIFT_STABLE_ENG_TORQUE", nameFlags);
MakeRptCmt(0x0001D4E6, "Used to calculate normalized engine torque for the shift stabilization algorithm.\nNorm Torque");
MakeNameEx(0x0001D728, "X_SHIFT_KE_LIFT_FOOT_TIME", nameFlags);
MakeRptCmt(0x0001D728, "Time to inhibit upshift once power off inhibiting is triggered.\nseconds");
MakeNameEx(0x0001D72A, "X_SHIFT_KE_POWER_ON_THROTTLE", nameFlags);
MakeRptCmt(0x0001D72A, "The rate of change in throttle which is considered apower-on manuver.\n%/sec");
MakeNameEx(0x0001D72C, "X_SHIFT_KE_SHIFT_STAB_DELTHR_LFTFT", nameFlags);
MakeRptCmt(0x0001D72C, "Threshold of rate of change of throttle to trigger power offshift stabilization.\n%/sec");
MakeNameEx(0x0001D72E, "X_SHIFT_KE_SHIFT_STAB_POWER_ON_TIME", nameFlags);
MakeRptCmt(0x0001D72E, "The time to freeze the power-off vehicle torque modifier duringa power-on manuever.\nSeconds");
MakeNameEx(0x0001D730, "X_SHIFT_KE_VEHICLE_ACCELERATING_MAX", nameFlags);
MakeRptCmt(0x0001D730, "Maximum acceleration defining steady state within shiftstabilization power off routine.\nMPH/Sec");
MakeNameEx(0x0001D732, "X_SHIFT_KE_VEHICLE_ACCELERATING_MIN", nameFlags);
MakeRptCmt(0x0001D732, "Minimum acceleration defining steady state within shiftstabilization power off routine.\nMPH/Sec");
MakeNameEx(0x0001D734, "X_SHIFT_KE_SHIFT_STAB_UPSHF_DELAY_TIME", nameFlags);
MakeNameEx(0x0001D736, "X_SHIFT_KV_PRED_BASE_NORM_VEH_TORQUE", nameFlags);
MakeRptCmt(0x0001D736, "Normalized Tractive Effort on a level road table used in theShift Stabilization power off rountine.\nNone");
MakeNameEx(0x0001D758, "X_SHIFT_KV_VEH_TORQ_MOD_ERR_TABLE", nameFlags);
MakeNameEx(0x0001D79C, "X_SHIFT_KE_VEH_TORQ_ERR_FILTCOEF", nameFlags);
MakeRptCmt(0x0001D79C, "Lag filter weighting used for Vehicle_Torque_Error used withinthe power off shift stabilization power off routine.\nNONE");
MakeNameEx(0x0001D79E, "X_SHIFT_KE_32_23_SOL_DELAY_TIME", nameFlags);
MakeRptCmt(0x0001D79E, "Threshold delay time for the solenoid state change for 2-3 upshift after 3-2 downshift.\nSeconds");
MakeNameEx(0x0001D7A0, "X_SHIFT_KE_32_23_HIGH_TIME", nameFlags);
MakeRptCmt(0x0001D7A0, "If time since 3-2 downshift is greater than this, the 2-3 shift should not be delayed.\nSeconds");
MakeNameEx(0x0001D7A2, "X_SHIFT_KE_32_23_LOW_TIME", nameFlags);
MakeRptCmt(0x0001D7A2, "If time since 3-2 downshift is less than this, the 2-3 shift should not be delayed.\nSeconds");
MakeNameEx(0x0001D7A4, "X_SHIFT_KE_32_23_SOLENOID_DELAY_ENABLE", nameFlags);
MakeRptCmt(0x0001D7A4, "2-3 upshift solenoid state change delay is active after a 2-3 upshift.\nT/F");
MakeNameEx(0x0001D7A6, "X_SHIFT_KV_ETC_STAB_DISABLED_MIN_GEAR", nameFlags);
MakeRptCmt(0x0001D7A6, "Minimum gear that when manually selected disables the ETC shift stability algorithm.\nGear");
MakeNameEx(0x0001D7AA, "X_SHIFT_KV_ETC_STAB_OFFSET_TEMP_SCALAR", nameFlags);
MakeRptCmt(0x0001D7AA, "Amount to scale the gear offset by as a function of temperature.\nFactor");
MakeNameEx(0x0001D7CA, "X_SHIFT_KE_ETC_STAB_1ST_GEAR_OFFSET", nameFlags);
MakeRptCmt(0x0001D7CA, "First gear offset used to calculate the target maximum engine speed in the ETC shift stabilization algorithm.\nRPM");
MakeNameEx(0x0001D7CC, "X_SHIFT_KE_ETC_STAB_2ND_GEAR_OFFSET", nameFlags);
MakeRptCmt(0x0001D7CC, "Second gear offset used to calculate the target maximum engine speed in the ETC shift stabilization algorithm.\nRPM");
MakeNameEx(0x0001D7CE, "X_SHIFT_KE_ETC_STAB_3RD_GEAR_OFFSET", nameFlags);
MakeRptCmt(0x0001D7CE, "Third gear offset used to calculate the target maximum engine speed in the ETC shift stabilization algorithm.\nRPM");
MakeNameEx(0x0001D7D0, "X_SHIFT_KE_ETC_STAB_JUMP_DOWN_THRESHOLD", nameFlags);
MakeRptCmt(0x0001D7D0, "Threshold for the difference between actual and target engine speed that causes the target to jump down.\nRPM");
MakeNameEx(0x0001D7D2, "X_SHIFT_KE_ETC_STAB_RPM_DECREASE_RATE", nameFlags);
MakeRptCmt(0x0001D7D2, "Rate at which the engine speed limit is ramped down.\nRPM/Sec");
MakeNameEx(0x0001D7D4, "X_SHIFT_KE_ETC_STAB_RPM_INCREASE_RATE", nameFlags);
MakeRptCmt(0x0001D7D4, "Rate at which the engine speed limit is ramped up.\nRPM/Sec");
MakeNameEx(0x0001D7D6, "X_SHIFT_KE_ETC_STAB_JUMP_UP_THRESHOLD", nameFlags);
MakeRptCmt(0x0001D7D6, "Threshold for the difference between actual and target engine speed that causes the target to jump up.\nRPM");
MakeNameEx(0x0001D7D8, "X_SHIFT_KE_ETC_STAB_ENABLE", nameFlags);
MakeRptCmt(0x0001D7D8, "Boolean calibration to show if the ETC shift stabilization is enabled or disabled.\nT/F");
MakeNameEx(0x0001D7D9, "X_SHIFT_KE_ETC_SHIFT_STAB_ONCE_PER_GEAR", nameFlags);
MakeRptCmt(0x0001D7D9, "Boolean calibration to show whether to reactivate ETC Shift Stabilization.  When FALSE, ETC Stabilization can be reactivated.\nT/F");
MakeNameEx(0x0001D7DA, "X_SHIFT_KV_DETENT_RPM_POINT_ENABLE", nameFlags);
MakeRptCmt(0x0001D7DA, "This is a calibration table to enable or disable detent shiftstabilization.\nT/F");
MakeNameEx(0x0001D7DE, "X_TIMING_KE_POSITIVE_DELTA_SHIFT_THROTTLE", nameFlags);
MakeRptCmt(0x0001D7DE, "Used to detect an increase in throttleby a specific amount.\nPercent");
MakeNameEx(0x0001D7E0, "X_TIMING_KE_NEGATIVE_DELTA_SHIFT_THROTTLE", nameFlags);
MakeRptCmt(0x0001D7E0, "Used to detect an increase in throttleby a specific amount.\nPercent");
MakeNameEx(0x0001D7E2, "X_TIMING_KE_MINIMUM_SHIFT_THROTTLE", nameFlags);
MakeRptCmt(0x0001D7E2, "Used to detect when a minimum threshold              throttle has been exceeded.\nPercent");
MakeNameEx(0x0001D7E4, "X_TIMING_KE_SHIFT_LIFTFOOT_THROTTLE", nameFlags);
MakeRptCmt(0x0001D7E4, "Used to detect when a liftfoot throttle condition has taken place.\nPercent");
MakeNameEx(0x0001D7E6, "X_TIMING_KA_INERTIA_TORQUE", nameFlags);
MakeRptCmt(0x0001D7E6, "Used to find Inertia_Torque\nFt-lb");
MakeNameEx(0x0001D84C, "X_TIMING_KE_FRZ_SHFTTRQ_MAN_DNSHFT_TRQMNT", nameFlags);
MakeRptCmt(0x0001D84C, "Enable/disable manual downshift inertia torque management.\nT/F");
MakeNameEx(0x0001D84E, "XOIL_LIFE_KE_TRANS_OIL_LIFE_TIME_TO_TEST", nameFlags);
MakeRptCmt(0x0001D84E, "Sampling period oftransmission oil temperature for transmission oil life.\nSeconds");
MakeNameEx(0x0001D850, "XOIL_LIFE_KV_TRANS_OIL_LIFE_COUNTER", nameFlags);
MakeRptCmt(0x0001D850, "Counts to add to oil life counter based on transmission oil temperature.\nSeconds");
MakeNameEx(0x0001D870, "XOIL_LIFE_KE_TRANS_OIL_LIFE_TIME_TO_CHANGE", nameFlags);
MakeRptCmt(0x0001D870, "Low threshold value of transmission oil life remaining.\n%");
MakeNameEx(0x0001D872, "XOIL_LIFE_KE_TRANS_OIL_LIFE_EXPECTANCY", nameFlags);
MakeRptCmt(0x0001D872, "Transmission oil life expectancy.\nCounts");
MakeNameEx(0x0001D876, "XOIL_LIFE_KE_TRANS_OIL_LIFE_UPON_RESET", nameFlags);
MakeRptCmt(0x0001D876, "Default transmission oil life expectancy upon EEPROM reset.\n%");
MakeNameEx(0x0001D8B0, "TRAN_DIAGNOSTICS_HEADER", nameFlags);
MakeRptCmt(0x0001D8B0, "Use this cal to identify the Transmission Diag calibration\nCal_ID_Record");
MakeNameEx(0x0001D8CC, "T_DG_TYPES_KV_DIAGNOSTIC_TEST_ENABLED", nameFlags);
MakeRptCmt(0x0001D8CC, "This parameter defines which diagnostics are enabled\nBOOLEAN");
MakeNameEx(0x0001D8F2, "T_DG_TYPES_KV_FREEZE_ECCC_ADAPT_MALF", nameFlags);
MakeRptCmt(0x0001D8F2, "Diagnostic faults which will cause the ECCC adapts to be frozen.\nTrue/False");
MakeNameEx(0x0001D934, "T_DG_TYPES_KV_DIAGNOSTIC_ACTION_ENABLED", nameFlags);
MakeRptCmt(0x0001D934, "This parameter defines which action for the corresponding diagnostic faults are enabled.\nBOOLEAN");
MakeNameEx(0x0001D976, "T_DG_TYPES_KV_FAULT_DIAGNOSTIC_RECOVER_INFO", nameFlags);
MakeRptCmt(0x0001D976, "This parameter defines which diagnostic tests are Fault_Active or Fault_Active_This_Key_On.\nF_A/This_Key_On");
MakeNameEx(0x0001D9AC, "T_DG_TYPES_KV_SPEED_LIMIT_DEFAULT_GEAR_MALF", nameFlags);
MakeRptCmt(0x0001D9AC, "Dianostic faults which will cause thedefault gear action to occur\nBOOLEAN");
MakeNameEx(0x0001D9EE, "T_DG_TYPES_KV_SPEED_LIMIT_SOFT_LANDING_MALF", nameFlags);
MakeRptCmt(0x0001D9EE, "Diagnostic faults which will cause softlanding to occur\nBOOLEAN");
MakeNameEx(0x0001DA30, "T_DG_TYPES_KV_DISABLE_32_MALFUNCTIONS", nameFlags);
MakeRptCmt(0x0001DA30, "Diagnostic faults which will cause the 3-2 pressure bias remedial action to be taken\nBOOLEAN");
MakeNameEx(0x0001DA72, "T_DG_TYPES_KV_INHIBIT_SEM_MALFUNCTIONS", nameFlags);
MakeRptCmt(0x0001DA72, "Diagnostic faults which will cause the SEM disabled remedial action to be taken.\nBOOLEAN");
MakeNameEx(0x0001DAB4, "T_DG_TYPES_KV_DEFAULT_GEAR_MALFUNCTIONS", nameFlags);
MakeRptCmt(0x0001DAB4, "Diagnostic faults which will cause default gear action to be taken\nTrue/False");
MakeNameEx(0x0001DAF6, "T_DG_TYPES_KV_SOFT_LANDING_MALFUNCTIONS", nameFlags);
MakeRptCmt(0x0001DAF6, "Diagnostic faults which will cause soft landing action to be taken\nTrue/False");
MakeNameEx(0x0001DB38, "T_DG_TYPES_KV_LIMIT_GEAR_MALFUNCTIONS", nameFlags);
MakeRptCmt(0x0001DB38, "Diagnostic faults which will cause limiting gear action to be taken\nTrue/False");
MakeNameEx(0x0001DB7A, "T_DG_TYPES_KV_LIMIT_GEAR_TRANS_HOT_MALF", nameFlags);
MakeRptCmt(0x0001DB7A, "Diagnostic faults which will cause limiting gear action to be taken\nTrue/False");
MakeNameEx(0x0001DBBC, "T_DG_TYPES_KV_INHIBIT_DOWN_TO_SECOND", nameFlags);
MakeRptCmt(0x0001DBBC, "Diagnostic faults will result in inhibiting downshift to second.\nTrue/False");
MakeNameEx(0x0001DBFE, "T_DG_TYPES_KV_DIAGNOSTIC_FM_OVERRIDE", nameFlags);
MakeRptCmt(0x0001DBFE, "Diagnostic faults which will cause disabling FM action to be taken.\nBOOLEAN");
MakeNameEx(0x0001DC40, "T_DG_TYPES_KV_DRIVE_2_PRESSURE_MALFUNCTIONS", nameFlags);
MakeRptCmt(0x0001DC40, "Diagnostic faults which will cause drive 2 pressure schedule action to be taken.\nBOOLEAN");
MakeNameEx(0x0001DC82, "T_DG_TYPES_KV_MAXIMUM_PRESSURE_MALFUNCTIONS", nameFlags);
MakeRptCmt(0x0001DC82, "Diagnostic faults which will cause maximum pressure action to be taken.\nBOOLEAN");
MakeNameEx(0x0001DCC4, "T_DG_TYPES_KV_FREEZE_ADAPT_MALFUNCTIONS", nameFlags);
MakeRptCmt(0x0001DCC4, "Diagnostic faults which will cause the freezing of the adaptive pressure modifier to be taken.\nBOOLEAN");
MakeNameEx(0x0001DD06, "T_DG_TYPES_KV_TORQUE_PRESSURE_OFFSET_MALF", nameFlags);
MakeRptCmt(0x0001DD06, "Diagnostic faults that disable the torque pressure offsets.\nBOOLEAN");
MakeNameEx(0x0001DD48, "T_DG_TYPES_KV_ENGINE_TORQUE_MALFUNCTION", nameFlags);
MakeRptCmt(0x0001DD48, "Diagnostic faults that involvethe Engine Torque Calc.\nBOOLEAN");
MakeNameEx(0x0001DD8A, "T_DG_TYPES_KV_TCC_OFF_MALFUNCTIONS", nameFlags);
MakeRptCmt(0x0001DD8A, "Diagnostic faults which will cause the TCC be turned off action to be taken\nTrue/False");
MakeNameEx(0x0001DDCC, "T_DG_TYPES_KV_APPLY_IN_4TH_MALFUNCTIONS", nameFlags);
MakeRptCmt(0x0001DDCC, "Diagnostic faults which will cause the TCC applying in 4th gear action to be taken\nTrue/False");
MakeNameEx(0x0001DE0E, "T_DG_TYPES_KV_TCC_INHIBIT_OUTPUTS_MALFS", nameFlags);
MakeRptCmt(0x0001DE0E, "Diagnostic faults which will cause the TCC output to be inhibited.\nTrue/False");
MakeNameEx(0x0001DE50, "T_DG_TYPES_KV_APPLY_IN_3RD_OR_4TH_MALFS", nameFlags);
MakeRptCmt(0x0001DE50, "Defines which diagnostic faults will resultin the TCC applying in 3rd or 4th gear.\nTrue/False");
MakeNameEx(0x0001DE92, "T_DG_TYPES_KE_SOFT_LIMIT_GEAR_MALF", nameFlags);
MakeRptCmt(0x0001DE92, "TRUE indicates soft limit max gear is desired. FALSE indicates immediate limit max gear is desired for diagnostic action.\nTrue/False");
MakeNameEx(0x0001DE93, "XDT_COMMON_KE_DISABLE_DIAG_FOR_PTO", nameFlags);
MakeRptCmt(0x0001DE93, "To disable diagnostics when PTO is active, set this to TRUE.\nT/F");
MakeNameEx(0x0001DE94, "XDTA_CTCC_KE_TCC_CTRL_SOLENOID_TOTAL_MAX", nameFlags);
MakeRptCmt(0x0001DE94, "Number of times that the TCC control solenoid status can be tested before the test counters are reset.\nCounts");
MakeNameEx(0x0001DE95, "XDTA_CTCC_KE_TCC_CTRL_SOLENOID_FAIL_MAX", nameFlags);
MakeRptCmt(0x0001DE95, "Number of times that an illegal TCC control solenoid status must be seen before the fault is set.\nCounts");
MakeNameEx(0x0001DE96, "XDTA_CTCC_KE_TCC_CTRL_SOLENOID_PASS_MAX", nameFlags);
MakeRptCmt(0x0001DE96, "Number of times that a valid TCC control solenoid status must be seen before the fault is passed.\nCounts");
MakeNameEx(0x0001DE98, "XDTA_CTCC_KE_TCC_CTRL_DUTY_CYCLE_HIGH", nameFlags);
MakeRptCmt(0x0001DE98, "TCC DutyCycle(Capacity)should be ABOVE this threshold to enablethe test for TCC control solenoid\nPercent");
MakeNameEx(0x0001DE9A, "XDTA_CTCC_KE_TCC_CTRL_DUTY_CYCLE_LOW", nameFlags);
MakeRptCmt(0x0001DE9A, "TCC DutyCycle(Capacity)should be BELOW this threshold to enablethe test for TCC control solenoid\nPercent");
MakeNameEx(0x0001DE9C, "XDTA_CTCC_KE_DIAG_TCC_CS_SYS_VOLT_TIME", nameFlags);
MakeRptCmt(0x0001DE9C, "TCC control solenoid output will not be tested if ignition voltage is out of range for longer than this.\nSeconds");
MakeNameEx(0x0001DE9E, "XDTA_D32_KE_D32_SOLENOID_FAIL_COUNT", nameFlags);
MakeRptCmt(0x0001DE9E, "Number of times that an illegal downshift 3-2 solenoid status must be seen before the fault is set.\nCounts");
MakeNameEx(0x0001DE9F, "XDTA_D32_KE_D32_SOLENOID_PASS_COUNT", nameFlags);
MakeRptCmt(0x0001DE9F, "Number of times that a legal downshift 3-2 solenoid status must be seen before the fault is cleared.\nCounts");
MakeNameEx(0x0001DEA0, "XDTA_D32_KE_D32_SOLENOID_TEST_COUNT", nameFlags);
MakeRptCmt(0x0001DEA0, "Total number of times that a legal/ illegal downshift 3-2 solenoid status must be seen before the test counters are reset.\nCounts");
MakeNameEx(0x0001DEA2, "XDTA_D32_KE_DIAG_32DSO_SYS_VOLT_TIME", nameFlags);
MakeRptCmt(0x0001DEA2, "3-2 downshift solenoid output will not be tested if ignition voltage is out of range for longer than this.\nSeconds");
MakeNameEx(0x0001DEA4, "XDTA_ETCC_KE_TCC_ENABLE_FAIL_COUNT", nameFlags);
MakeRptCmt(0x0001DEA4, "Number of times that an illegal TCC Enable solenoid status must be seen before the fault is set.\nCounts");
MakeNameEx(0x0001DEA5, "XDTA_ETCC_KE_TCC_ENABLE_PASS_COUNT", nameFlags);
MakeRptCmt(0x0001DEA5, "Number of times that a legal TCC Enable solenoid status must be seen before the fault is cleared.\nCounts");
MakeNameEx(0x0001DEA6, "XDTA_ETCC_KE_TCC_ENABLE_MAX_COUNT", nameFlags);
MakeRptCmt(0x0001DEA6, "Total number of times that a legal/illegal TCC Enable solenoid status must be seen before the counters are reset.\nCounts");
MakeNameEx(0x0001DEA8, "XDTA_ETCC_KE_DIAG_TCC_ENABLE_SO_SVOLT_TIME", nameFlags);
MakeRptCmt(0x0001DEA8, "TCC enable solenoid output will not be tested if ignition voltage is out of range for longer than this.\nSeconds");
MakeNameEx(0x0001DEAA, "XDTA_SHIFT_SOL_KE_SHIFT_SOLENOID_A_FAIL_COUNT", nameFlags);
MakeRptCmt(0x0001DEAA, "The number of times an invalid status on solenoid A must be seen before the diagnostic fault is set.\nCounts");
MakeNameEx(0x0001DEAB, "XDTA_SHIFT_SOL_KE_SHIFT_SOLENOID_A_MAX_COUNT", nameFlags);
MakeRptCmt(0x0001DEAB, "The number of times solenoid A must be tested before resetting all solenoid A diagnostic counters.\nCounts");
MakeNameEx(0x0001DEAC, "XDTA_SHIFT_SOL_KE_SHIFT_SOLENOID_A_PASS_COUNT", nameFlags);
MakeRptCmt(0x0001DEAC, "The number of times a valid status on solenoid A must be seen before the pass condition is set.\nCounts");
MakeNameEx(0x0001DEAD, "XDTA_SHIFT_SOL_KE_SHIFT_SOLENOID_B_FAIL_COUNT", nameFlags);
MakeRptCmt(0x0001DEAD, "The number of times an invalid status on solenoid B must be seen before the diagnostic fault is set.\nCounts");
MakeNameEx(0x0001DEAE, "XDTA_SHIFT_SOL_KE_SHIFT_SOLENOID_B_MAX_COUNT", nameFlags);
MakeRptCmt(0x0001DEAE, "The number of times solenoid B must be tested before resetting all solenoid B diagnostic counters.\nCounts");
MakeNameEx(0x0001DEAF, "XDTA_SHIFT_SOL_KE_SHIFT_SOLENOID_B_PASS_COUNT", nameFlags);
MakeRptCmt(0x0001DEAF, "The number of times a valid status on solenoid A must be seen before the pass condition is set.\nCounts");
MakeNameEx(0x0001DEB0, "XDTA_SHIFT_SOL_KE_DIAG_SSA_SYS_VOLT_TIME", nameFlags);
MakeRptCmt(0x0001DEB0, "Shift solenoid A output will not be tested if ignition voltage is out of range for longer than this.\nSeconds");
MakeNameEx(0x0001DEB2, "XDTA_SHIFT_SOL_KE_DIAG_SSB_SYS_VOLT_TIME", nameFlags);
MakeRptCmt(0x0001DEB2, "Shift solenoid B output will not be tested if ignition voltage is out of range for longer than this.\nSeconds");
MakeNameEx(0x0001DEB4, "XDTP_4W_LOW_KE_4WD_ETORQUE_LOW", nameFlags);
MakeRptCmt(0x0001DEB4, "Lower engine torque threshold to enable 4WD-Lo diagnostic. Used in a hysteresis pair with KE_4WD_Etorque_High.\nFt_lb");
MakeNameEx(0x0001DEB6, "XDTP_4W_LOW_KE_4WD_ETORQUE_HIGH", nameFlags);
MakeRptCmt(0x0001DEB6, "Higher engine torque threshold to enable 4WD-Lo diagnostic. Used in a hysteresis pair with KE_4WD_Etorque_Low.\nFt_lb");
MakeNameEx(0x0001DEB8, "XDTP_4W_LOW_KE_4WD_VAC_LOW_THRESH", nameFlags);
MakeRptCmt(0x0001DEB8, "Lower engine vacuum threshold to enable 4WD-Lo diagnostic. Used in a hysteresis pair with KE_4WD_Vac_High_Thresh.\nkPa");
MakeNameEx(0x0001DEB9, "XDTP_4W_LOW_KE_4WD_VAC_HIGH_THRESH", nameFlags);
MakeRptCmt(0x0001DEB9, "Higher engine vacuum threshold to enable 4WD-Lo diagnostic. Used in a hysteresis pair with KE_4WD_Vac_Low_Thresh.\nkPa");
MakeNameEx(0x0001DEBA, "XDTP_4W_LOW_KE_4WD_LOW_TPS", nameFlags);
MakeRptCmt(0x0001DEBA, "Lower throttle range threshold to enable 4WD-Lo diagnostic. Used in a hysteresis pair with KE_4WD_High_TPS.\nPercent");
MakeNameEx(0x0001DEBC, "XDTP_4W_LOW_KE_4WD_HIGH_TPS", nameFlags);
MakeRptCmt(0x0001DEBC, "Upper throttle range threshold to enable 4WD-Lo diagnostic. Used in a hysteresis pair with KE_4WD_Low_TPS.\nPercent");
MakeNameEx(0x0001DEBE, "XDTP_4W_LOW_KE_4WD_LOW_TRANS_TEMP", nameFlags);
MakeNameEx(0x0001DEC0, "XDTP_4W_LOW_KE_4WD_HIGH_TRANS_TEMP", nameFlags);
MakeNameEx(0x0001DEC2, "XDTP_4W_LOW_KE_4WD_MPH_THRESH", nameFlags);
MakeRptCmt(0x0001DEC2, "Vehicle speed threshold above which enables the 4WD-Lo diagnostic.\nMPH");
MakeNameEx(0x0001DEC4, "XDTP_4W_LOW_KE_4WD_LOW_TCR_MIN_RATIO", nameFlags);
MakeRptCmt(0x0001DEC4, "Transfer Case Ratio; when in 4WD-Lo, manimum value. Used in a hysteresis pair with KE_4WD_Low_TCR_Max_Ratio.\nUnitless");
MakeNameEx(0x0001DEC6, "XDTP_4W_LOW_KE_4WD_LOW_TCR_MAX_RATIO", nameFlags);
MakeRptCmt(0x0001DEC6, "Transfer Case Ratio; when in 4WD-Lo, maximum value. Used in a hysteresis pair with KE_4WD_Low_TCR_Min_Ratio.\nUnitless");
MakeNameEx(0x0001DEC8, "XDTP_4W_LOW_KE_4WD_HIGH_TCR_MIN_RATIO", nameFlags);
MakeRptCmt(0x0001DEC8, "Transfer case ratio, when not in 4WD-Lo, minimum value. Used in a hysteresis pair with KE_4WD_High_TCR_Max_Ratio.\nUnitless");
MakeNameEx(0x0001DECA, "XDTP_4W_LOW_KE_4WD_HIGH_TCR_MAX_RATIO", nameFlags);
MakeRptCmt(0x0001DECA, "Transfer case ratio, when not in 4WD-Lo, maximum value. Used in a hysteresis pair with KE_4WD_High_TCR_Min_Ratio.\nUnitless");
MakeNameEx(0x0001DECC, "XDTP_4W_LOW_KE_4WD_LO_STUCK_OFF_FAIL_COUNTS", nameFlags);
MakeRptCmt(0x0001DECC, "4WD-Lo switch stuck off fail counter limit\nCounts");
MakeNameEx(0x0001DECD, "XDTP_4W_LOW_KE_4WD_LO_STUCK_ON_FAIL_COUNTS", nameFlags);
MakeRptCmt(0x0001DECD, "4WD-Lo switch stuck on fail counter limit\nCounts");
MakeNameEx(0x0001DECE, "XDTP_4W_LOW_KE_4WD_STUCK_OFF_FAIL_TIME", nameFlags);
MakeNameEx(0x0001DED0, "XDTP_4W_LOW_KE_4WD_STUCK_OFF_PASS_TIME", nameFlags);
MakeNameEx(0x0001DED2, "XDTP_4W_LOW_KE_4WD_STUCK_ON_FAIL_TIME", nameFlags);
MakeNameEx(0x0001DED4, "XDTP_4W_LOW_KE_4WD_STUCK_ON_PASS_TIME", nameFlags);
MakeNameEx(0x0001DED6, "XDTP_4W_LOW_KE_4WD_LO_FAIL_STCK_OFF_SLIP_LO", nameFlags);
MakeNameEx(0x0001DED8, "XDTP_4W_LOW_KE_4WD_LO_FAIL_STCK_OFF_SLIP_HI", nameFlags);
MakeNameEx(0x0001DEDA, "XDTP_4W_LOW_KE_4WD_LO_FAIL_STCK_ON_SLIP_LO", nameFlags);
MakeNameEx(0x0001DEDC, "XDTP_4W_LOW_KE_4WD_LO_FAIL_STCK_ON_SLIP_HI", nameFlags);
MakeNameEx(0x0001DEDE, "XDTP_4W_LOW_KE_4WD_LO_PASS_STCK_OFF_SLIP_LO", nameFlags);
MakeNameEx(0x0001DEE0, "XDTP_4W_LOW_KE_4WD_LO_PASS_STCK_OFF_SLIP_HI", nameFlags);
MakeNameEx(0x0001DEE2, "XDTP_4W_LOW_KE_4WD_LO_PASS_STCK_ON_SLIP_LO", nameFlags);
MakeNameEx(0x0001DEE4, "XDTP_4W_LOW_KE_4WD_LO_PASS_STCK_ON_SLIP_HI", nameFlags);
MakeNameEx(0x0001DEE6, "XDTP_SHIFT_TIME_KV_SHIFT_TIME_LONG_DIAG_LIMIT", nameFlags);
MakeRptCmt(0x0001DEE6, "Time limit above which shift time is considered long\nSeconds");
MakeNameEx(0x0001DEEC, "XDTP_SHIFT_TIME_KV_LONG_SHIFT_AT_MAX_ADAPT_LIMIT", nameFlags);
MakeRptCmt(0x0001DEEC, "Limit for number of long transmission upshifts with adapts at the max limit. When the limit is reached, the diagnostic is set\nCounts");
MakeNameEx(0x0001DEF0, "XDTP_SLIP_COMPONENT_KE_SLIP_COMP_EXTENDED_TIME_1", nameFlags);
MakeRptCmt(0x0001DEF0, "TCC Slip must be in a calibratable range for this long before 1st fault can be set in trans comp slip test.\nSeconds");
MakeNameEx(0x0001DEF2, "XDTP_SLIP_COMPONENT_KE_SLIP_COMP_EXTENDED_TIME_2", nameFlags);
MakeRptCmt(0x0001DEF2, "TCC Slip must be in a calibratable range for this long before 2nd fault can be set in trans comp slip test.\nSeconds");
MakeNameEx(0x0001DEF4, "XDTP_SLIP_COMPONENT_KE_SLIP_COMP_EXTENDED_TIME_3", nameFlags);
MakeRptCmt(0x0001DEF4, "TCC Slip must be in a calibratable range for this long before fault can be set in trans comp slip test.\nSeconds");
MakeNameEx(0x0001DEF6, "XDTP_SLIP_COMPONENT_KE_SLIP_COMP_FAIL_LOW_LIMIT_1", nameFlags);
MakeRptCmt(0x0001DEF6, "Low threshold for TCC slip fail band in condition 1, fail case 2, trans comp slip test.\nRPM");
MakeNameEx(0x0001DEF8, "XDTP_SLIP_COMPONENT_KE_SLIP_COMP_FAIL_LOW_LIMIT_2", nameFlags);
MakeRptCmt(0x0001DEF8, "Low threshold for TCC slip fail band in condition 2, fail case 2, trans comp slip test.\nRPM");
MakeNameEx(0x0001DEFA, "XDTP_SLIP_COMPONENT_KE_SLIP_COMP_FAIL_LOW_LIMIT_3", nameFlags);
MakeRptCmt(0x0001DEFA, "Low threshold for TCC slip fail band in condition 3, fail case 2, trans comp slip test.\nRPM");
MakeNameEx(0x0001DEFC, "XDTP_SLIP_COMPONENT_KE_SLIP_COMP_FAIL_HIGH_LIMIT_1", nameFlags);
MakeRptCmt(0x0001DEFC, "High threshold for TCC slip fail band in condition 1, fail case2, trans comp slip test.\nRPM");
MakeNameEx(0x0001DEFE, "XDTP_SLIP_COMPONENT_KE_SLIP_COMP_FAIL_HIGH_LIMIT_2", nameFlags);
MakeRptCmt(0x0001DEFE, "High threshold for TCC slip fail band in condition 2, fail case2, trans comp slip test.\nRPM");
MakeNameEx(0x0001DF00, "XDTP_SLIP_COMPONENT_KE_SLIP_COMP_FAIL_HIGH_LIMIT_3", nameFlags);
MakeRptCmt(0x0001DF00, "High threshold for TCC slip fail band in condition 3, fail case2, trans comp slip test.\nRPM");
MakeNameEx(0x0001DF02, "XDTP_SLIP_COMPONENT_KE_SLIP_COMP_FC2_THROTTLE_LOW", nameFlags);
MakeRptCmt(0x0001DF02, "The lower limit of throttle position for enabling fail case 2 in the Trans Slip Comp test.\n%");
MakeNameEx(0x0001DF04, "XDTP_SLIP_COMPONENT_KE_SLIP_COMP_FC2_THROTTLE_HIGH", nameFlags);
MakeRptCmt(0x0001DF04, "The upper limit of throttle position for enabling fail case 2 in the Trans Slip Comp test.\n%");
MakeNameEx(0x0001DF06, "XDTP_SLIP_COMPONENT_KE_SLIP_COMP_FC2_ENABLE", nameFlags);
MakeRptCmt(0x0001DF06, "Enables fail case 2 in Trans Comp Slip test.\nT/F");
MakeNameEx(0x0001DF08, "XDTP_SLIP_COMPONENT_KE_COMP_SLIP_TCC_TURN_OFF_TIME", nameFlags);
MakeRptCmt(0x0001DF08, "Amount of time TCC must be turned off due to TCC slipping detected in Trans Comp Slip test, fail case 2, cond 2.\nSeconds");
MakeNameEx(0x0001DF0A, "XDTP_SLIP_COMPONENT_KE_TRANS_COMP_SLIP_MAX_COUNT", nameFlags);
MakeRptCmt(0x0001DF0A, "Transmission component slipping fail case counter.\nCounts");
MakeNameEx(0x0001DF0C, "XDTP_SLIP_COMPONENT_KE_SLIPPING_COMP_TCC_ON_TIME", nameFlags);
MakeRptCmt(0x0001DF0C, "Amount of time TCC must be commanded on before the transmission component slipping test is run.\nSeconds");
MakeNameEx(0x0001DF0E, "XDTP_SLIP_COMPONENT_KE_SLIPPING_COMPONENT_DIAG_TIME", nameFlags);
MakeRptCmt(0x0001DF0E, "Amount of time which slip must be above threshold to set the malfunction\nSeconds");
MakeNameEx(0x0001DF10, "XDTP_SLIP_COMPONENT_KE_SLIPPING_COMP_THROTTLE_HIGH", nameFlags);
MakeRptCmt(0x0001DF10, "Maximum throttle position for enabling the Transmission Slipping Component test.\nPercent");
MakeNameEx(0x0001DF12, "XDTP_SLIP_COMPONENT_KE_SLIPPING_COMP_THROTTLE_LOW", nameFlags);
MakeRptCmt(0x0001DF12, "Minimum throttle position for enabling the Transmission Slipping Component test.\nPercent");
MakeNameEx(0x0001DF14, "XDTP_SLIP_COMPONENT_KE_SLIPPING_COMP_TRANS_TEMP_HIGH", nameFlags);
MakeRptCmt(0x0001DF14, "Maximum transmission temperature for enabling the Transmission Slipping Component tests.\nDegrees_C");
MakeNameEx(0x0001DF16, "XDTP_SLIP_COMPONENT_KE_SLIPPING_COMP_TRANS_TEMP_LOW", nameFlags);
MakeRptCmt(0x0001DF16, "Minimum transmission temperature for enabling the Transmission Slipping Component tests.\nDegrees_C");
MakeNameEx(0x0001DF18, "XDTP_SLIP_COMPONENT_KE_TRANS_SLIP_COMP_ENG_TRQ_LOW", nameFlags);
MakeRptCmt(0x0001DF18, "Upper engine torque bound for transmission component slipping diagnostic test to be enabled.\nFoot Lbs");
MakeNameEx(0x0001DF1A, "XDTP_SLIP_COMPONENT_KE_TRANS_SLIP_COMP_ENG_TRQ_HIGH", nameFlags);
MakeRptCmt(0x0001DF1A, "Lower engine torque bound for transmission component slipping diagnostic test to be enabled.\nFoot Lbs");
MakeNameEx(0x0001DF1C, "XDTP_SLIP_COMPONENT_KE_TRANS_SLIP_COMP_ENG_VAC_LOW", nameFlags);
MakeRptCmt(0x0001DF1C, "Upper bound of engine vacuum constraint.\nkPa");
MakeNameEx(0x0001DF1D, "XDTP_SLIP_COMPONENT_KE_TRANS_SLIP_COMP_ENG_VAC_HIGH", nameFlags);
MakeRptCmt(0x0001DF1D, "Lower bound of engine vacuum constraint.\nkPa");
MakeNameEx(0x0001DF1E, "XDTP_SLIP_COMPONENT_KE_TCC_OFF_THROTTLE_HIGH", nameFlags);
MakeRptCmt(0x0001DF1E, "Maximum throttle position for enabling the TCC stuck off test.\nPercent");
MakeNameEx(0x0001DF20, "XDTP_SLIP_COMPONENT_KE_TCC_OFF_THROTTLE_LOW", nameFlags);
MakeRptCmt(0x0001DF20, "Minimum throttle position for enabling the TCC stuck off test.\nPercent");
MakeNameEx(0x0001DF22, "XDTP_SLIP_COMPONENT_KE_TCC_OFF_TRANS_TEMP_HIGH", nameFlags);
MakeRptCmt(0x0001DF22, "Maximum transmission temperature for enabling the TCC Stuck Off tests.\nDegrees_C");
MakeNameEx(0x0001DF24, "XDTP_SLIP_COMPONENT_KE_TCC_OFF_TRANS_TEMP_LOW", nameFlags);
MakeRptCmt(0x0001DF24, "Minimum transmission temperature for enabling the TCC Stuck Off tests.\nDegrees_C");
MakeNameEx(0x0001DF26, "XDTP_SLIP_COMPONENT_KE_TCC_OFF_FAIL_SLIP_LIMIT", nameFlags);
MakeRptCmt(0x0001DF26, "Above this value the TCC Stuck Off malfunction may be set\nRPM");
MakeNameEx(0x0001DF28, "XDTP_SLIP_COMPONENT_KE_TCC_OFF_PASS_SLIP_LIMIT", nameFlags);
MakeRptCmt(0x0001DF28, "Above this value the TCC Stuck Off malfunction may be cleared\nRPM");
MakeNameEx(0x0001DF2A, "XDTP_SLIP_COMPONENT_KE_TCC_OFF_FAIL_DIAG_TIME", nameFlags);
MakeRptCmt(0x0001DF2A, "Amount of time slip must be above threshold to clear the malfunction\nSeconds");
MakeNameEx(0x0001DF2C, "XDTP_SLIP_COMPONENT_KE_TCC_OFF_PASS_DIAG_TIME", nameFlags);
MakeRptCmt(0x0001DF2C, "Amount of time slip must be above threshold to clear the malfunction\nSeconds");
MakeNameEx(0x0001DF2E, "XDTP_SLIP_COMPONENT_KE_SLIP_COMP_FAIL_HIGH_LIMIT", nameFlags);
MakeRptCmt(0x0001DF2E, "High threshold for TCC slip failband\nRPM");
MakeNameEx(0x0001DF30, "XDTP_SLIP_COMPONENT_KE_SLIP_COMP_FAIL_LOW_LIMIT", nameFlags);
MakeRptCmt(0x0001DF30, "Low threshold for TCC slip failband\nRPM");
MakeNameEx(0x0001DF32, "XDTP_SLIP_COMPONENT_KE_SLIP_COMP_PASS_HIGH_LIMIT", nameFlags);
MakeRptCmt(0x0001DF32, "High threshold for TCC slip pass.\nRPM");
MakeNameEx(0x0001DF34, "XDTP_SLIP_COMPONENT_KE_SLIP_COMP_PASS_LOW_LIMIT", nameFlags);
MakeRptCmt(0x0001DF34, "Low threshold for TCC slip pass.\nRPM");
MakeNameEx(0x0001DF36, "XDTP_SLIP_COMPONENT_KE_SLIP_COMP_FULL_LOCK_TIME", nameFlags);
MakeRptCmt(0x0001DF36, "Time TCC must be commanded at fullat full duty cycle before fail test enables.\nSeconds");
MakeNameEx(0x0001DF38, "XDTP_SLIP_COMPONENT_KE_2_TCC_STUCK_OFF_RATIO_HIGH", nameFlags);
MakeRptCmt(0x0001DF38, "Higher Ratio bound for 2nd gear in the TCCstuck off diagnostic test.\nRatio_Type");
MakeNameEx(0x0001DF3A, "XDTP_SLIP_COMPONENT_KE_2_TCC_STUCK_OFF_RATIO_LOW", nameFlags);
MakeRptCmt(0x0001DF3A, "Lower Ratio bound for 2nd gear in the TCCstuck off diagnostic test.\nRatio_Type");
MakeNameEx(0x0001DF3C, "XDTP_SLIP_COMPONENT_KE_3_TCC_STUCK_OFF_RATIO_HIGH", nameFlags);
MakeRptCmt(0x0001DF3C, "Higher Ratio bound for 3rd gear in the TCCstuck off diagnostic test.\nRatio_Type");
MakeNameEx(0x0001DF3E, "XDTP_SLIP_COMPONENT_KE_3_TCC_STUCK_OFF_RATIO_LOW", nameFlags);
MakeRptCmt(0x0001DF3E, "Lower Ratio bound for 3rd gear in the TCCstuck off diagnostic test.\nRatio_Type");
MakeNameEx(0x0001DF40, "XDTP_SLIP_COMPONENT_KE_4_TCC_STUCK_OFF_RATIO_HIGH", nameFlags);
MakeRptCmt(0x0001DF40, "Higher Ratio bound for 4th gear in the TCCstuck off diagnostic test.\nRatio_Type");
MakeNameEx(0x0001DF42, "XDTP_SLIP_COMPONENT_KE_4_TCC_STUCK_OFF_RATIO_LOW", nameFlags);
MakeRptCmt(0x0001DF42, "Lower Ratio bound for 4th gear in the TCCstuck off diagnostic test.\nRatio_Type");
MakeNameEx(0x0001DF44, "XDTP_SLIP_COMPONENT_KE_TCC_LOCKED_OFF_TIME", nameFlags);
MakeRptCmt(0x0001DF44, "Amount of time TCCmust be in locked mode before TCC Stuck OffDiagnostic Test is run.\nSeconds");
MakeNameEx(0x0001DF46, "XDTP_SLIP_COMPONENT_KE_TCC_STUCK_OFF_MAX_COUNT", nameFlags);
MakeRptCmt(0x0001DF46, "Fail counter for TCC_Stuck_Off.\nCounts");
MakeNameEx(0x0001DF48, "XDTP_SLIP_COMPONENT_KE_TORQUE_CONV_STRESS_MPH", nameFlags);
MakeRptCmt(0x0001DF48, "Vehicle speed must be less than this to enable torque converter overstress diagnostic.\nMPH");
MakeNameEx(0x0001DF4A, "XDTP_SLIP_COMPONENT_KE_TORQUE_CONV_STRESS_THR_HIGH", nameFlags);
MakeRptCmt(0x0001DF4A, "Throttle must be greater than this to fail the torque converter overstress diagnostic.\nPercent");
MakeNameEx(0x0001DF4C, "XDTP_SLIP_COMPONENT_KE_TORQUE_CONV_STRESS_SLIP_HIGH", nameFlags);
MakeRptCmt(0x0001DF4C, "Slip must be greater than this to fail the torque converter overstress diagnostic.\nRPM");
MakeNameEx(0x0001DF4E, "XDTP_SLIP_COMPONENT_KE_TORQUE_CONV_STRESS_FAIL_TIME", nameFlags);
MakeRptCmt(0x0001DF4E, "Amount of time the torque converter overstress fail conditions must be met before the diagnostic Fails.\nSeconds");
MakeNameEx(0x0001DF50, "XDTP_SLIP_COMPONENT_KE_TORQUE_CONV_STRESS_THR_LOW", nameFlags);
MakeRptCmt(0x0001DF50, "Throttle must be less than this to pass the torque converter overstress diagnostic.\nPercent");
MakeNameEx(0x0001DF52, "XDTP_SLIP_COMPONENT_KE_TORQUE_CONV_STRESS_SLIP_LOW", nameFlags);
MakeRptCmt(0x0001DF52, "Slip must be less than this to pass the torque converter overstress diagnostic.\nRPM");
MakeNameEx(0x0001DF54, "XDTP_SLIP_COMPONENT_KE_TORQUE_CONV_STRESS_PASS_TIME", nameFlags);
MakeRptCmt(0x0001DF54, "Amount of time the torque converter overstress pass conditions must be met before the diagnostic Passes.\nSeconds");
MakeNameEx(0x0001DF56, "XDTP_SLIP_COMPONENT_KE_TCC_OFF_LAST_RANGE_CHNG_TIME", nameFlags);
MakeRptCmt(0x0001DF56, "Amount of time since the last change in transmission range status before the TCC Stuck Off diagnostic can be enabled.\nSeconds");
MakeNameEx(0x0001DF58, "XDTP_SLIP_COMPONENT_KE_TRANS_SLIP_COMP_DRIVE_RANGE", nameFlags);
MakeRptCmt(0x0001DF58, "Enable criterion for the diagnostic  Note: Drive_3 exclusively for the 3T40-E trans.\nPRNDL_Type");
MakeNameEx(0x0001DF5A, "XDTP_SLIP_COMPONENT_KE_TRANS_SLIP_COMP_ENG_SPD_LOW", nameFlags);
MakeRptCmt(0x0001DF5A, "Low limit for the engine speed to enable diagnostic\nRPM");
MakeNameEx(0x0001DF5C, "XDTP_SLIP_COMPONENT_KE_TRANS_SLIP_COMP_ENG_SPD_HIGH", nameFlags);
MakeRptCmt(0x0001DF5C, "High limit for the engine speed to enable diagnostic\nRPM");
MakeNameEx(0x0001DF5E, "XDTP_SLIP_COMPONENT_KE_TRANS_SLIP_CMP_SPD_RATIO_LOW", nameFlags);
MakeRptCmt(0x0001DF5E, "Low limit for the speed ratio to enable diagnostic\nRatio");
MakeNameEx(0x0001DF60, "XDTP_SLIP_COMPONENT_KE_TRANS_SLIP_CMP_SPD_RATIO_HIGH", nameFlags);
MakeRptCmt(0x0001DF60, "High limit for the speed ratio to enable diagnostic\nRatio");
MakeNameEx(0x0001DF62, "XDTP_SLIP_COMPONENT_KE_TRANS_SLIP_COMP_VEH_SPD_LOW", nameFlags);
MakeRptCmt(0x0001DF62, "Low limit for the Vehicle speed to enable diagnostic\nMPH");
MakeNameEx(0x0001DF64, "XDTP_SLIP_COMPONENT_KE_TRANS_SLIP_COMP_VEH_SPD_HIGH", nameFlags);
MakeRptCmt(0x0001DF64, "High limit for the Vehicle speed to enable diagnostic\nMPH");
MakeNameEx(0x0001DF66, "XDTP_SLIP_COMPONENT_KE_TCC_LOCKED_CAPACITY", nameFlags);
MakeNameEx(0x0001DF68, "XDTP_TCC_SLIP_KE_TCC_STUCK_ON_FAIL_LOW_SLIP", nameFlags);
MakeRptCmt(0x0001DF68, "TCC stuck on low limit, above this value malfucntion will be set\nRPM_S");
MakeNameEx(0x0001DF6A, "XDTP_TCC_SLIP_KE_TCC_STUCK_ON_FAIL_HIGH_SLIP", nameFlags);
MakeRptCmt(0x0001DF6A, "TCC stuck on high limit, below this value malfucntion will be set\nRPM_S");
MakeNameEx(0x0001DF6C, "XDTP_TCC_SLIP_KE_TCC_STUCK_ON_PASS_LOW_SLIP", nameFlags);
MakeRptCmt(0x0001DF6C, "TCC stuck on low limit, above this value malfucntion will be cleared\nRPM_S");
MakeNameEx(0x0001DF6E, "XDTP_TCC_SLIP_KE_TCC_STUCK_ON_PASS_HIGH_SLIP", nameFlags);
MakeRptCmt(0x0001DF6E, "TCC stuck on high limit, below this value malfucntion will be cleared\nRPM_S");
MakeNameEx(0x0001DF70, "XDTP_TCC_SLIP_KE_TCC_STUCK_ON_ETORQUE_LOW", nameFlags);
MakeRptCmt(0x0001DF70, "TCC Stuck On diagnostic will not execute if torque below this level\nFtLB");
MakeNameEx(0x0001DF72, "XDTP_TCC_SLIP_KE_TCC_STUCK_ON_ETORQUE_HIGH", nameFlags);
MakeRptCmt(0x0001DF72, "TCC Stuck On diagnostic will not execute if torque above this level\nFtLB");
MakeNameEx(0x0001DF74, "XDTP_TCC_SLIP_KE_TCC_STUCK_ON_VAC_HIGH_THRESH", nameFlags);
MakeRptCmt(0x0001DF74, "In order to execute the TCC stuck on diagnostic, engine vac < this cal\nKpa");
MakeNameEx(0x0001DF75, "XDTP_TCC_SLIP_KE_TCC_STUCK_ON_VAC_LOW_THRESH", nameFlags);
MakeRptCmt(0x0001DF75, "In order to execute the TCC stuck on diagnostic, engine vac > this cal\nKpa");
MakeNameEx(0x0001DF76, "XDTP_TCC_SLIP_KE_TCC_STUCK_ON_FAIL_TIME", nameFlags);
MakeRptCmt(0x0001DF76, "Amount of time TCC slip must be between thresholds in order to set malfunction\nSeconds");
MakeNameEx(0x0001DF78, "XDTP_TCC_SLIP_KE_TCC_STUCK_ON_PASS_TIME", nameFlags);
MakeRptCmt(0x0001DF78, "Amount of time TCC slip must be between thresholds in order to clear malfunction\nSeconds");
MakeNameEx(0x0001DF7A, "XDTP_TCC_SLIP_KE_TCC_STUCK_ON_THROTTLE_HIGH", nameFlags);
MakeRptCmt(0x0001DF7A, "Maximum throttle position for enabling the TCC stuck on diagnostic\nPercent");
MakeNameEx(0x0001DF7C, "XDTP_TCC_SLIP_KE_TCC_STUCK_ON_THROTTLE_LOW", nameFlags);
MakeRptCmt(0x0001DF7C, "Minimum throttle position for enabling the TCC stuck on diagnostic\nPercent");
MakeNameEx(0x0001DF7E, "XDTP_TCC_SLIP_KE_TCC_STUCK_ON_FAIL_COUNTER", nameFlags);
MakeRptCmt(0x0001DF7E, "Number of times fail condition must occur in order for the test to report a failure\nSHORTCARD");
MakeNameEx(0x0001DF80, "XDTP_TCC_SLIP_KE_TCC_ON_LAST_RANGE_CHNG_TIME", nameFlags);
MakeRptCmt(0x0001DF80, "Amount of time since the last change in in transmission range status before the TCCStuck On diagnostic can be enabled\nSeconds");
MakeNameEx(0x0001DF82, "XDTP_TCC_SLIP_KE_TCC_SYST_PERF_STU_ON_TEMP_HI", nameFlags);
MakeRptCmt(0x0001DF82, "Disable TCC Stuck On with release switch diagnostic if transmission temperature is above this.\nDegrees_C");
MakeNameEx(0x0001DF83, "XDTP_TCC_SLIP_KE_TCC_SYST_PERF_STU_ON_TEMP_LO", nameFlags);
MakeRptCmt(0x0001DF83, "Disable TCC Stuck On with release switch diagnostic if transmission temperature is below this.\nDegrees_C");
MakeNameEx(0x0001DF84, "XDTP_TCC_SLIP_KE_TCC_ON_REL_SWITCH_TIME_FAIL", nameFlags);
MakeRptCmt(0x0001DF84, "The amount of time that the TCC_Release_Switchindicates TCC release oil is not presentin order to fail\nSeconds");
MakeNameEx(0x0001DF86, "XDTP_TCC_SLIP_KE_TCC_ON_REL_SWITCH_TIME_PASS", nameFlags);
MakeRptCmt(0x0001DF86, "The amount of time that the TCC ReleaseSwitch indicates TCC Release oil is presentin order to pass\nSeconds");
MakeNameEx(0x0001DF88, "XDTP_TCC_SLIP_KE_TCC_ON_W_REL_THROTTLE_HIGH", nameFlags);
MakeRptCmt(0x0001DF88, "High threshold throttle position for TCC Systemstuck on with release switch diagnostic test\nPercent");
MakeNameEx(0x0001DF8A, "XDTP_TCC_SLIP_KE_TCC_ON_W_REL_THROTTLE_LOW", nameFlags);
MakeRptCmt(0x0001DF8A, "Low threshold throttle position for TCC Systemstuck on with release switch diagnostic test\nPercent");
MakeNameEx(0x0001DF8C, "XDTP_TCC_SLIP_KE_TCC_STUCK_ON_DRIVE_RANGE", nameFlags);
MakeRptCmt(0x0001DF8C, "Enable criterion for the diagnostic  Note: Drive_3 exclusively for the 3T40-E trans.\nPRNDL_Type");
MakeNameEx(0x0001DF8E, "XDTP_TCC_SLIP_KE_TCC_STUCK_ON_ENG_SPD_HIGH", nameFlags);
MakeRptCmt(0x0001DF8E, "High limit for the engine speed to enable diagnostic\nRPM");
MakeNameEx(0x0001DF90, "XDTP_TCC_SLIP_KE_TCC_STUCK_ON_ENG_SPD_LOW", nameFlags);
MakeRptCmt(0x0001DF90, "Low limit for the engine speed to enable diagnostic\nRPM");
MakeNameEx(0x0001DF92, "XDTP_TCC_SLIP_KE_TCC_STUCK_ON_SPD_RATIO_HIGH", nameFlags);
MakeRptCmt(0x0001DF92, "High limit for the speed ratio to enable diagnostic\nRatio");
MakeNameEx(0x0001DF94, "XDTP_TCC_SLIP_KE_TCC_STUCK_ON_SPD_RATIO_LOW", nameFlags);
MakeRptCmt(0x0001DF94, "Low limit for the speed ratio to enable diagnostic\nRatio");
MakeNameEx(0x0001DF96, "XDTP_TCC_SLIP_KE_TCC_STUCK_ON_VEH_SPD_HIGH", nameFlags);
MakeRptCmt(0x0001DF96, "High limit for the Vehicle speed to enable diagnostic\nMPH");
MakeNameEx(0x0001DF98, "XDTP_TCC_SLIP_KE_TCC_STUCK_ON_VEH_SPD_LOW", nameFlags);
MakeRptCmt(0x0001DF98, "Low limit for the Vehicle speed to enable diagnostic\nMPH");
MakeNameEx(0x0001DF9A, "XDTP_TEMP_KE_TRANS_OVER_TEMPERATURE_HIGH", nameFlags);
MakeRptCmt(0x0001DF9A, "Degrees Ctemperature threshold above which the transmission over temperature fault may occur\nDegrees_C");
MakeNameEx(0x0001DF9C, "XDTP_TEMP_KE_TRANS_OVER_TEMPERATURE_LOW", nameFlags);
MakeRptCmt(0x0001DF9C, "Degrees Ctemperature threshold below which the transmission over temperature fault isreset\nDegrees_C");
MakeNameEx(0x0001DF9E, "XDTP_TEMP_KE_TRANS_OVER_TEMP_FAIL_TIME", nameFlags);
MakeRptCmt(0x0001DF9E, "Amountof time which transmission temperature must be above the high thresholds before a fault is set\nSeconds");
MakeNameEx(0x0001DFA2, "XDTP_TEMP_KE_TRANS_OVER_TEMP_PASS_TIME", nameFlags);
MakeRptCmt(0x0001DFA2, "Amountof time which transmission temperature must be below the low thresholds before a fault is cleared\nSeconds");
MakeNameEx(0x0001DFA4, "XDTP_TEMP_KE_TEMP_AT_START_UP_HIGH_THRESH", nameFlags);
MakeRptCmt(0x0001DFA4, "Maximumstart up transmission fluid temperaturethreshold to enable fail case of thetransmission temperature performance test\nDegrees C");
MakeNameEx(0x0001DFA6, "XDTP_TEMP_KE_TEMP_AT_START_UP_LOW_THRESH", nameFlags);
MakeRptCmt(0x0001DFA6, "Minimumstart up transmission fluid temperaturethreshold to enable fail case of thetransmission temperature performance test\nDegrees C");
MakeNameEx(0x0001DFA8, "XDTP_TEMP_KE_TEMP_PERF_COOLANT_DELTA", nameFlags);
MakeNameEx(0x0001DFA9, "XDTP_TEMP_KE_TEMP_PERF_COOLANT_THRESH", nameFlags);
MakeRptCmt(0x0001DFA9, "Minimum enginecoolant temperature threshold to enable failcase of the transmission temperatureperformance diagnostic test\nDegrees C");
MakeNameEx(0x0001DFAA, "XDTP_TEMP_KE_TEMP_PERF_ENGINE_RUN_TIME", nameFlags);
MakeRptCmt(0x0001DFAA, "The minimumamount of time engine must be running toenable fail case of the transmissiontemperature performance diagnostic test\nSeconds");
MakeNameEx(0x0001DFAE, "XDTP_TEMP_KE_TEMP_PERF_MPH_OUTPUT_SPD_THRE", nameFlags);
MakeRptCmt(0x0001DFAE, "Minimumoutput speed threshold to enable fail caseof the transmission temperature performancediagnostic test\nMPH");
MakeNameEx(0x0001DFB0, "XDTP_TEMP_KE_TEMP_PERF_MPH_OUTPUT_SPD_TIME", nameFlags);
MakeNameEx(0x0001DFB4, "XDTP_TEMP_KE_TEMP_PERF_SLIP_THRESH", nameFlags);
MakeRptCmt(0x0001DFB4, "Minimum slipthreshold to enable fail case of thetransmission temperature performancediagnostic test\nRPM_S");
MakeNameEx(0x0001DFB6, "XDTP_TEMP_KE_TEMP_PERF_SLIP_TIME", nameFlags);
MakeNameEx(0x0001DFBA, "XDTP_TEMP_KE_TRANS_TEMP_AD_COUNTS_HIGH", nameFlags);
MakeRptCmt(0x0001DFBA, "The maximumtransmission temperature A/D counts to enablethe transmission temperature diagnostictest\nA/D Counts");
MakeNameEx(0x0001DFBB, "XDTP_TEMP_KE_TRANS_TEMP_AD_COUNTS_LOW", nameFlags);
MakeRptCmt(0x0001DFBB, "The minimumtransmission temperature A/D counts to enablethe transmission temperature diagnostictest\nA/D Counts");
MakeNameEx(0x0001DFBC, "XDTP_TEMP_KE_TRANS_TEMP_FAIL_1_DELTA_THRES", nameFlags);
MakeRptCmt(0x0001DFBC, "Minimummabsolute delta transmission fluid temperaturefor fail case 1 of the transmissiontemperature performance diagnostic\nDegrees C");
MakeNameEx(0x0001DFBE, "XDTP_TEMP_KE_TRANS_TEMP_FAIL_1_DIAG_TIME", nameFlags);
MakeNameEx(0x0001DFC0, "XDTP_TEMP_KE_TRANS_TEMP_FAIL_2_COUNT", nameFlags);
MakeNameEx(0x0001DFC1, "XDTP_TEMP_KE_TRANS_TEMP_FAIL_2_DELTA_THRES", nameFlags);
MakeRptCmt(0x0001DFC1, "Minimummabsolute delta transmission fluid temperaturefor fail case 2 of the transmissiontemperature performance diagnostic\nDegrees C");
MakeNameEx(0x0001DFC2, "XDTP_TEMP_KE_TRANS_TEMP_FAIL_2_DIAG_TIME", nameFlags);
MakeNameEx(0x0001DFC4, "XDTP_TEMP_KE_TRANS_TEMP_PASS_1_DELTA_THRES", nameFlags);
MakeRptCmt(0x0001DFC4, "Minimummabsolute delta transmission fluid temperaturefor pass case 1 of the transmissiontemperature performance diagnostic\nDegrees C");
MakeNameEx(0x0001DFC6, "XDTP_TEMP_KE_TRANS_TEMP_PASS_1_DIAG_TIME", nameFlags);
MakeNameEx(0x0001DFC8, "XDTP_TEMP_KE_DIAG_SYS_VOLT_FAULT_TIME", nameFlags);
MakeNameEx(0x0001DFCA, "XDTP_TRANS_RATIO_KE_RATIO_DIAG_THROTTLE_THRESH", nameFlags);
MakeRptCmt(0x0001DFCA, "Low  Throttle limit for Gear Ratio test enable.\nThrottle");
MakeNameEx(0x0001DFCC, "XDTP_TRANS_RATIO_KE_RATIO_DIAG_OUT_SPD_THRESH", nameFlags);
MakeRptCmt(0x0001DFCC, "Low MPH limit for Gear Ratio test enable.\nMPH");
MakeNameEx(0x0001DFCE, "XDTP_TRANS_RATIO_KE_LOW_RATIO_TRAN_TEMP_THRESH", nameFlags);
MakeRptCmt(0x0001DFCE, "Low Degrees C limit for Gear Ratio test enable.\nDeg_C");
MakeNameEx(0x0001DFD0, "XDTP_TRANS_RATIO_KE_UNKNOWN_RATIO_DIAG_TIME", nameFlags);
MakeRptCmt(0x0001DFD0, "Amount of time ratio is outside of the thresholds in order to set malfunction\nSeconds");
MakeNameEx(0x0001DFD2, "XDTP_TRANS_RATIO_KE_UNKNOWN_RATIO_1ST_GEAR_HIGH", nameFlags);
MakeRptCmt(0x0001DFD2, "High limit for 1st gear ratio used in determining if the ratio is unknown\nGear Ratio");
MakeNameEx(0x0001DFD4, "XDTP_TRANS_RATIO_KE_UNKNOWN_RATIO_1ST_GEAR_LOW", nameFlags);
MakeRptCmt(0x0001DFD4, "Low limit for 1st gear ratio used in determining if the ratio is unknown\nGear Ratio");
MakeNameEx(0x0001DFD6, "XDTP_TRANS_RATIO_KE_UNKNOWN_RATIO_REV_GEAR_HIGH", nameFlags);
MakeRptCmt(0x0001DFD6, "High limit for reverse gear ratio used in determining if the ratio is unknown\nGear Ratio");
MakeNameEx(0x0001DFD8, "XDTP_TRANS_RATIO_KE_UNKNOWN_RATIO_REV_GEAR_LOW", nameFlags);
MakeRptCmt(0x0001DFD8, "Low limit for reverse gear ratio used in determining if the ratio is unknown\nGear Ratio");
MakeNameEx(0x0001DFDA, "XDTP_TRANS_RATIO_KE_UNKNOWN_RATIO_2ND_GEAR_HIGH", nameFlags);
MakeRptCmt(0x0001DFDA, "High limit for 2nd gear ratio used in determining if the ratio is unknown\nGear Ratio");
MakeNameEx(0x0001DFDC, "XDTP_TRANS_RATIO_KE_UNKNOWN_RATIO_2ND_GEAR_LOW", nameFlags);
MakeRptCmt(0x0001DFDC, "Low limit for 2nd gear ratio used in determining if the ratio is unknown\nGear Ratio");
MakeNameEx(0x0001DFDE, "XDTP_TRANS_RATIO_KE_UNKNOWN_RATIO_3RD_GEAR_HIGH", nameFlags);
MakeRptCmt(0x0001DFDE, "High limit for 3rd gear ratio used in determining if the ratio is unknown\nGear Ratio");
MakeNameEx(0x0001DFE0, "XDTP_TRANS_RATIO_KE_UNKNOWN_RATIO_3RD_GEAR_LOW", nameFlags);
MakeRptCmt(0x0001DFE0, "Low limit for 3rd gear ratio used in determining if the ratio is unknown\nGear Ratio");
MakeNameEx(0x0001DFE2, "XDTP_TRANS_RATIO_KE_UNKNOWN_RATIO_4TH_GEAR_HIGH", nameFlags);
MakeRptCmt(0x0001DFE2, "High limit for 4th gear ratio used in determining if the ratio is unknown\nGear Ratio");
MakeNameEx(0x0001DFE4, "XDTP_TRANS_RATIO_KE_UNKNOWN_RATIO_4TH_GEAR_LOW", nameFlags);
MakeRptCmt(0x0001DFE4, "Low limit for 4th gear ratio used in determining if the ratio is unknown\nGear Ratio");
MakeNameEx(0x0001DFE6, "XDTP_TRANS_RATIO_KE_UNKNOWN_RATIO_ENG_TRQ_HIGH", nameFlags);
MakeRptCmt(0x0001DFE6, "High limit of Engine Torque constraint in undefined ratio diagnostic test.\nFt_lbs");
MakeNameEx(0x0001DFE8, "XDTP_TRANS_RATIO_KE_UNKNOWN_RATIO_ENG_TRQ_LOW", nameFlags);
MakeRptCmt(0x0001DFE8, "Low limit of Engine Torque constraint in undefined ratio diagnostic test.\nFt_lbs");
MakeNameEx(0x0001DFEA, "XDTP_TRANS_RATIO_KE_UNKNOWN_RATIO_ENG_VAC_HIGH", nameFlags);
MakeRptCmt(0x0001DFEA, "High limit of Engine Vacuum constraint in undefined ratio diagnostic test.\nk_Pa");
MakeNameEx(0x0001DFEB, "XDTP_TRANS_RATIO_KE_UNKNOWN_RATIO_ENG_VAC_LOW", nameFlags);
MakeRptCmt(0x0001DFEB, "Low limit of Engine Vacuum constraint in undefined ratio diagnostic test.\nk_Pa");
MakeNameEx(0x0001DFEC, "XDTP_TRANS_RATIO_KE_UNKNOWN_RATIO_RANGE_TIME", nameFlags);
MakeRptCmt(0x0001DFEC, "Minimum amount of time since manual valve change constraint for undefined ratio diag. test.\nSeconds");
MakeNameEx(0x0001DFEE, "XDTP_TRANS_RATIO_KE_UNKNOWN_RATIO_TRANS_TEMP", nameFlags);
MakeRptCmt(0x0001DFEE, "Amount of transmission temp. constraint for undefined ratio test.\nDeg_C");
MakeNameEx(0x0001DFF0, "XDTP_TRANS_RATIO_KE_UNKNW_RATIO_4WD_HIGH_MTCR_MAX", nameFlags);
MakeNameEx(0x0001DFF2, "XDTP_TRANS_RATIO_KE_UNKNW_RATIO_4WD_HIGH_MTCR_MIN", nameFlags);
MakeNameEx(0x0001DFF4, "XDTP_TRANS_RATIO_KE_UNKNW_RATIO_4WD_LOW_MTCR_MAX", nameFlags);
MakeNameEx(0x0001DFF6, "XDTP_TRANS_RATIO_KE_UNKNW_RATIO_4WD_LOW_MTCR_MIN", nameFlags);
MakeNameEx(0x0001DFF8, "XDTP_TRANS_RATIO_KE_SS_PERF_ENAB_4WD_HI_MTCR_MAX", nameFlags);
MakeRptCmt(0x0001DFF8, "4WD High/Max measured transfer case ratio for Shift Solenoid Perfornce Diagnostic\nNONE");
MakeNameEx(0x0001DFFA, "XDTP_TRANS_RATIO_KE_SS_PERF_ENAB_4WD_HI_MTCR_MIN", nameFlags);
MakeRptCmt(0x0001DFFA, "4WD High/Min measured transfer case ratio for Shift Solenoid Performance Diagnostic\nNONE");
MakeNameEx(0x0001DFFC, "XDTP_TRANS_RATIO_KE_SS_PERF_ENAB_4WD_LO_MTCR_MAX", nameFlags);
MakeRptCmt(0x0001DFFC, "4WD Low/Max measured transfer case ratio for Shift Solenoid Performance Diagnostic\nNONE");
MakeNameEx(0x0001DFFE, "XDTP_TRANS_RATIO_KE_SS_PERF_ENAB_4WD_LO_MTCR_MIN", nameFlags);
MakeRptCmt(0x0001DFFE, "4WD Low/Min measured transfer case rario for Shift Solenoid Performance Diagnostic\nNONE");
MakeNameEx(0x0001E000, "XDTP_TRANS_RATIO_KE_SS_PERF_ENABLE_DIAGTT_HIGH", nameFlags);
MakeRptCmt(0x0001E000, "High transmission temperature calibration limit for Shift Solenoid Performance Diagnostic enabling condition\nDeg_C");
MakeNameEx(0x0001E001, "XDTP_TRANS_RATIO_KE_SS_PERF_ENABLE_DIAGTT_LOW", nameFlags);
MakeRptCmt(0x0001E001, "Low transmission temperature calibration limit for Shift Solenoid Performance Diagnostic\nDeg_C");
MakeNameEx(0x0001E002, "XDTP_TRANS_RATIO_KE_SS_PERF_ENABLE_IGVOLT_HIGH", nameFlags);
MakeRptCmt(0x0001E002, "High ignition voltage calibration for enabling conditions for shift solenoid circuit performance\nVolts");
MakeNameEx(0x0001E003, "XDTP_TRANS_RATIO_KE_SS_PERF_ENABLE_IGVOLT_LOW", nameFlags);
MakeRptCmt(0x0001E003, "Low Ignition Voltage Calibration for enabling condition\nVolts");
MakeNameEx(0x0001E004, "XDTP_TRANS_RATIO_KE_SS_PERF_ENABLE_INPSPD_HIGH", nameFlags);
MakeRptCmt(0x0001E004, "High calibration limit for enabling conditions in Shift Solenoid Performance Diagnostic\nRPM");
MakeNameEx(0x0001E006, "XDTP_TRANS_RATIO_KE_SS_PERF_ENABLE_INPSPD_LOW", nameFlags);
MakeRptCmt(0x0001E006, "Low input speed  calibration limit for Shift Solenoid Performance Diagnostic\nRPM");
MakeNameEx(0x0001E008, "XDTP_TRANS_RATIO_KE_SS_PERF_ENABLE_OUTSPD", nameFlags);
MakeRptCmt(0x0001E008, "Output Speed calibratiofor Shift Solenoid Performance Diagnostic\nRPM");
MakeNameEx(0x0001E00A, "XDTP_TRANS_RATIO_KE_SS_PERF_ETORQUE_FC1_HIGH", nameFlags);
MakeRptCmt(0x0001E00A, "High Limit calibration for fail case 1 Engine Torque Shift Solenoid Performance Diagnostic\nFt_Lb");
MakeNameEx(0x0001E00C, "XDTP_TRANS_RATIO_KE_SS_PERF_ETORQUE_FC1_LOW", nameFlags);
MakeRptCmt(0x0001E00C, "Lower Limit Engine Torque used for Shift Solenoid Performance diagnostic Fail Case 1\nFt_Lb");
MakeNameEx(0x0001E00E, "XDTP_TRANS_RATIO_KE_SS_PERF_ETORQUE_FC2_HIGH", nameFlags);
MakeRptCmt(0x0001E00E, "High Limit calibration for fail case 2 Engine Torque Shift Solenoid Performance Diagnostic\nFt_Lb");
MakeNameEx(0x0001E010, "XDTP_TRANS_RATIO_KE_SS_PERF_ETORQUE_FC2_LOW", nameFlags);
MakeRptCmt(0x0001E010, "Lower Limit Engine Torque Used for Shift Solenoid Performance Fail Case 2 diagnostic Test\nFt_Lb");
MakeNameEx(0x0001E012, "XDTP_TRANS_RATIO_KE_SS_PERF_ETORQUE_FC3_HIGH", nameFlags);
MakeRptCmt(0x0001E012, "High Limit calibration for fail case 3 Engine Torque Shift Solenoid Performance Diagnostic\nFt_Lb");
MakeNameEx(0x0001E014, "XDTP_TRANS_RATIO_KE_SS_PERF_ETORQUE_FC3_LOW", nameFlags);
MakeRptCmt(0x0001E014, "Lower Limit Engine Torque used for Shift Solenoid Performance (Fail Case 3) diagnostic test\nFt_Lb");
MakeNameEx(0x0001E016, "XDTP_TRANS_RATIO_KE_SS_PERF_ETORQUE_FC4_HIGH", nameFlags);
MakeRptCmt(0x0001E016, "High Limit calibration for fail case 4 Engine Torque Shift Solenoid Performance Diagnostic\nFt_Lb");
MakeNameEx(0x0001E018, "XDTP_TRANS_RATIO_KE_SS_PERF_ETORQUE_FC4_LOW", nameFlags);
MakeRptCmt(0x0001E018, "Lower Limit for fail Case 4 Engine Torque in Shift Solenoid Performance Diagnostic test\nFt_Lb");
MakeNameEx(0x0001E01A, "XDTP_TRANS_RATIO_KE_SS_PERF_ETORQUE_FC5_HIGH", nameFlags);
MakeRptCmt(0x0001E01A, "High Limit calibration for fail case 5 Engine Torque Shift Solenoid Performance Diagnostic\nFt_Lb");
MakeNameEx(0x0001E01C, "XDTP_TRANS_RATIO_KE_SS_PERF_ETORQUE_FC5_LOW", nameFlags);
MakeRptCmt(0x0001E01C, "Lower Limit for fail Case 5 Engine Torque in Shift Solenoid Performance Diagnostic test\nFt_Lb");
MakeNameEx(0x0001E01E, "XDTP_TRANS_RATIO_KE_SS_PERF_ETORQUE_FC6_HIGH", nameFlags);
MakeRptCmt(0x0001E01E, "High Limit calibration for fail case 1 Engine Torque Shift Solenoid Performance Diagnostic\nFt_Lb");
MakeNameEx(0x0001E020, "XDTP_TRANS_RATIO_KE_SS_PERF_ETORQUE_FC6_LOW", nameFlags);
MakeRptCmt(0x0001E020, "Lower Limit for fail Case 6 Engine Torque in Shift Solenoid Performance Diagnostic Tset\nFt_Lb");
MakeNameEx(0x0001E022, "XDTP_TRANS_RATIO_KE_SS_PERF_ETORQUE_FC7_HIGH", nameFlags);
MakeRptCmt(0x0001E022, "High Limit calibration for fail case 7 Engine Torque Shift Solenoid Performance Diagnostic\nFt_Lb");
MakeNameEx(0x0001E024, "XDTP_TRANS_RATIO_KE_SS_PERF_ETORQUE_FC7_LOW", nameFlags);
MakeRptCmt(0x0001E024, "Lower Limit for fail Case 7 Engine Torque in Shift Solenoid Performance Diagnostic Test\nFt_Lb");
MakeNameEx(0x0001E026, "XDTP_TRANS_RATIO_KE_SS_PERF_ETORQUE_FC8_HIGH", nameFlags);
MakeRptCmt(0x0001E026, "High limit calibration for fail case 8 Engine Torque Shift Solenoid Performance Diagnostic\nFt_Lb");
MakeNameEx(0x0001E028, "XDTP_TRANS_RATIO_KE_SS_PERF_ETORQUE_FC8_LOW", nameFlags);
MakeRptCmt(0x0001E028, "Lower Limit for Fail case 8 Engine Torque in Shift Solenoid Diagnostic Test\nFt_Lb");
MakeNameEx(0x0001E02A, "XDTP_TRANS_RATIO_KE_SS_PERF_ETORQUE_PC1_HIGH", nameFlags);
MakeRptCmt(0x0001E02A, "High pass case 1 limit Engine Torque used for Shift Solenoid Performance Diagnostio\nFt_Lb");
MakeNameEx(0x0001E02C, "XDTP_TRANS_RATIO_KE_SS_PERF_ETORQUE_PC1_LOW", nameFlags);
MakeRptCmt(0x0001E02C, "Lower pass case 1 Engine Torque calibration limit for Shift Solenoid Performance Diagnostic\nFt_Lb");
MakeNameEx(0x0001E02E, "XDTP_TRANS_RATIO_KE_SS_PERF_ETORQUE_PC2_HIGH", nameFlags);
MakeRptCmt(0x0001E02E, "High pass case 2 calibration limit for Shift Solenoid Performance Diagnostic\nFt_Lb");
MakeNameEx(0x0001E030, "XDTP_TRANS_RATIO_KE_SS_PERF_ETORQUE_PC2_LOW", nameFlags);
MakeRptCmt(0x0001E030, "Low pass case 2 Engine Torque calibration limit for Shift Solenoid Perfromance Diagnostic\nFt_Lb");
MakeNameEx(0x0001E032, "XDTP_TRANS_RATIO_KE_SS_PERF_ETORQUE_PC3_HIGH", nameFlags);
MakeRptCmt(0x0001E032, "High pass 3 Engine Torque calibration limit for Shift Solenoid Performance Diagnostic\nFt_Lb");
MakeNameEx(0x0001E034, "XDTP_TRANS_RATIO_KE_SS_PERF_ETORQUE_PC3_LOW", nameFlags);
MakeRptCmt(0x0001E034, "Low pass case 3 Engine Torque calibration limit For Shift Solenoid Performance Diagnostic\nFt_Lb");
MakeNameEx(0x0001E036, "XDTP_TRANS_RATIO_KE_SS_PERF_ETORQUE_PC4_HIGH", nameFlags);
MakeRptCmt(0x0001E036, "High pass case 4 Engine Torque calibration limit for Shift Solenoid Performance Diagnostic\nFt_Lb");
MakeNameEx(0x0001E038, "XDTP_TRANS_RATIO_KE_SS_PERF_ETORQUE_PC4_LOW", nameFlags);
MakeRptCmt(0x0001E038, "Low pass case 4 Engine Torque  calibration limit for Shift Solenoid Performance Diagnostic\nFt_Lb");
MakeNameEx(0x0001E03A, "XDTP_TRANS_RATIO_KE_SS_PERF_FAIL_D1144_COUNTER", nameFlags);
MakeRptCmt(0x0001E03A, "Shift Solenoid Performance Diagnostic Fail Counter for 1144 Failure Mode\ncounts");
MakeNameEx(0x0001E03B, "XDTP_TRANS_RATIO_KE_SS_PERF_FAIL_D1221_COUNTER", nameFlags);
MakeRptCmt(0x0001E03B, "Shift Solenoid Performance Diagnostic Fail Counter for 1221 Failure Mode\ncounts");
MakeNameEx(0x0001E03C, "XDTP_TRANS_RATIO_KE_SS_PERF_FAIL_D2233_COUNTER", nameFlags);
MakeRptCmt(0x0001E03C, "Shift Solenoid Performance Diagnostic Fail Counter for 2233 Failure Mode\ncounts");
MakeNameEx(0x0001E03D, "XDTP_TRANS_RATIO_KE_SS_PERF_FAIL_D4334_COUNTER", nameFlags);
MakeRptCmt(0x0001E03D, "Shift Solenoid Performance Diagnostic Fail Counter for 4334 Failure Mode\ncounts");
MakeNameEx(0x0001E03E, "XDTP_TRANS_RATIO_KE_SS_PERF_FAIL_TIME_FC1", nameFlags);
MakeRptCmt(0x0001E03E, "Fail case 1 timer for Shift Solenoid Performance Diagnostic\nSeconds");
MakeNameEx(0x0001E040, "XDTP_TRANS_RATIO_KE_SS_PERF_FAIL_TIME_FC2", nameFlags);
MakeRptCmt(0x0001E040, "Fail case 2 timer for Shift Solenoid Perfromance Diagnostic\nSeconds");
MakeNameEx(0x0001E042, "XDTP_TRANS_RATIO_KE_SS_PERF_FAIL_TIME_FC3", nameFlags);
MakeRptCmt(0x0001E042, "Fail case 3 timer for Shift Solenoid Performance Diagnostic\nSeconds");
MakeNameEx(0x0001E044, "XDTP_TRANS_RATIO_KE_SS_PERF_FAIL_TIME_FC4", nameFlags);
MakeRptCmt(0x0001E044, "Fail case 4 timer for Shift Solenoid Performance Diagnostic\nSeconds");
MakeNameEx(0x0001E046, "XDTP_TRANS_RATIO_KE_SS_PERF_FAIL_TIME_FC5", nameFlags);
MakeRptCmt(0x0001E046, "Fail case 5 timer for Shift Solenoid Performance Diagnostic\nSeconds");
MakeNameEx(0x0001E048, "XDTP_TRANS_RATIO_KE_SS_PERF_FAIL_TIME_FC6", nameFlags);
MakeRptCmt(0x0001E048, "Fail case 6 timer for Shift Solenoid Performance Diagnostic\nSeconds");
MakeNameEx(0x0001E04A, "XDTP_TRANS_RATIO_KE_SS_PERF_FAIL_TIME_FC7", nameFlags);
MakeRptCmt(0x0001E04A, "Fail case 7 timer for Shift Solenoid Performance Diagnostic\nSeconds");
MakeNameEx(0x0001E04C, "XDTP_TRANS_RATIO_KE_SS_PERF_FAIL_TIME_FC8", nameFlags);
MakeRptCmt(0x0001E04C, "Fail case 8 timer for Shift Solenoid Performance Diagnostic\nSeconds");
MakeNameEx(0x0001E04E, "XDTP_TRANS_RATIO_KE_SS_PERF_GEAR_CHANGE_TIMER_FC1", nameFlags);
MakeRptCmt(0x0001E04E, "Fail case 1 Gear change timer calibration for Shift Solenoid Performance Diagnostic\nSeconds");
MakeNameEx(0x0001E050, "XDTP_TRANS_RATIO_KE_SS_PERF_GEAR_CHANGE_TIMER_FC2", nameFlags);
MakeRptCmt(0x0001E050, "Fail case 2 gear change timer calibration for Shift Solenoid Performnace Diagnostic\nSeconds");
MakeNameEx(0x0001E052, "XDTP_TRANS_RATIO_KE_SS_PERF_GEAR_CHANGE_TIMER_FC3", nameFlags);
MakeRptCmt(0x0001E052, "Fail case 3 Gear change timer for Shift Solenoid Performnace Diagnostic\nSeconds");
MakeNameEx(0x0001E054, "XDTP_TRANS_RATIO_KE_SS_PERF_GEAR_CHANGE_TIMER_FC4", nameFlags);
MakeRptCmt(0x0001E054, "Fail case 4 Gear change timer calibration for Shift Solenoid Performance Diagnostic\nSeconds");
MakeNameEx(0x0001E056, "XDTP_TRANS_RATIO_KE_SS_PERF_GEAR_CHANGE_TIMER_FC5", nameFlags);
MakeRptCmt(0x0001E056, "Fail case 5 gear change timer for Shift Solenoid Performance Diagnostic\nSeconds");
MakeNameEx(0x0001E058, "XDTP_TRANS_RATIO_KE_SS_PERF_GEAR_CHANGE_TIMER_FC6", nameFlags);
MakeRptCmt(0x0001E058, "Fail case 6 gear change timer calibration for Shift Solenoid Performance Diagnostic\nSeconds");
MakeNameEx(0x0001E05A, "XDTP_TRANS_RATIO_KE_SS_PERF_GEAR_CHANGE_TIMER_FC7", nameFlags);
MakeRptCmt(0x0001E05A, "Fail case 7 gear change timer calibration for Shift Solenoid Performance Diagnostic\nSeconds");
MakeNameEx(0x0001E05C, "XDTP_TRANS_RATIO_KE_SS_PERF_GEAR_CHANGE_TIMER_FC8", nameFlags);
MakeRptCmt(0x0001E05C, "Fail case 8 gear change timer calibration for Shift Solenoid Performance Diagnostic\nSeconds");
MakeNameEx(0x0001E05E, "XDTP_TRANS_RATIO_KE_SS_PERF_ENABLE_FC4", nameFlags);
MakeRptCmt(0x0001E05E, "Bit select enble calibration for fail case four\nT/F");
MakeNameEx(0x0001E05F, "XDTP_TRANS_RATIO_KE_SS_PERF_ENABLE_FC8", nameFlags);
MakeRptCmt(0x0001E05F, "Bit select enable calibrationfor fail case eight\nT/F");
MakeNameEx(0x0001E060, "XDTP_TRANS_RATIO_KE_SS_PERF_MODELSR_FC1", nameFlags);
MakeRptCmt(0x0001E060, "Fail case 1 Modeled Speed Ratio calibration for Shift Solenoid Performance Diagnostic\nFactor");
MakeNameEx(0x0001E061, "XDTP_TRANS_RATIO_KE_SS_PERF_MODELSR_FC2", nameFlags);
MakeRptCmt(0x0001E061, "Fail case 2 Modeled Speed Ratio calibration for Shift Solenoid Performance Diagnostic\nFactor");
MakeNameEx(0x0001E062, "XDTP_TRANS_RATIO_KE_SS_PERF_MODELSR_FC3", nameFlags);
MakeRptCmt(0x0001E062, "Fail case 3 Modeled Speed Ratio calibration\nFactor");
MakeNameEx(0x0001E063, "XDTP_TRANS_RATIO_KE_SS_PERF_MODELSR_FC4", nameFlags);
MakeRptCmt(0x0001E063, "Fail case 4 Modeled Speed Ratio calibration for Shift Solenoid Perfromance Diagnostic\nFactor");
MakeNameEx(0x0001E064, "XDTP_TRANS_RATIO_KE_SS_PERF_MODELSR_FC5", nameFlags);
MakeRptCmt(0x0001E064, "Fail case 5 Modeled Speed Ratio calibration for Shift Solenoid Perfromance Diagnostic\nFactor");
MakeNameEx(0x0001E065, "XDTP_TRANS_RATIO_KE_SS_PERF_MODELSR_FC6", nameFlags);
MakeRptCmt(0x0001E065, "Fail case 6 Modeled Speed Ratio calibration for Shift Solenoid Performance Diagnostic\nFactor");
MakeNameEx(0x0001E066, "XDTP_TRANS_RATIO_KE_SS_PERF_MODELSR_FC7", nameFlags);
MakeRptCmt(0x0001E066, "Fail case 7 Modeled Speed Ratio calibration for Shift Solenoid Performance Diagnostic\nFactor");
MakeNameEx(0x0001E067, "XDTP_TRANS_RATIO_KE_SS_PERF_MODELSR_FC8", nameFlags);
MakeRptCmt(0x0001E067, "Fail case 8 Modeled Speed Ratio calibration for Shift Solenoid Performance Diagnostic\nFactor");
MakeNameEx(0x0001E068, "XDTP_TRANS_RATIO_KE_SS_PERF_MODELSR_PC1", nameFlags);
MakeRptCmt(0x0001E068, "Pass case 1 Modeled Speed ratio calibration for Shift Solenoid Performance Diagnostic\nFactor");
MakeNameEx(0x0001E069, "XDTP_TRANS_RATIO_KE_SS_PERF_MODELSR_PC2", nameFlags);
MakeRptCmt(0x0001E069, "Pass case 2 Modeled Speed Ratio calibration for Shift Solenoid Performance Diagnostic\nFactor");
MakeNameEx(0x0001E06A, "XDTP_TRANS_RATIO_KE_SS_PERF_MODELSR_PC3", nameFlags);
MakeRptCmt(0x0001E06A, "Pass case 3 Model Speed Ratio calibration\nFactor");
MakeNameEx(0x0001E06B, "XDTP_TRANS_RATIO_KE_SS_PERF_MODELSR_PC4", nameFlags);
MakeRptCmt(0x0001E06B, "Pass case 4 Model Speed Ratio calibration\nFactor");
MakeNameEx(0x0001E06C, "XDTP_TRANS_RATIO_KE_SS_PERF_OUTSPD_FC5", nameFlags);
MakeRptCmt(0x0001E06C, "Fail case 5 output speed calibration for Shift Solenoid Performance Diagnostic\nRPM");
MakeNameEx(0x0001E06E, "XDTP_TRANS_RATIO_KE_SS_PERF_PASS_TIME_PC1", nameFlags);
MakeRptCmt(0x0001E06E, "Pass case 1 time calibration for Shift Solenoid Performance Diagnostic\nSeconds");
MakeNameEx(0x0001E070, "XDTP_TRANS_RATIO_KE_SS_PERF_PASS_TIME_PC2", nameFlags);
MakeRptCmt(0x0001E070, "Pass case 2 time calibration for Shift Solenoid Performnace Diagnostic\nSeconds");
MakeNameEx(0x0001E072, "XDTP_TRANS_RATIO_KE_SS_PERF_PASS_TIME_PC3", nameFlags);
MakeRptCmt(0x0001E072, "Pass case 3 timer calibration for Shift Solenoid Performance Diagnostic\nSeconds");
MakeNameEx(0x0001E074, "XDTP_TRANS_RATIO_KE_SS_PERF_PASS_TIME_PC4", nameFlags);
MakeRptCmt(0x0001E074, "Pass case 4 timer for Shift Solenoid Performance diagnostic\nSeconds");
MakeNameEx(0x0001E076, "XDTP_TRANS_RATIO_KE_SS_PERF_RATIO_FC1_HIGH", nameFlags);
MakeRptCmt(0x0001E076, "High ratio limit for fail case 1 in Shift Solenoid Performance Diagnostic\nRatio");
MakeNameEx(0x0001E078, "XDTP_TRANS_RATIO_KE_SS_PERF_RATIO_FC1_LOW", nameFlags);
MakeRptCmt(0x0001E078, "Lower ratio limt for fail case 1 in Shift Solenoid Performance Diagnostic\nRatio");
MakeNameEx(0x0001E07A, "XDTP_TRANS_RATIO_KE_SS_PERF_RATIO_FC2_HIGH", nameFlags);
MakeRptCmt(0x0001E07A, "Higher ratio limit for fail case 2 in Shift Solenoid Performance Diagnostic\nRatio");
MakeNameEx(0x0001E07C, "XDTP_TRANS_RATIO_KE_SS_PERF_RATIO_FC2_LOW", nameFlags);
MakeRptCmt(0x0001E07C, "Lower ratio limit for fail case 2 in Shift Solenoid Performnace Diagnostic\nRatio");
MakeNameEx(0x0001E07E, "XDTP_TRANS_RATIO_KE_SS_PERF_RATIO_FC3_HIGH", nameFlags);
MakeRptCmt(0x0001E07E, "Higher ratio limit for fail case 3 in Shift Solenoid Performance Diagnostic\nRatio");
MakeNameEx(0x0001E080, "XDTP_TRANS_RATIO_KE_SS_PERF_RATIO_FC3_LOW", nameFlags);
MakeRptCmt(0x0001E080, "Lower ratio limit for fail case 3 in Shift Solenoid Performance Diagnostic\nRatio");
MakeNameEx(0x0001E082, "XDTP_TRANS_RATIO_KE_SS_PERF_RATIO_FC4_HIGH", nameFlags);
MakeRptCmt(0x0001E082, "High ratio limit for fail case 4 in Shift Solenoid Performance Diagnostic\nRatio");
MakeNameEx(0x0001E084, "XDTP_TRANS_RATIO_KE_SS_PERF_RATIO_FC4_LOW", nameFlags);
MakeRptCmt(0x0001E084, "Low ratio limit for fail case 4 in Shift Solenoid Performance Diagnostic\nRatio");
MakeNameEx(0x0001E086, "XDTP_TRANS_RATIO_KE_SS_PERF_RATIO_FC5_HIGH", nameFlags);
MakeRptCmt(0x0001E086, "High ratio limit for fail case 5 in Shift Solenoid Performnace Diagnostic\nRatio");
MakeNameEx(0x0001E088, "XDTP_TRANS_RATIO_KE_SS_PERF_RATIO_FC5_LOW", nameFlags);
MakeRptCmt(0x0001E088, "Lower ratio limit for fail case 5 in Shift Solenoid Performance\nRatio");
MakeNameEx(0x0001E08A, "XDTP_TRANS_RATIO_KE_SS_PERF_RATIO_FC6_HIGH", nameFlags);
MakeRptCmt(0x0001E08A, "High ratio limit for fail case 6 in Shift Solenoid Performance Diagnostic\nRatio");
MakeNameEx(0x0001E08C, "XDTP_TRANS_RATIO_KE_SS_PERF_RATIO_FC6_LOW", nameFlags);
MakeRptCmt(0x0001E08C, "Lower ratio limit for fail case 6 in Shift Solenoid Performance Diagnostic\nRatio");
MakeNameEx(0x0001E08E, "XDTP_TRANS_RATIO_KE_SS_PERF_RATIO_FC7_HIGH", nameFlags);
MakeRptCmt(0x0001E08E, "High ratio limit for fail case 7 in Shift Solenoid Performance Diagnostic\nRatio");
MakeNameEx(0x0001E090, "XDTP_TRANS_RATIO_KE_SS_PERF_RATIO_FC7_LOW", nameFlags);
MakeRptCmt(0x0001E090, "Lower ratio limit for fail case 7 in Shift Solenoid Performance Diagnostic\nRatio");
MakeNameEx(0x0001E092, "XDTP_TRANS_RATIO_KE_SS_PERF_RATIO_FC8_HIGH", nameFlags);
MakeRptCmt(0x0001E092, "High ratio limit for fail case 8 in Shift Solenoid Performance\nRatio");
MakeNameEx(0x0001E094, "XDTP_TRANS_RATIO_KE_SS_PERF_RATIO_FC8_LOW", nameFlags);
MakeRptCmt(0x0001E094, "Lower ratio limit for fail case 8 in Shift Solenoid Performance Diagnostic\nRatio");
MakeNameEx(0x0001E096, "XDTP_TRANS_RATIO_KE_SS_PERF_RATIO_PC1_HIGH", nameFlags);
MakeRptCmt(0x0001E096, "High ratio limit for fail case 1 in Shift Solenoid Performance Diagnostic\nRatio");
MakeNameEx(0x0001E098, "XDTP_TRANS_RATIO_KE_SS_PERF_RATIO_PC1_LOW", nameFlags);
MakeRptCmt(0x0001E098, "Low ratio calibration limit for pass case 1 in Shift Solenoid Performance Diagnostic\nRatio");
MakeNameEx(0x0001E09A, "XDTP_TRANS_RATIO_KE_SS_PERF_RATIO_PC2_HIGH", nameFlags);
MakeRptCmt(0x0001E09A, "High ratio calibration limit for pass case 2 in Shift Solenoid Performance Diagnostic\nRatio");
MakeNameEx(0x0001E09C, "XDTP_TRANS_RATIO_KE_SS_PERF_RATIO_PC2_LOW", nameFlags);
MakeRptCmt(0x0001E09C, "Low ratio calibration limit for pass case 2 in Shift Solenoid Performance Diagnostic\nRatio");
MakeNameEx(0x0001E09E, "XDTP_TRANS_RATIO_KE_SS_PERF_RATIO_PC3_HIGH", nameFlags);
MakeRptCmt(0x0001E09E, "High ratio calibration for pass case 3 in Shift Solenoid Performance Diagnostic\nRatio");
MakeNameEx(0x0001E0A0, "XDTP_TRANS_RATIO_KE_SS_PERF_RATIO_PC3_LOW", nameFlags);
MakeRptCmt(0x0001E0A0, "Low ratio calibration limit for pass case 3 in Shift Soleoid Performance Diagnostic\nRatio");
MakeNameEx(0x0001E0A2, "XDTP_TRANS_RATIO_KE_SS_PERF_RATIO_PC4_HIGH", nameFlags);
MakeRptCmt(0x0001E0A2, "High ratio calibration limit for fail case 4 in Shift Solenoid Performance Diagnostic\nRatio");
MakeNameEx(0x0001E0A4, "XDTP_TRANS_RATIO_KE_SS_PERF_RATIO_PC4_LOW", nameFlags);
MakeRptCmt(0x0001E0A4, "Low ratio calibration limit for pass case 4 in Shift Solenoid Performance Diagnostic\nRatio");
MakeNameEx(0x0001E0A6, "XDTP_TRANS_RATIO_KE_SS_PERF_SLIP_FC5_HIGH", nameFlags);
MakeRptCmt(0x0001E0A6, "High slip limit for fail case 5 in Shift Solenoid Performance Diagnostic test\nRPM");
MakeNameEx(0x0001E0A8, "XDTP_TRANS_RATIO_KE_SS_PERF_SLIP_FC5_LOW", nameFlags);
MakeRptCmt(0x0001E0A8, "Low slip limit for fail case 5 in Shift Solenoid Performance Diagnostic test\nRPM");
MakeNameEx(0x0001E0AA, "XDTP_TRANS_RATIO_KE_SS_PERF_THROT_FC1", nameFlags);
MakeRptCmt(0x0001E0AA, "Fail case 1 Throttle position threshold for Shift Solenoid Performance Diagnostic\nPercent");
MakeNameEx(0x0001E0AC, "XDTP_TRANS_RATIO_KE_SS_PERF_THROT_FC2", nameFlags);
MakeRptCmt(0x0001E0AC, "Fail case 2 Throttle position threshold for Shift Solenoid Performance Diagnostic\nPercent");
MakeNameEx(0x0001E0AE, "XDTP_TRANS_RATIO_KE_SS_PERF_THROT_FC3", nameFlags);
MakeRptCmt(0x0001E0AE, "Fail case 3 Throttle position threshold for Shift Solenoid Performance Diagnostic\nPercent");
MakeNameEx(0x0001E0B0, "XDTP_TRANS_RATIO_KE_SS_PERF_THROT_FC4", nameFlags);
MakeRptCmt(0x0001E0B0, "Fail case 4 Throttle position threshold for Shift Solenoid Performance Diagnostic\nPercent");
MakeNameEx(0x0001E0B2, "XDTP_TRANS_RATIO_KE_SS_PERF_THROT_FC5", nameFlags);
MakeRptCmt(0x0001E0B2, "Fail case 5 Throttle position threshold for Shift Solenoid Performance Diagnostic\nPercent");
MakeNameEx(0x0001E0B4, "XDTP_TRANS_RATIO_KE_SS_PERF_THROT_FC6", nameFlags);
MakeRptCmt(0x0001E0B4, "Fail case 6 Throttle position threshold for Shift Solenoid Performance Diagnostic\nPercent");
MakeNameEx(0x0001E0B6, "XDTP_TRANS_RATIO_KE_SS_PERF_THROT_FC7", nameFlags);
MakeRptCmt(0x0001E0B6, "Fail case 7 throttle position threshold for Shift Solenoid Performance Diagnostic\nPercent");
MakeNameEx(0x0001E0B8, "XDTP_TRANS_RATIO_KE_SS_PERF_THROT_FC8", nameFlags);
MakeRptCmt(0x0001E0B8, "Fail Case 8 throttle position threshold for Shift Solenoid Performance Diagnostic\nPercent");
MakeNameEx(0x0001E0BA, "XDTP_TRANS_RATIO_KE_SS_PERF_THROT_PC1", nameFlags);
MakeRptCmt(0x0001E0BA, "Pass case 1 throttle position threshold for Shift Solenoid Performance Diagnostic\nPercent");
MakeNameEx(0x0001E0BC, "XDTP_TRANS_RATIO_KE_SS_PERF_THROT_PC2", nameFlags);
MakeRptCmt(0x0001E0BC, "Pass case 2 throttle position threshold for Shift Solenoid Performance Diagnostic\nPercent");
MakeNameEx(0x0001E0BE, "XDTP_TRANS_RATIO_KE_SS_PERF_THROT_PC3", nameFlags);
MakeRptCmt(0x0001E0BE, "Pass case 3 throttle position threshold for Shift Solenoid Performance Diagnostic\nPercent");
MakeNameEx(0x0001E0C0, "XDTP_TRANS_RATIO_KE_SS_PERF_THROT_PC4", nameFlags);
MakeRptCmt(0x0001E0C0, "Pass case 4 throttle position threshold for Shift Solenoid Performance Diagnostic\nPercent");
MakeNameEx(0x0001E0C2, "XDTS_BRAKE_KE_BRAKE_STUCK_ON_RECOVER_TIME", nameFlags);
MakeNameEx(0x0001E0C4, "XDTS_BRAKE_KE_BRAKE_STUCK_OFF_RECOVER_TIME", nameFlags);
MakeNameEx(0x0001E0C6, "XDTS_BRAKE_KE_BRAKE_ON_OUT_SPD_LOW_THRESH", nameFlags);
MakeRptCmt(0x0001E0C6, "Starting speed for detecting an acceleration cycle for brakeswitch stuck on diagnostic.\nMPH");
MakeNameEx(0x0001E0C8, "XDTS_BRAKE_KE_BRAKE_OFF_OUT_SPD_LOW_THRESH", nameFlags);
MakeRptCmt(0x0001E0C8, "Starting speed for detecting an acceleration cycle for brake switch stuck off diagnostic.\nMPH");
MakeNameEx(0x0001E0CA, "XDTS_BRAKE_KE_BRAKE_ON_OUT_SPD_HIGH_THRESH", nameFlags);
MakeRptCmt(0x0001E0CA, "Ending speed for detecting an acceleration cycle for brake switch stuck on diagnostic.\nMPH");
MakeNameEx(0x0001E0CC, "XDTS_BRAKE_KE_BRAKE_OFF_OUT_SPD_HIGH_THRESH", nameFlags);
MakeRptCmt(0x0001E0CC, "Ending speed for detecting an acceleration cycle for brake switch stuck off diagnostic.\nMPH");
MakeNameEx(0x0001E0CE, "XDTS_BRAKE_KE_ON_HIGH_TIME_LIMIT", nameFlags);
MakeRptCmt(0x0001E0CE, "Amount of time vehicle speed must be above the high thresholdduring the accel cycle in thebrake stuck on test.\nSeconds");
MakeNameEx(0x0001E0D0, "XDTS_BRAKE_KE_ON_MED_TIME_LIMIT", nameFlags);
MakeRptCmt(0x0001E0D0, "Amount of time vehicle speed must be in-between the high and low threshold during the brakestuck on test accelerationcycle.\nSeconds");
MakeNameEx(0x0001E0D2, "XDTS_BRAKE_KE_OFF_HIGH_TIME_LIMIT", nameFlags);
MakeNameEx(0x0001E0D4, "XDTS_BRAKE_KE_OFF_MED_TIME_LIMIT", nameFlags);
MakeRptCmt(0x0001E0D4, "Amount of time vehicle speed must be in-between the low andhigh threshold during a decel cycle in the brake stuck off test.\nSeconds");
MakeNameEx(0x0001E0D6, "XDTS_BRAKE_KE_BRAKE_ON_WITH_ACCEL_LIMIT", nameFlags);
MakeRptCmt(0x0001E0D6, "Number of acceleration events with the brake depressed above which the brake switch stuck on malfunction will be set.\nCounts");
MakeNameEx(0x0001E0D7, "XDTS_BRAKE_KE_BRAKE_OFF_WITH_DECEL_LIMIT", nameFlags);
MakeRptCmt(0x0001E0D7, "Number of deceleration events with the brake not depressed above which the brake switch stuck off malfunction will be set.\nCounts");
MakeNameEx(0x0001E0D8, "XDTS_BRAKE_KE_BRAKE_OFF_PASS_COUNT", nameFlags);
MakeRptCmt(0x0001E0D8, "Number of valid pass cycles before a pass condition is accepted for the brake switch stuck off test.\nCounts");
MakeNameEx(0x0001E0D9, "XDTS_BRAKE_KE_BRAKE_ON_PASS_COUNT", nameFlags);
MakeRptCmt(0x0001E0D9, "Number of valid pass cycles before a pass condition is accepted for the brake switch stuck on test.\nCounts");
MakeNameEx(0x0001E0DA, "XDTS_BRAKE_KE_BRAKE_ON_FAIL_TIME_LIMIT", nameFlags);
MakeRptCmt(0x0001E0DA, "Amount of time that the brake switch stuck on test must fail before the accelerationcycle counter is reset.\nSeconds");
MakeNameEx(0x0001E0DE, "XDTS_INPT_SPD_SENSOR_KE_IN_SPD_DIAG_OUT_SPD_THRESH", nameFlags);
MakeRptCmt(0x0001E0DE, "Vehicle speed threshold above which input speed diagnostic is enabled.\nMPH");
MakeNameEx(0x0001E0E0, "XDTS_INPT_SPD_SENSOR_KE_INPUT_SPEED_LOW_THRESH", nameFlags);
MakeRptCmt(0x0001E0E0, "Input speed threshold below which a diagnostic fault is enabled.\nRPM");
MakeNameEx(0x0001E0E2, "XDTS_INPT_SPD_SENSOR_KE_INPUT_SPEED_LOW_TIME", nameFlags);
MakeRptCmt(0x0001E0E2, "Amount of time input speed must be below the threshold in order to set malfunction.\nSeconds.");
MakeNameEx(0x0001E0E4, "XDTS_INPT_SPD_SENSOR_KE_INPUT_SPEED_HIGH_THRESH", nameFlags);
MakeRptCmt(0x0001E0E4, "Input speed threshold above which a diagnostic fault is cleared.\nRPM");
MakeNameEx(0x0001E0E6, "XDTS_INPT_SPD_SENSOR_KE_INPUT_SPEED_HIGH_TIME", nameFlags);
MakeRptCmt(0x0001E0E6, "Amount of time input speed must be above the threshold in order to clear malfunction.\nSeconds.");
MakeNameEx(0x0001E0E8, "XDTS_INPT_SPD_SENSOR_KE_INPUT_SPEED_DELTA_TIME_FAIL", nameFlags);
MakeRptCmt(0x0001E0E8, "Amount of time there must be a drop in the input speed for a failure to be reported.\nSeconds.");
MakeNameEx(0x0001E0EA, "XDTS_INPT_SPD_SENSOR_KE_INPUT_SPEED_PERF_TIME_PASS", nameFlags);
MakeRptCmt(0x0001E0EA, "Amount of time pass condition  for input speed sensor         performance must be valid      before a PASS is reported.\nSeconds.");
MakeNameEx(0x0001E0EC, "XDTS_INPT_SPD_SENSOR_KE_INPUT_SPEED_PERF_PASS_THRESH", nameFlags);
MakeRptCmt(0x0001E0EC, "Input speed must be above this threshold for a period of time for the PASS test to be valid.\nRPM");
MakeNameEx(0x0001E0EE, "XDTS_INPT_SPD_SENSOR_KE_INPUT_SPEED_PERF_DELTA_FAIL", nameFlags);
MakeRptCmt(0x0001E0EE, "The drop in input speed must be above this for a period of time for a failure to be reported.\nRPM");
MakeNameEx(0x0001E0F0, "XDTS_INPT_SPD_SENSOR_KE_INPUT_SPEED_PERF_DELTA_PASS", nameFlags);
MakeRptCmt(0x0001E0F0, "The drop in input speed must be below this for a period of time for a pass to be reported.\nRPM");
MakeNameEx(0x0001E0F2, "XDTS_INPT_SPD_SENSOR_KE_INPUT_SPEED_PERF_MPH_THRESH", nameFlags);
MakeRptCmt(0x0001E0F2, "Vehicle speed must be above this threshold for the input speed sensor performance fail test to be enabled.\nMPH");
MakeNameEx(0x0001E0F4, "XDTS_INPT_SPD_SENSOR_KE_INPUT_SPEED_PERF_THR_THRESH", nameFlags);
MakeRptCmt(0x0001E0F4, "Throttle position must be above this threshold for the input speed sensor performance fail test to be enabled.\nPercent");
MakeNameEx(0x0001E0F6, "XDTS_OUTPT_SPD_SENSOR_KE_OUT_SPD_LOSS_IN_PN_FAIL", nameFlags);
MakeRptCmt(0x0001E0F6, "Change in transmission output shaft speed above which will trigger output speed loss diagnostic in park or neutral\nRPM");
MakeNameEx(0x0001E0F8, "XDTS_OUTPT_SPD_SENSOR_KE_OUT_SPD_LOSS_NOT_PN_FAIL", nameFlags);
MakeRptCmt(0x0001E0F8, "Change in transmission output shaft speed above which will trigger output speed loss diagnostic when not in park or neutral\nRPM");
MakeNameEx(0x0001E0FA, "XDTS_OUTPT_SPD_SENSOR_KE_OUT_SPD_LOSS_TIME_FL_PN", nameFlags);
MakeNameEx(0x0001E0FC, "XDTS_OUTPT_SPD_SENSOR_KE_OUT_SPD_LOSS_TIME_FL_NOTPN", nameFlags);
MakeNameEx(0x0001E0FE, "XDTS_OUTPT_SPD_SENSOR_KE_OUT_SPD_LOSS_RANGE_CHG_TIME", nameFlags);
MakeRptCmt(0x0001E0FE, "Amount of time since the last change in transmission range status before the output speed loss diagnostic is enabled\nSeconds");
MakeNameEx(0x0001E100, "XDTS_OUTPT_SPD_SENSOR_KE_OUT_SPD_LOSS_TIME_PASS", nameFlags);
MakeRptCmt(0x0001E100, "Amount of time the change in output speed must meet the pass conditions before the output speed loss diagnostic is passed\nSeconds");
MakeNameEx(0x0001E102, "XDTS_OUTPT_SPD_SENSOR_KE_OUT_SPD_LOSS_MPH_PASS", nameFlags);
MakeRptCmt(0x0001E102, "Change in transmission output shaft speed below which the output speed loss diagnostic will be passed\nRPM");
MakeNameEx(0x0001E104, "XDTS_OUTPT_SPD_SENSOR_KE_OUT_SPD_LOSS_MPH_UNFIL", nameFlags);
MakeRptCmt(0x0001E104, "Unfiltered output shaft speed above which the output speed loss diagnostic will be passed\nRPM");
MakeNameEx(0x0001E106, "XDTS_OUTPT_SPD_SENSOR_KE_MAX_ALLOWED_POS_OUT_SPD_CHG", nameFlags);
MakeRptCmt(0x0001E106, "Maximum positive change in output speed over one loop that will still allow the  output speed loss test to run\nRPM");
MakeNameEx(0x0001E108, "XDTS_OUTPT_SPD_SENSOR_KE_OUT_SPD_TEST_DELAY_TIME", nameFlags);
MakeRptCmt(0x0001E108, "Amount of time to delay the Output Speed loss test after a Positive output speed  spike has occured\nSeconds");
MakeNameEx(0x0001E10A, "XDTS_OUTPT_SPD_SENSOR_KE_TIME_SINCE_4WDL_STATE_CHANGE", nameFlags);
MakeRptCmt(0x0001E10A, "Enables the diagnostic if the time since the four wheel drive low state change is  greater than this calibration.\nSeconds");
MakeNameEx(0x0001E10C, "XDTS_OUTPT_SPD_SENSOR_KE_OUT_SPD_LOW_IN_SPD_THRESH", nameFlags);
MakeRptCmt(0x0001E10C, "Amount of engine or input speed (depending on the application) below which the output speed low diagnostic is disabled\nRPM");
MakeNameEx(0x0001E10E, "XDTS_OUTPT_SPD_SENSOR_KE_OUT_SPD_LOW_VAC_HIGH_THRESH", nameFlags);
MakeRptCmt(0x0001E10E, "Amount of engine vacuum above which the output speed low diagnostic is disabled\nKPA");
MakeNameEx(0x0001E10F, "XDTS_OUTPT_SPD_SENSOR_KE_OUT_SPD_LOW_VAC_LOW_THRESH", nameFlags);
MakeRptCmt(0x0001E10F, "Amount of engine vacuum below which the output speed low diagnostic is disabled\nKPA");
MakeNameEx(0x0001E110, "XDTS_OUTPT_SPD_SENSOR_KE_OUT_SPD_LOW_THROTTLE_THRESH", nameFlags);
MakeRptCmt(0x0001E110, "Amount of throttle position below which output speed low diagnostic is disabled\nPercent");
MakeNameEx(0x0001E112, "XDTS_OUTPT_SPD_SENSOR_KE_OUT_SPD_LOW_THRESHOLD_FAIL", nameFlags);
MakeRptCmt(0x0001E112, "Amount of transmission output shaft speed below which output speed low diagnostic will fail\nRPM");
MakeNameEx(0x0001E114, "XDTS_OUTPT_SPD_SENSOR_KE_OUT_SPD_LOW_THRESHOLD_PASS", nameFlags);
MakeRptCmt(0x0001E114, "Amount of transmission output shaft speed above which output speed low diagnostic will pass\nRPM");
MakeNameEx(0x0001E116, "XDTS_OUTPT_SPD_SENSOR_KE_OUT_SPD_LOW_TIME_FAIL", nameFlags);
MakeRptCmt(0x0001E116, "Amount of time output speed is below the low threshold before the output speed low diagnostic is enabled\nSeconds");
MakeNameEx(0x0001E118, "XDTS_OUTPT_SPD_SENSOR_KE_OUT_SPD_LOW_TIME_PASS", nameFlags);
MakeRptCmt(0x0001E118, "Amount of time output speed is above the low threshold before the output speed low diagnostic is passed\nSeconds");
MakeNameEx(0x0001E11A, "XDTS_OUTPT_SPD_SENSOR_KE_OUT_SPD_LOW_ETORQUE_LOW", nameFlags);
MakeRptCmt(0x0001E11A, "Amount of engine torque below which the output speed low diagnostic is disabled\nFt_lb");
MakeNameEx(0x0001E11C, "XDTS_OUTPT_SPD_SENSOR_KE_OUT_SPD_LOW_ETORQUE_HIGH", nameFlags);
MakeRptCmt(0x0001E11C, "Amount of engine torque above which the output speed low diagnostic is disabled\nFt_lb");
MakeNameEx(0x0001E11E, "XDTS_RANGE_KE_ILLEGAL_RANGE_STATUS_TIME", nameFlags);
MakeRptCmt(0x0001E11E, "Amount of time an illegal range status must be seenbefore the diagnostic fault is set\nSeconds");
MakeNameEx(0x0001E120, "XDTS_RANGE_KE_ILLEGAL_P_N_FAIL_TIME", nameFlags);
MakeRptCmt(0x0001E120, "Amount of time an illegal PSA state must be seen before the diagnostic fault is set\nSeconds");
MakeNameEx(0x0001E122, "XDTS_RANGE_KE_ILLEGAL_P_N_PASS_TIME", nameFlags);
MakeRptCmt(0x0001E122, "Amount of time an legal PSA state must be seen before the diagnostic pass is set\nSeconds");
MakeNameEx(0x0001E124, "XDTS_RANGE_KE_DIAG_SPEED_RATIO_RANGE_HIGH", nameFlags);
MakeRptCmt(0x0001E124, "Ratio below which illegal park/neutral test is enabled.\nRatio");
MakeNameEx(0x0001E126, "XDTS_RANGE_KE_DIAG_SPEED_RATIO_RANGE_LOW", nameFlags);
MakeRptCmt(0x0001E126, "Ratio above which illegal park/neutral test is enabled.\nRatio");
MakeNameEx(0x0001E128, "XDTS_RANGE_KE_PSM_FAULT_ENG_SPD_LOW_THRESH", nameFlags);
MakeRptCmt(0x0001E128, "Engine speed low threshold above which illegal drive_2 test is enabled.\nRPM");
MakeNameEx(0x0001E12A, "XDTS_RANGE_KE_PSM_FAULT_ENG_SPD_HIGH_THRESH", nameFlags);
MakeRptCmt(0x0001E12A, "Engine speed high threshold below which illegal drive_2 test is enabled.\nRPM");
MakeNameEx(0x0001E12C, "XDTS_RANGE_KE_PSM_FAULT_MPH_THRESH", nameFlags);
MakeRptCmt(0x0001E12C, "Vehicle speed threshold below which illegal drive_2 test is enabled.\nMPH");
MakeNameEx(0x0001E12E, "XDTS_RANGE_KE_PSM_FAULT_INPUT_SPD_THRESH", nameFlags);
MakeRptCmt(0x0001E12E, "Input speed threshold above which illegal drive_2 test is enabled.\nRPM");
MakeNameEx(0x0001E130, "XDTS_RANGE_KE_PSM_FAULT_TPS_LOW_THRESH", nameFlags);
MakeRptCmt(0x0001E130, "Low threshold throttle position for pressureswitch assembly diagnostic test.\nPercent");
MakeNameEx(0x0001E132, "XDTS_RANGE_KE_PSM_FAULT_TPS_HIGH_THRESH", nameFlags);
MakeRptCmt(0x0001E132, "High threshold throttle position for pressureswitch assembly diagnostic test.\nPercent");
MakeNameEx(0x0001E134, "XDTS_RANGE_KE_PSM_ENG_SPD_FAIL_TIMER_LIMIT", nameFlags);
MakeRptCmt(0x0001E134, "Amount of time an illegal PSM state must be seen before diagnostic Fail shall be set\nSeconds");
MakeNameEx(0x0001E136, "XDTS_RANGE_KE_PSM_ENG_SPD_PASS_TIMER_LIMIT", nameFlags);
MakeRptCmt(0x0001E136, "Amount of time an illegal PSM state must be seen before diagnostic Pass shall be set\nSeconds");
MakeNameEx(0x0001E138, "XDTS_RANGE_KE_PSM_FAULT_ENG_SPD_LOW_TIME", nameFlags);
MakeRptCmt(0x0001E138, "A timer limit for Engine_Speed to be below a threshold. Is used by the PSM diagnostic for the illegal drive2 determination.\nSeconds");
MakeNameEx(0x0001E13A, "XDTS_RANGE_KE_PSM_FAULT_ENG_SPD_MED_TIME", nameFlags);
MakeRptCmt(0x0001E13A, "A timer limit for Engine_Speed to be between two thresholds Is used by the PSM diagnostic for the illegal drive2 determination.\nSeconds");
MakeNameEx(0x0001E13C, "XDTS_RANGE_KE_PSA_MPH_OUTPUT_SPEED", nameFlags);
MakeRptCmt(0x0001E13C, "Vehicle speed in MPH greater than this valueto enable case three of the pressure switchassembly test\nMPH");
MakeNameEx(0x0001E13E, "XDTS_RANGE_KE_PSA_OUT_SPD_THROTTLE_THRESH", nameFlags);
MakeRptCmt(0x0001E13E, "Throttle greater than this valueto enable case three of the pressure switchassembly test\nPercent");
MakeNameEx(0x0001E140, "XDTS_RANGE_KE_PSM_FAULT_ENG_TRQ_LOW_THRESH", nameFlags);
MakeRptCmt(0x0001E140, "Low threshold engine torque for pressureswitch assembly diagnostic test.\nFt_lb");
MakeNameEx(0x0001E142, "XDTS_RANGE_KE_PSM_FAULT_ENG_TRQ_HIGH_THRESH", nameFlags);
MakeRptCmt(0x0001E142, "High threshold engine torque for pressureswitch assembly diagnostic test.\nFt_lb");
MakeNameEx(0x0001E144, "XDTS_RANGE_KE_PSM_FAULT_ENG_VAC_LOW_THRESH", nameFlags);
MakeRptCmt(0x0001E144, "Low threshold manifold pressure for pressureswitch assembly diagnostic test.\nKPA");
MakeNameEx(0x0001E145, "XDTS_RANGE_KE_PSM_FAULT_ENG_VAC_HIGH_THRESH", nameFlags);
MakeRptCmt(0x0001E145, "High threshold manifold pressure for pressureswitch assembly diagnostic test.\nKPA");
MakeNameEx(0x0001E146, "XDTS_RANGE_KE_PSA_RATIO_IN_PARK_NEUTRAL", nameFlags);
MakeRptCmt(0x0001E146, "Ratio value used to check low or high ratioin park or neutral range.\nNONE");
MakeNameEx(0x0001E148, "XDTS_RANGE_KE_PSA_LW_RAT_PARK_NEUTRAL_TIME", nameFlags);
MakeRptCmt(0x0001E148, "Amount of Time used to check transmission range inpark or neutral with low gear ratio.\nSeconds");
MakeNameEx(0x0001E14A, "XDTS_RANGE_KE_PSA_HGH_RAT_PARK_NEUTRAL_TIME", nameFlags);
MakeRptCmt(0x0001E14A, "Amount of Time used to check transmission range inpark or neutral with hhgh gear ratio.\nSeconds");
MakeNameEx(0x0001E14C, "XDTS_RANGE_KE_PSA_REVERSE_RATIO_LOW", nameFlags);
MakeRptCmt(0x0001E14C, "Low limit gear ratio used in transmissiondrivable range check.\nNONE");
MakeNameEx(0x0001E14E, "XDTS_RANGE_KE_PSA_REVERSE_RATIO_HIGH", nameFlags);
MakeRptCmt(0x0001E14E, "High limit gear ratio used in transmissiondrivable range check.\nNONE");
MakeNameEx(0x0001E150, "XDTS_RANGE_KE_PSA_REV_RATIO_FAIL_TIME", nameFlags);
MakeRptCmt(0x0001E150, "Amount of Time used to check transmission range inreverse with gear ratio either low or high\nSeconds");
MakeNameEx(0x0001E152, "XDTS_RANGE_KE_PSA_REV_RATIO_PASS_TIME", nameFlags);
MakeRptCmt(0x0001E152, "Amount of Time used to check transmission range inreverse with gear ratio between low and high\nSeconds");
MakeNameEx(0x0001E154, "XDTS_RANGE_KE_PSA_DRIVE_RANGE_LOW_FAIL", nameFlags);
MakeRptCmt(0x0001E154, "Low limit gear ratio used in transmissiondrivable range check.\nNONE");
MakeNameEx(0x0001E156, "XDTS_RANGE_KE_PSA_DRIVE_RANGE_HIGH_FAIL", nameFlags);
MakeRptCmt(0x0001E156, "High limit gear ratio used in transmissiondrivable range check.\nNONE");
MakeNameEx(0x0001E158, "XDTS_RANGE_KE_PSA_DRIVE_RANGE_LOW_PASS", nameFlags);
MakeRptCmt(0x0001E158, "Low limit gear ratio used in transmissiondrivable range check.\nNONE");
MakeNameEx(0x0001E15A, "XDTS_RANGE_KE_PSA_DRIVE_RANGE_HIGH_PASS", nameFlags);
MakeRptCmt(0x0001E15A, "Low limit gear ratio used in transmissiondrivable range check.\nNONE");
MakeNameEx(0x0001E15C, "XDTS_RANGE_KE_PSA_PASS_DRIVE_RANGE_TIME", nameFlags);
MakeRptCmt(0x0001E15C, "Amount of Time used to check transmission range inDrive with gear ratio between low and high\nSeconds");
MakeNameEx(0x0001E15E, "XDTS_RANGE_KE_PSA_FAIL_DRIVE_RANGE_TIME", nameFlags);
MakeRptCmt(0x0001E15E, "Amount of Time used to check transmission range inDrive with gear ratio at low or high\nSeconds");
MakeNameEx(0x0001E160, "XDTS_RANGE_KE_PSA_REV_RATIO_1ST_GEAR_LOW", nameFlags);
MakeRptCmt(0x0001E160, "Lowlimit for 1st gear ratio used in transmissiondrivable range check while in reverse\nNONE");
MakeNameEx(0x0001E162, "XDTS_RANGE_KE_PSA_REV_RATIO_1ST_GEAR_HIGH", nameFlags);
MakeRptCmt(0x0001E162, "Highlimit for 1st gear ratio used in transmissiondrivable range check while in reverse\nNONE");
MakeNameEx(0x0001E164, "XDTS_RANGE_KE_PSA_REV_RATIO_2ND_GEAR_LOW", nameFlags);
MakeRptCmt(0x0001E164, "Lowlimit for 2nd gear ratio used in transmissiondrivable range check while in reverse\nNONE");
MakeNameEx(0x0001E166, "XDTS_RANGE_KE_PSA_REV_RATIO_2ND_GEAR_HIGH", nameFlags);
MakeRptCmt(0x0001E166, "Highlimit for 2nd gear ratio used in transmissiondrivable range check while in reverse\nNONE");
MakeNameEx(0x0001E168, "XDTS_RANGE_KE_PSA_REV_RATIO_3RD_GEAR_LOW", nameFlags);
MakeRptCmt(0x0001E168, "Lowlimit for 3rd gear ratio used in transmissiondrivable range check while in reverse\nNONE");
MakeNameEx(0x0001E16A, "XDTS_RANGE_KE_PSA_REV_RATIO_3RD_GEAR_HIGH", nameFlags);
MakeRptCmt(0x0001E16A, "Highlimit for 3rd gear ratio used in transmissiondrivable range check while in reverse\nNONE");
MakeNameEx(0x0001E16C, "XDTS_RANGE_KE_PSA_REV_RATIO_4TH_GEAR_LOW", nameFlags);
MakeRptCmt(0x0001E16C, "Lowlimit for 4th gear ratio used in transmissiondrivable range check while in reverse\nNONE");
MakeNameEx(0x0001E16E, "XDTS_RANGE_KE_PSA_REV_RATIO_4TH_GEAR_HIGH", nameFlags);
MakeRptCmt(0x0001E16E, "Highlimit for 4th gear ratio used in transmissiondrivable range check while in reverse\nNONE");
MakeNameEx(0x0001E170, "XDTS_RANGE_KE_PSM_NOISS_VOLT_FAULT_TIME", nameFlags);
MakeNameEx(0x0001E172, "XDTS_RANGE_KE_PSA_WISS_VOLT_FAULT_TIME", nameFlags);
MakeRptCmt(0x0001E172, "Pressure switch assembly with input speed sensor will not be tested if ignition voltage is out of range for longer than this.\nSeconds");
MakeNameEx(0x0001E174, "XDTS_RANGE_KE_PSA_IMS_NUMBER", nameFlags);
MakeRptCmt(0x0001E174, "Comparison for diagnostic P1527 pass or fail.\nIMS Number");
MakeNameEx(0x0001E176, "XDTS_RANGE_KV_PSA_IMS_AGE_FACTOR", nameFlags);
MakeRptCmt(0x0001E176, "Multiplying factor based on engine miles.\nScaler");
MakeNameEx(0x0001E180, "XDTS_RANGE_KE_TOP_RANGE_MULTIPLIER", nameFlags);
MakeRptCmt(0x0001E180, "Multiplier for the Top Range Counter used in PSA/IMS comparison diagnostic.\nIMS Number");
MakeNameEx(0x0001E181, "XDTS_RANGE_KE_DG_IGN_VOLTAGE_LOW_THRSH", nameFlags);
MakeRptCmt(0x0001E181, "Lower limit for the system voltage for the PSA/IMS comparison diagnostic.\nVolts");
MakeNameEx(0x0001E182, "XDTS_RANGE_KE_DG_IGN_VOLTAGE_HIGH_THRSH", nameFlags);
MakeRptCmt(0x0001E182, "Upper limit for the system voltage for the PSA/IMS comparison diagnostic.\nVolts");
MakeNameEx(0x0001E184, "XDTS_RANGE_KE_PSA_IMS_GENERAL_TIME", nameFlags);
MakeRptCmt(0x0001E184, "Upper limit for the PSA/IMS mismatch time.\nSeconds");
MakeNameEx(0x0001E186, "XDTS_RANGE_KE_PSA_IMS_TOP_RANGE_TIME", nameFlags);
MakeRptCmt(0x0001E186, "Upper limit for the PSA/IMS mismatch time when one of them indicates Drive 4.\nSeconds");
MakeNameEx(0x0001E188, "XDTS_RANGE_KE_PSA_F_IMS_ODD_TIME", nameFlags);
MakeRptCmt(0x0001E188, "Upper limit for the PSA/IMS mismatch time during a garage shift window.\nSeconds");
MakeNameEx(0x0001E18A, "XDTS_RANGE_KE_PSA_IMS_GS_WINDOW_TIME", nameFlags);
MakeRptCmt(0x0001E18A, "Time before and after a new garage shift that constitutes a garage shift window.\nSeconds");
MakeNameEx(0x0001E18C, "XDTS_RANGE_KE_DIAG_PSA_SYS_VOLT_TIME", nameFlags);
MakeRptCmt(0x0001E18C, "If ignition voltage is out of range for a time greater than this, do not test Pressure Switch Assembly Engine Speed Transition.\nSeconds");
MakeNameEx(0x0001E18E, "XDTS_TCC_REL_SWCH_KE_TCC_REL_SW_DIAG_TIME_PASS", nameFlags);
MakeRptCmt(0x0001E18E, "Pass time for TCC stuck off while TCC  is being commanded ON.\nSeconds");
MakeNameEx(0x0001E190, "XDTS_TCC_REL_SWCH_KE_TCC_REL_SW_DIAG_TIME_FAIL", nameFlags);
MakeRptCmt(0x0001E190, "Fail time for TCC stuck off while TCC  is being commanded ON.\nSeconds");
MakeNameEx(0x0001E192, "XDTS_TCC_REL_SWCH_KE_TCC_REL_SW_SLIP_LOW", nameFlags);
MakeRptCmt(0x0001E192, "TCC slip low threshold value to enable TCC stuck off  while TCC is being commanded ON.- TCC Release switch circuit malfunction\nRPM_S");
MakeNameEx(0x0001E194, "XDTS_TCC_REL_SWCH_KE_TCC_REL_SW_SLIP_HIGH", nameFlags);
MakeRptCmt(0x0001E194, "TCC slip high threshold value to enable TCC stuck off  while TCC is being commanded ON.\nRPM_S");
MakeNameEx(0x0001E196, "XDTS_TCC_REL_SWCH_KE_TCC_REL_SW_ENGINE_TORQUE_HIGH", nameFlags);
MakeRptCmt(0x0001E196, "High enable threshold to run rel sw diag for TCC stuck off when commanded on.\nFt_Lb");
MakeNameEx(0x0001E198, "XDTS_TCC_REL_SWCH_KE_TCC_REL_SW_ENGINE_TORQUE_LOW", nameFlags);
MakeRptCmt(0x0001E198, "Low enable threshold to run rel sw diag for TCC stuck off when commanded on.\nFt_Lb");
MakeNameEx(0x0001E19A, "XDTS_TCC_REL_SWCH_KE_TCC_REL_FAIL_COUNTER", nameFlags);
MakeRptCmt(0x0001E19A, "TCC Stuck off while being commanded on fail counter - TCC release switch diag.\nCounts");
MakeNameEx(0x0001E19C, "XDTS_TCC_REL_SWCH_KE_TCC_REL_SW_TCC_PRESSURE_HIGH", nameFlags);
MakeRptCmt(0x0001E19C, "Low threshold to run TCC stuck off when being commanded on - TCC release switch diag.\nPSI");
MakeNameEx(0x0001E19E, "XDTS_TCC_REL_SWCH_KE_TCC_REL_SW_TCC_PRESSURE_LOW", nameFlags);
MakeRptCmt(0x0001E19E, "High threshold to run TCC stuck off when being commanded on - TCC release switch diag.\nPSI");
MakeNameEx(0x0001E1A0, "XDTS_TEMP_KE_TRANS_TEMP_SENSOR_VOLT_HIGH", nameFlags);
MakeRptCmt(0x0001E1A0, "High limit for transmission temperature sensor voltage above which the diagnostic fault is set\nA/D Counts");
MakeNameEx(0x0001E1A1, "XDTS_TEMP_KE_TRANS_TEMP_SENSOR_VOLTAGE_LOW", nameFlags);
MakeRptCmt(0x0001E1A1, "Low limit for transmission temperature sensor voltage below which the diagnostic fault is set\nA/D Counts");
MakeNameEx(0x0001E1A2, "XDTS_TEMP_KE_TRANS_TEMP_SENSOR_HIGH_TIME", nameFlags);
MakeRptCmt(0x0001E1A2, "Amount of time transmission sensor voltage must be above high limit before the diagnostic fault is set\nSeconds");
MakeNameEx(0x0001E1A4, "XDTS_TEMP_KE_TRANS_TEMP_SENSOR_LOW_TIME", nameFlags);
MakeRptCmt(0x0001E1A4, "Amount of time transmission sensor voltage must be below low limit before the diagnostic fault is set\nSeconds");
MakeNameEx(0x0001E1A6, "XDTS_TEMP_KE_TTS_HIGH_VOLT_FAULT_TIME", nameFlags);
MakeRptCmt(0x0001E1A6, "Transmission fluid temperature sensor circuit high will not be tested if ignition voltage is out of range for longer than this.\nSeconds");
MakeNameEx(0x0001E1A8, "XDTS_TEMP_KE_TTS_LOW_VOLT_FAULT_TIME", nameFlags);
MakeRptCmt(0x0001E1A8, "Transmission fluid temperature sensor circuit low will not be tested if ignition voltage is out of range for longer than this.\nSeconds");
MakeNameEx(0x0001E1B0, "FUELCALIBRATIONS_HEADER", nameFlags);
MakeRptCmt(0x0001E1B0, "Use this cal to identify the Fuel Systems calibration\nCal_ID_Record");
MakeNameEx(0x0001E1CC, "F_TANK_KE_FUEL_TANK_VACUUM_OFFSET", nameFlags);
MakeRptCmt(0x0001E1CC, "The y-intercept for the tank vacuum AD counts to inches water equation.\nInches H2O");
MakeNameEx(0x0001E1CE, "F_TANK_KE_GAGE_TO_ZERO_ON_PUMP_FAULT", nameFlags);
MakeRptCmt(0x0001E1CE, "Bit selectable cal to force the PWM Fuel Level output to zero when a secondary fuel pump fault is present.\nBOOLEAN");
MakeNameEx(0x0001E1D0, "F_TANK_KE_FUEL_TANK_RATED_CAPACITY", nameFlags);
MakeRptCmt(0x0001E1D0, "Maximum Fuel Tank volume as rated by GMUTS and/or the platform.\nLiters");
MakeNameEx(0x0001E1D2, "F_TANK_KE_FUEL_SYSTEM_USES_PULLUP_RESIS", nameFlags);
MakeRptCmt(0x0001E1D2, "Determines whether to acitvate or de-activate the transistor to which allows the pullup resistor to be on or off.\nTRUE/FALSE");
MakeNameEx(0x0001E1D4, "F_TANK_KE_FUEL_TANK_RATED_CAPACITY_GAGE", nameFlags);
MakeRptCmt(0x0001E1D4, "Maximum Fuel Tank volume as rated by GMUTS and/or the platform.\nLiters");
MakeNameEx(0x0001E1D6, "F_TANK_KE_VSS_XFER_PUMP", nameFlags);
MakeRptCmt(0x0001E1D6, "Maximum value of vehicle speed that the secondary transfer pump will be diagnosed.\nMPH");
MakeNameEx(0x0001E1D8, "F_TANK_KE_FUEL_GAGE_PWM_MIN", nameFlags);
MakeRptCmt(0x0001E1D8, "Minimum value allowed for fuel gage PWM signal.\nPercent");
MakeNameEx(0x0001E1DA, "F_TANK_KE_FUEL_GAGE_PWM_MAX", nameFlags);
MakeRptCmt(0x0001E1DA, "Maximum value allowed for fuel gage PWM signal.\nPercent");
MakeNameEx(0x0001E1DC, "F_TANK_KE_PRIMARY_TANK_RATED_CAPACITY", nameFlags);
MakeRptCmt(0x0001E1DC, "Volume to which the primary tank is considered Full.\nLiters");
MakeNameEx(0x0001E1DE, "F_TANK_KE_PRI_TANK_RATED_CAPACITY_GAGE", nameFlags);
MakeRptCmt(0x0001E1DE, "Volume to which the primary tank is considered Full for purposes of the fuel gage.\nLiters");
MakeNameEx(0x0001E1E0, "F_TANK_KE_GRAVITY_FUEL_FILL", nameFlags);
MakeRptCmt(0x0001E1E0, "Threshold in the secondary tank which determine the spill over level into the primary tank.\nLiters");
MakeNameEx(0x0001E1E2, "F_TANK_KE_PRIMARY_TANK_HIGH_XFER_LEVEL", nameFlags);
MakeRptCmt(0x0001E1E2, "Volume in primary tank at which point the secondary transfer pump will be requested off after a calibratable time.\nLiters");
MakeNameEx(0x0001E1E4, "F_TANK_KE_SECONDARY_TANK_ZONE1_5_THRESH", nameFlags);
MakeNameEx(0x0001E1E6, "F_TANK_KV_FUEL_LEVEL_TO_PWM_FOR_GAGE", nameFlags);
MakeRptCmt(0x0001E1E6, "Table to convert fuel level to PWM duty cycleto drive a fuel gage in the cluster.\nPercent");
MakeNameEx(0x0001E1FC, "F_TANK_KE_FUEL_SENDER_UNIT_TYPE", nameFlags);
MakeRptCmt(0x0001E1FC, "This calibration defines if the 5V or the 12V fuel tank level sensor is wired to the PCM.\nSenderType");
MakeNameEx(0x0001E1FE, "F_TANK_KE_FUEL_LEVEL_INPUT_DELAY", nameFlags);
MakeRptCmt(0x0001E1FE, "The minimum amount of time to delay a valid fuel level reading.\nSeconds");
MakeNameEx(0x0001E200, "F_TANK_KE_PRIMARY_TANK_TOO_FULL_TIME", nameFlags);
MakeRptCmt(0x0001E200, "Time which the primary fuel level must remain above the threshold to turn off the xfer pump.\nSeconds");
MakeNameEx(0x0001E202, "F_TANK_KE_FUEL_LEVEL_UPPER_FAULTS", nameFlags);
MakeNameEx(0x0001E203, "F_TANK_KE_FUEL_LEVEL_LOWER_FAULTS", nameFlags);
MakeNameEx(0x0001E204, "F_TANK_KE_FUEL_LEVEL_PULSE_OFF_CTS_ETH", nameFlags);
MakeNameEx(0x0001E205, "F_TANK_KE_FUEL_LEVEL_PULSE_OFF_CTS_EVP", nameFlags);
MakeNameEx(0x0001E206, "F_TANK_KE_FUEL_LEVEL_PULSE_ETHANOL_HI", nameFlags);
MakeNameEx(0x0001E208, "F_TANK_KE_FUEL_LEVEL_PULSE_ETHANOL_LO", nameFlags);
MakeNameEx(0x0001E20A, "F_TANK_KE_FUEL_LEVEL_AD_HIGH_LIMIT", nameFlags);
MakeRptCmt(0x0001E20A, "If the fuel level reading is equal to or above this value then it is considered a fault.\nA/D Counts");
MakeNameEx(0x0001E20B, "F_TANK_KE_FUEL_LEVEL_AD_LOW_LIMIT", nameFlags);
MakeRptCmt(0x0001E20B, "If the fuel level reading is equal to or below this value then it is considered a fault.\nA/D Counts");
MakeNameEx(0x0001E20C, "F_TANK_KV_CONVERT_PRIMARY_FUEL_LEVEL_TO", nameFlags);
MakeRptCmt(0x0001E20C, "Converts fuel level sender AD counts to liters.\nLiters");
MakeNameEx(0x0001E30E, "F_TANK_KV_CONVERT_SECONDARY_FUEL_LEVEL_", nameFlags);
MakeRptCmt(0x0001E30E, "Converts fuel level sender AD counts to liters.\nLiters");
MakeNameEx(0x0001E410, "F_TANK_KV_PRI_FUEL_LEVEL_TO_VOL_GAGE", nameFlags);
MakeRptCmt(0x0001E410, "Converts fuel level sender AD counts to liters for display on the fuel gage.\nLiters");
MakeNameEx(0x0001E512, "F_TANK_KV_SEC_FUEL_LEVEL_TO_VOL_GAGE", nameFlags);
MakeRptCmt(0x0001E512, "Converts fuel level sender AD counts to liters for the secondary tank for display on the fuel gage.\nLiters");
MakeNameEx(0x0001E614, "F_TANK_KV_TRANSFER_PUMP_TIME_LIMIT", nameFlags);
MakeRptCmt(0x0001E614, "Maximum amount of time the transfer pump can be on continuously without burning up.\nSeconds_L");
MakeNameEx(0x0001E67C, "F_TANK_KV_FUEL_VAPOR_TEMPERATURE", nameFlags);
MakeRptCmt(0x0001E67C, "Used to linearize and scale the raw A/D fuel tank vapor temperature sensor.\nDegrees_C");
MakeNameEx(0x0001E69E, "F_TANK_KE_PRIMARY_TANK_FULL_THRESHOLD", nameFlags);
MakeRptCmt(0x0001E69E, "Threshold of _measurable_, usable fuel in the primary tank above which the primary tank is considered full.\nLiters");
MakeNameEx(0x0001E6A0, "F_TANK_KE_PRIMARY_TANK_PUMP_ON_LEVEL", nameFlags);
MakeNameEx(0x0001E6A2, "F_TANK_KE_SECONDARY_TANK_EMPTY_THRESHOL", nameFlags);
MakeRptCmt(0x0001E6A2, "Threshold of measurable, usable fuel in the secondary tank above which the secondary tank is considered full.\nLiters");
MakeNameEx(0x0001E6A4, "F_TANK_KE_SECONDARY_TANK_TRANSFER_THRES", nameFlags);
MakeRptCmt(0x0001E6A4, "Volume necessary in secondary tank to allow the transferpump to be turned on.\nLiters");
MakeNameEx(0x0001E6A6, "F_TANK_KE_SECONDARY_TANK_EMPTY_TIME", nameFlags);
MakeRptCmt(0x0001E6A6, "Time which the transfer pump has pumped the fuel in the secondary tank below the secondary empty threshold.\nSeconds");
MakeNameEx(0x0001E6A8, "F_TANK_KE_TRANSFER_PUMP_MIN_OFF_TIME", nameFlags);
MakeRptCmt(0x0001E6A8, "Timer to prevent the fuel pump from turning off and  turning right back on.\nSeconds");
MakeNameEx(0x0001E6AA, "F_TANK_KE_TRANSFER_PUMP_FUEL_LEVEL_DELT", nameFlags);
MakeRptCmt(0x0001E6AA, "Minimum level of change necessary to determine the senders are moving and the pump is working.\nLiters");
MakeNameEx(0x0001E6AC, "F_TANK_KE_TRANSFER_PUMP_FAIL_TIME", nameFlags);
MakeNameEx(0x0001E6AE, "F_TANK_KE_SLOSH_DELAY_XFER_PUMP_TIME", nameFlags);
MakeRptCmt(0x0001E6AE, "Amount of delay time to allow fuel slosh to relax before the transfer pump is diagnosed.\nSeconds");
MakeNameEx(0x0001E6B0, "F_TANK_KE_FUEL_LEVEL_CHANGE_STATE_TIME", nameFlags);
MakeRptCmt(0x0001E6B0, "Time sender readings must be in a new state before that new state's calculation method will be used.\nSeconds");
MakeNameEx(0x0001E6B2, "F_TANK_KE_FUEL_GAGE_NORMAL_FILTER", nameFlags);
MakeRptCmt(0x0001E6B2, "Lag filter time constant used to over-damp fuel gage movement.\nSeconds");
MakeNameEx(0x0001E6B4, "F_TANK_KE_FUEL_GAGE_FAST_FILL_FILTER", nameFlags);
MakeRptCmt(0x0001E6B4, "Lag filter time constant used to allow fast fuel gage movement during Fast Fill mode of gage operation.\nSeconds");
MakeNameEx(0x0001E6B6, "F_TANK_KE_FUEL_MAIN_TIME_CONSTANT", nameFlags);
MakeRptCmt(0x0001E6B6, "The main filter coefficient for fuel tank level.\nSeconds");
MakeNameEx(0x0001E6B8, "F_TANK_KE_FUEL_SLOSH_TIME_CONSTANT", nameFlags);
MakeRptCmt(0x0001E6B8, "Filter coefficient for both primary and secondary fuel levels used in slosh calculations.\nSeconds");
MakeNameEx(0x0001E6BA, "F_TANK_KE_FUEL_PRM_SLSH_THRSH_TIME_CNST", nameFlags);
MakeRptCmt(0x0001E6BA, "Filter coefficient for primary fuel tank levelused in slosh threshold lookup.\nSeconds");
MakeNameEx(0x0001E6BC, "F_TANK_KE_FUEL_SEC_SLSH_THRSH_TIME_CNST", nameFlags);
MakeRptCmt(0x0001E6BC, "Filter coefficient for secondary fuel tank levelused in slosh threshold lookup.\nSeconds");
MakeNameEx(0x0001E6BE, "F_TANK_KE_FUEL_LEVEL_DELTA", nameFlags);
MakeRptCmt(0x0001E6BE, "If the fuel level reading has not moved this amount for a given amount of accumulated miles then it is considered a fault.\nLiters");
MakeNameEx(0x0001E6C0, "F_TANK_KE_PRIMARY_SENDER_MIN_MILES", nameFlags);
MakeNameEx(0x0001E6C4, "F_TANK_KE_SECONDARY_SENDER_MIN_MILES", nameFlags);
MakeNameEx(0x0001E6C8, "F_TANK_KE_FUEL_SENDER_MIN_MILES_IN_DEAD", nameFlags);
MakeRptCmt(0x0001E6C8, "If the fuel tank level remains in deadband this amount of miles, the fuel sender is considered to be malfunctioning.\nMiles");
MakeNameEx(0x0001E6CC, "F_TANK_KE_FUEL_LEVEL_RATIONALITY_TIME_L", nameFlags);
MakeRptCmt(0x0001E6CC, "Time allowed for the fuel level readings to be inconsistant with reality.\nSeconds");
MakeNameEx(0x0001E6D0, "F_TANK_KE_REZERO_MIN_AD_COUNTS", nameFlags);
MakeRptCmt(0x0001E6D0, "Vacuum Sensor raw reading must be above this TO adjust the tank vacuum bias.\nAD_Counts 10bit");
MakeNameEx(0x0001E6D2, "F_TANK_KE_REZERO_MAX_AD_COUNTS", nameFlags);
MakeRptCmt(0x0001E6D2, "Vacuum Sensor raw reading must be below this TO adjust the tank vacuum bias.\nAD_Counts_10bit");
MakeNameEx(0x0001E6D4, "F_TANK_KE_SENSOR_WARMUP_TIME_MINIMUM", nameFlags);
MakeRptCmt(0x0001E6D4, "The minimum amount of time the vacuum sensor needs power applied before an accurate reading can be obtained.\nSeconds");
MakeNameEx(0x0001E6D6, "F_TANK_KE_FUEL_TANK_VACUUM_SCALE", nameFlags);
MakeRptCmt(0x0001E6D6, "The slope coefficient for the tank vacuum AD counts to inches water equation.\nScalar");
MakeNameEx(0x0001E6D8, "F_TANK_KE_VACUUM_SLOSH_TIME_CONSTANT", nameFlags);
MakeRptCmt(0x0001E6D8, "The filter coefficient for tank vacuum for fuel tank slosh determination.\nmillisecs.");
MakeNameEx(0x0001E6DA, "F_TANK_KE_VACUUM_MAIN_TIME_CONSTANT", nameFlags);
MakeRptCmt(0x0001E6DA, "The filter coefficient for tank vacuum.\nSeconds");
MakeNameEx(0x0001E6DC, "F_TANK_KE_HIGH_VACUUM_THRESHOLD", nameFlags);
MakeRptCmt(0x0001E6DC, "Enable the Tank Protection Mode when the tank vacuum is more negative than this value.\nInches H2O");
MakeNameEx(0x0001E6DE, "F_TANK_KE_LOW_VACUUM_THRESHOLD", nameFlags);
MakeRptCmt(0x0001E6DE, "Disable the Tank Protection Mode when the tank vacuum is less negative than this value.\nInches H2O");
MakeNameEx(0x0001E6E0, "F_TANK_KE_EXCESSIVE_VACUUM_COUNT_LIMIT", nameFlags);
MakeRptCmt(0x0001E6E0, "Enable the Tank Protection Mode when the number OF excessive tank vacuum samples exceeds this value.\ncount");
MakeNameEx(0x0001E6E1, "F_TANK_KE_NORMAL_VACUUM_COUNT_LIMIT", nameFlags);
MakeRptCmt(0x0001E6E1, "Disable the Tank Protection Mode when the total number OF tank vacuum samples exceeds this value.\ncount");
MakeNameEx(0x0001E6E2, "F_TANK_KE_TANK_VACUUM_RAW_MAX", nameFlags);
MakeRptCmt(0x0001E6E2, "Maximum tank vacuum reading indicating a valid tank vacuum sensor read.\nAD Counts 10bit");
MakeNameEx(0x0001E6E4, "F_TANK_KE_TANK_VACUUM_RAW_MIN", nameFlags);
MakeRptCmt(0x0001E6E4, "Minimum tank vacuum reading indicating a valid tank vacuum sensor read.\nAD Counts 10bit");
MakeNameEx(0x0001E6E6, "F_TANK_KE_FAST_FILL_RUN_TIME", nameFlags);
MakeRptCmt(0x0001E6E6, "Indicates how long to use fast filter after the engine has begun running.\nSeconds");
MakeNameEx(0x0001E6E8, "F_TANK_KE_FUEL_GAGE_PWM_FREQUENCY", nameFlags);
MakeRptCmt(0x0001E6E8, "Adjustable frequency TO drive the fuel gage\nHertz");
MakeNameEx(0x0001E6EA, "F_TANK_KE_FUEL_GAGE_USES_PWM_OUTPUT", nameFlags);
MakeRptCmt(0x0001E6EA, "Bit selectable cal to force the PWM output for certainapplications.\nBOOLEAN");
MakeNameEx(0x0001E6EB, "F_TANK_KE_F_TANK_IGNORE_MEC", nameFlags);
MakeRptCmt(0x0001E6EB, "When set FALSE, the sender diagnostics will only run when the Manufacturers Enable Counter is Zero.\nBOOLEAN");
MakeNameEx(0x0001E6EC, "F_TANK_KV_EVAP_STATE_ALLOWS_SEC_XFER_PU", nameFlags);
MakeRptCmt(0x0001E6EC, "Determines which evap test states allow the transferpump to be turned on.\nBOOLEAN");
MakeNameEx(0x0001E6F4, "F_TANK_KE_FUEL_LEVEL_FILTER_COEF", nameFlags);
MakeRptCmt(0x0001E6F4, "Filter coefficient for both primary and secondary fuel levels used in fuel tank diagnostics.\nSeconds");
MakeNameEx(0x0001E6F6, "F_TANK_KE_VENT_RSTR_MIN_AD_COUNTS", nameFlags);
MakeNameEx(0x0001E6F8, "F_TANK_KE_VENT_RSTR_MAX_AD_COUNTS", nameFlags);
MakeNameEx(0x0001E6FA, "F_TANK_KE_VENT_RESTRICT_PREP_TMR", nameFlags);
MakeRptCmt(0x0001E6FA, "Used to determine if vent restriction failed.\nSeconds");
MakeNameEx(0x0001E6FC, "DG_EONV_KE_EONV_DELTA_FROM_PRESSURE_PEAK", nameFlags);
MakeRptCmt(0x0001E6FC, "Decrease in pressure after a peak needed to identify it as a pressure peak.\nInchOfWat");
MakeNameEx(0x0001E6FE, "DG_EONV_KE_EONV_DELTA_FROM_VACUUM_PEAK", nameFlags);
MakeNameEx(0x0001E700, "DG_EONV_KE_EONV_EWMA_FAIL_COEF", nameFlags);
MakeRptCmt(0x0001E700, "This filter coefficient is used for the 0.020 inch EWMA calculation when the 0.020 inch EWMA is currently in the failing state.\nUnitless");
MakeNameEx(0x0001E702, "DG_EONV_KE_EONV_EWMA_FAIL_THRESHOLD", nameFlags);
MakeRptCmt(0x0001E702, "The fail threshold value that will set the MIL for P0442 once it is exceeded by EWMA.\nUnitless");
MakeNameEx(0x0001E704, "DG_EONV_KE_EONV_EWMA_NONFAIL_COEF", nameFlags);
MakeRptCmt(0x0001E704, "This filter coefficient is used for the 0.020 inch EWMA calculation when the 0.020 inch EWMA is currently in the passing state.\nUnitless");
MakeNameEx(0x0001E706, "DG_EONV_KE_EONV_EWMA_NONFAIL_THRESHOLD", nameFlags);
MakeRptCmt(0x0001E706, "The EWMA threshold value that will be used when the system is passing.\nUnitless");
MakeNameEx(0x0001E708, "DG_EONV_KE_EONV_EWMATESTSAMPLESTOPASS", nameFlags);
MakeRptCmt(0x0001E708, "The number of EWMA test samples required before the diagnostic is allowed to report a pass.\nUnitless");
MakeNameEx(0x0001E709, "DG_EONV_KE_EONV_MOD_VOLATILITY_MULT", nameFlags);
MakeRptCmt(0x0001E709, "Correction factor based on moderate fuel volatility.\nUnitless");
MakeNameEx(0x0001E70A, "DG_EONV_KE_EONV_PH1_COUNTS_AT_ZERO_MAX", nameFlags);
MakeRptCmt(0x0001E70A, "Number of counts needed to indicate the Phase 1 pressure build has stabilized at zero.\nUnitless");
MakeNameEx(0x0001E70C, "DG_EONV_KE_EONV_PH2_COUNTS_AT_ZERO_MAX", nameFlags);
MakeRptCmt(0x0001E70C, "Number of counts needed to indicate the Phase 2 vacuum build has stabilized at zero.\nUnitless");
MakeNameEx(0x0001E70E, "DG_EONV_KE_EONV_PHASE1_TEMP_DELTA_MIN", nameFlags);
MakeRptCmt(0x0001E70E, "Minimum temperature change required to report a failed test.\nDegrees_C");
MakeNameEx(0x0001E710, "DG_EONV_KE_EONV_PHASE1_TIME_LIMIT", nameFlags);
MakeRptCmt(0x0001E710, "The maximum amount of time allowed to execute the pressure monitoring portions of the EONV Diagnostic.\nSeconds");
MakeNameEx(0x0001E712, "DG_EONV_KE_EONV_PHASE1_VAC_COUNTS_MAX", nameFlags);
MakeRptCmt(0x0001E712, "Number of counts needed to indicate the Phase 1 vacuum build.\nUnitless");
MakeNameEx(0x0001E714, "DG_EONV_KE_EONV_PHASE1VACUUMALLOWED", nameFlags);
MakeRptCmt(0x0001E714, "Lower boundary at which vacuum is considered to be building.\nInchOfWat");
MakeNameEx(0x0001E716, "DG_EONV_KE_EONV_PHASE1ZEROPRESSURE", nameFlags);
MakeRptCmt(0x0001E716, "Boundary at which pressure is considered zero in Phase 1.\nInchOfWat");
MakeNameEx(0x0001E718, "DG_EONV_KE_EONV_PHASE1ZEROVACUUM", nameFlags);
MakeRptCmt(0x0001E718, "Boundary at which vacuum is considered zero in Phase 1.\nInchOfWat");
MakeNameEx(0x0001E71A, "DG_EONV_KE_EONV_PHASE2_TEMP_DELTA_MIN", nameFlags);
MakeRptCmt(0x0001E71A, "Minimum temperature change required to report a failed test.\nDegrees_C");
MakeNameEx(0x0001E71C, "DG_EONV_KE_EONV_PHASE2PRESSUREALLOWED", nameFlags);
MakeRptCmt(0x0001E71C, "Lower boundary at which pressure is considered essentially zero.\nInchOfWat");
MakeNameEx(0x0001E71E, "DG_EONV_KE_EONV_PHASE2ZEROPRESSURE", nameFlags);
MakeRptCmt(0x0001E71E, "Boundary at which pressure is considered zero in Phase 2.\nInchOfWat");
MakeNameEx(0x0001E720, "DG_EONV_KE_EONV_PHASE2ZEROVACUUM", nameFlags);
MakeRptCmt(0x0001E720, "Boundary at which vacuum is considered zero in Phase 2.\nInchOfWat");
MakeNameEx(0x0001E722, "DG_EONV_KE_EONV_PRESS_HIGH_VOLATILITY", nameFlags);
MakeRptCmt(0x0001E722, "Defines the integration limit for high volatility fuels.\nInH2O/Sec");
MakeNameEx(0x0001E726, "DG_EONV_KE_EONV_PRESS_MOD_VOLATILITY", nameFlags);
MakeRptCmt(0x0001E726, "Defines the integration limit for moderate volatility fuels.\nInH2O/Sec");
MakeNameEx(0x0001E72A, "DG_EONV_KE_EONV_PRESSWAIT_ATTEMPTS_MAX", nameFlags);
MakeRptCmt(0x0001E72A, "Maximum number of times this process can be activated without exiting Phase 2.\nUnitless");
MakeNameEx(0x0001E72C, "DG_EONV_KE_EONV_RATIONALITYTIME", nameFlags);
MakeNameEx(0x0001E72E, "DG_EONV_KE_EONV_RATIONALITYWAITTIME", nameFlags);
MakeRptCmt(0x0001E72E, "The amount of time that the rationality check will wait for the KE_EONV_RationalityTime to be met.\nSeconds");
MakeNameEx(0x0001E730, "DG_EONV_KE_EONV_TIME_BETWEEN_PHASE", nameFlags);
MakeRptCmt(0x0001E730, "The minimum time to wait between Phase 1 and Phase 2.\nSeconds");
MakeNameEx(0x0001E732, "DG_EONV_KE_EONV_TOTAL_TIME", nameFlags);
MakeRptCmt(0x0001E732, "The elapsed time allowed to execute the EONV Diagnostic. If this time is exceeded, the test enters the analysis phase.\nSeconds");
MakeNameEx(0x0001E734, "DG_EONV_KE_EONV_VACUUM_THRESHOLD_MIN", nameFlags);
MakeRptCmt(0x0001E734, "The minimum desired Phase 2 vacuum threshold.\nInchOfWat");
MakeNameEx(0x0001E736, "DG_EONV_KE_EONV_VEHICLE_HAS_TEMP_SENSOR", nameFlags);
MakeRptCmt(0x0001E736, "Indicates whether or not the vehicle has a temperature sensor.\nBOOLEAN");
MakeNameEx(0x0001E738, "DG_EONV_KE_EONV_WAITAFTERPRESSBUILDTIME", nameFlags);
MakeNameEx(0x0001E73A, "DG_EONV_KV_EONV_AVG_PH1_VAP_TEMP_MULT", nameFlags);
MakeRptCmt(0x0001E73A, "Correction factor based on average vapor temperature in Phase 1.\nUnitless");
MakeNameEx(0x0001E74C, "DG_EONV_KV_EONV_DELTA_VAP_TEMP_MULT", nameFlags);
MakeRptCmt(0x0001E74C, "Correction factor based on delta vapor temperature in Phase 1.\nUnitless");
MakeNameEx(0x0001E75E, "DG_EONV_KV_EONV_VOLATILITY_TIME_MAX", nameFlags);
MakeRptCmt(0x0001E75E, "Calibrated amount of time allocated for the volatility check.\nSeconds");
MakeNameEx(0x0001E780, "DI_EONV_KA_EONV_PRESSURE_THRESHOLD", nameFlags);
MakeRptCmt(0x0001E780, "Pressure threshold attainable only by a system with a total leak less than 0.020 inch.\nInchOfWat");
MakeNameEx(0x0001E9C2, "DI_EONV_KE_EONV_REFUELINGDELTALVLMAX", nameFlags);
MakeRptCmt(0x0001E9C2, "The minimum change in fuel level that must occur to indicate a refueling event.\nPercent");
MakeNameEx(0x0001E9C4, "DI_EONV_KE_EONV_FUEL_VAP_TEMP_MAX", nameFlags);
MakeRptCmt(0x0001E9C4, "Upper fuel vapor temperature boundary for enabling EONV diagnostic.\nDegrees_C");
MakeNameEx(0x0001E9C6, "DI_EONV_KE_EONV_SYSTEM_VOLTAGE_MIN", nameFlags);
MakeRptCmt(0x0001E9C6, "Minimum allowed system voltage below which system voltage will be considered  too low.\nVolts");
MakeNameEx(0x0001E9C7, "DI_EONV_KE_EONV_DO_NOT_USE_FAST_PASS", nameFlags);
MakeRptCmt(0x0001E9C7, "Used to bypass the small leak test.\nBOOLEAN");
MakeNameEx(0x0001E9C8, "DI_EONV_KE_EONV_ATTEMPTS_MAX", nameFlags);
MakeRptCmt(0x0001E9C8, "Maximum number of attempts that the diagnostic is allowed to enable in a given time frame.\nCounts");
MakeNameEx(0x0001E9CA, "DI_EONV_KE_EONV_AMBAIRTIME", nameFlags);
MakeRptCmt(0x0001E9CA, "Delays the update of calculated estimated ambient air temperature.\nSeconds");
MakeNameEx(0x0001E9CE, "DI_EONV_KE_EONV_AMBAIR_IDLE_COUNTER_MAX", nameFlags);
MakeRptCmt(0x0001E9CE, "Maximum count for the EONV_AmbAir_Idle_Counter.\nCounts");
MakeNameEx(0x0001E9D0, "DI_EONV_KV_EONV_AMBAIR_IDLE_DECREMENTER", nameFlags);
MakeRptCmt(0x0001E9D0, "Decrement the estimated ambient air idle counter based on air flow at idle.\nCounter");
MakeNameEx(0x0001E9F2, "DI_EONV_KV_EONV_AMBAIRTEMP_FILT_STEP", nameFlags);
MakeRptCmt(0x0001E9F2, "Change the estimated ambient air temperature based on air flow.\nDegrees_C");
MakeNameEx(0x0001EA14, "DI_EONV_KV_EONV_DELTA_VACUUM_RISE_MAX", nameFlags);
MakeRptCmt(0x0001EA14, "Change in vacuum over time above this level will indicate that a refuelevent has occurred.\nInches H2O");
MakeNameEx(0x0001EA36, "DI_EONV_KE_EONV_AMBAIR_AIRFLOW", nameFlags);
MakeRptCmt(0x0001EA36, "Calibrated amount of airflow needed to prevent the idle counter from increasing.\nGrams_Per_Second");
MakeNameEx(0x0001EA38, "DI_EONV_KE_EONV_AMBAIR_VEHSPD", nameFlags);
MakeRptCmt(0x0001EA38, "Calibrated amount of vehicle speed needed to update minimum intake air temperature and the ambient air temperature estimate.\nMPH");
MakeNameEx(0x0001EA3A, "DI_EONV_KE_EONV_AMBIENTAIRTEMP_LOWER_LIM", nameFlags);
MakeRptCmt(0x0001EA3A, "Lower boundary of the ambient air temperature window to enable EONV.\nDegrees_C");
MakeNameEx(0x0001EA3C, "DI_EONV_KE_EONV_AMBIENTAIRTEMP_UPPER_LIM", nameFlags);
MakeRptCmt(0x0001EA3C, "Upper boundary of the ambient air temperature window to enable EONV.\nDegrees_C");
MakeNameEx(0x0001EA3E, "DI_EONV_KE_EONV_DEFAULT_FUEL_LEVEL", nameFlags);
MakeNameEx(0x0001EA40, "DI_EONV_KE_EONV_DELTA_VAC_REFUELING_MAX", nameFlags);
MakeRptCmt(0x0001EA40, "Upper boundary on delta vacuum used to detect refueling to prevent intermittence from looking like a refueling event.\nInches H2O");
MakeNameEx(0x0001EA42, "DI_EONV_KE_EONV_ENGINE_RUN_TIME_MIN", nameFlags);
MakeRptCmt(0x0001EA42, "To execute EONV, the engine run time must exceed this value.\nSeconds");
MakeNameEx(0x0001EA46, "DI_EONV_KE_EONV_FUEL_TANK_VACUUM_OFFSET", nameFlags);
MakeRptCmt(0x0001EA46, "The fuel tank vacuum offset for EONV.\nInches H2O");
MakeNameEx(0x0001EA48, "DI_EONV_KE_EONV_FL_SLOSH_PERIOD", nameFlags);
MakeRptCmt(0x0001EA48, "To determine the sample period for fuel level slosh.\nCounts");
MakeNameEx(0x0001EA4A, "DI_EONV_KE_EONV_FL_SLOSH_PERIOD_PRIM", nameFlags);
MakeRptCmt(0x0001EA4A, "To determine unacceptable liquid slosh period in the secondary fuel tank.\nCounts");
MakeNameEx(0x0001EA4C, "DI_EONV_KE_EONV_FL_SLOSH_PERIOD_SEC", nameFlags);
MakeRptCmt(0x0001EA4C, "\nCounts");
MakeNameEx(0x0001EA4E, "DI_EONV_KE_EONV_FUEL_LEVEL_MAX", nameFlags);
MakeRptCmt(0x0001EA4E, "Upper fuel level boundary for enabling EONV diagnostic.\nPercent");
MakeNameEx(0x0001EA50, "DI_EONV_KE_EONV_FUEL_LEVEL_MIN", nameFlags);
MakeRptCmt(0x0001EA50, "Lower fuel level boundary for enabling EONV diagnostic.\nPercent");
MakeNameEx(0x0001EA52, "DI_EONV_KE_EONV_FUEL_VAPORTEMP_FILT_COEF", nameFlags);
MakeRptCmt(0x0001EA52, "Filter coefficient for the fuel vapor temperature variable.\n0-1");
MakeNameEx(0x0001EA54, "DI_EONV_KE_EONV_FUEL_VAP_TEMP_MIN", nameFlags);
MakeRptCmt(0x0001EA54, "Lower fuel vapor temperature boundary for enabling EONV diagnostic.\nDegrees_C");
MakeNameEx(0x0001EA56, "DI_EONV_KE_EONV_MIN_TRIP_DISTANCE", nameFlags);
MakeRptCmt(0x0001EA56, "Minimum distance traveled to enable the EONV diagnostic.\nMiles");
MakeNameEx(0x0001EA58, "DI_EONV_KE_EONV_MIN_VEHICLE_SPEED", nameFlags);
MakeRptCmt(0x0001EA58, "Minimum vehicle speed to start calculation of distance.\nMPH");
MakeNameEx(0x0001EA5A, "DI_EONV_KE_EONV_SLOSH_TANKVAC_FILT_COEF", nameFlags);
MakeRptCmt(0x0001EA5A, "Filtered coefficient for vacuum slosh.\n0-1");
MakeNameEx(0x0001EA5C, "DI_EONV_KE_EONV_SNAPSHOT_DELAY_MAX", nameFlags);
MakeRptCmt(0x0001EA5C, "The time delta at which the current vacuum is compared to a previous vacuum in order to detect a refueling event.\nSeconds");
MakeNameEx(0x0001EA5E, "DI_EONV_KE_EONV_TANK_PRESSURE_MAX", nameFlags);
MakeRptCmt(0x0001EA5E, "Maximum allowable pressure in the fuel tank. If exceeded, the diagnostic will consider a refueling event to have occurred.\nInches H2O");
MakeNameEx(0x0001EA60, "DI_EONV_KE_EONV_TANK_VACUUM_FILT_COEF", nameFlags);
MakeRptCmt(0x0001EA60, "Filter coefficient for the tank vacuum variable.\n0-1");
MakeNameEx(0x0001EA62, "DI_EONV_KE_EONV_TANK_VAC_FILTCOEF_REFUEL", nameFlags);
MakeRptCmt(0x0001EA62, "Filter coefficient for the refueling tank vacuum variable.\n0-1");
MakeNameEx(0x0001EA64, "DI_EONV_KE_EONV_TANK_VACUUM_REZERO_MAX", nameFlags);
MakeRptCmt(0x0001EA64, "Tank vacuum sensor voltage above which the tank vacuum variable will not be rezeroed.\nVolts");
MakeNameEx(0x0001EA66, "DI_EONV_KE_EONV_TANK_VACUUM_REZERO_MIN", nameFlags);
MakeRptCmt(0x0001EA66, "Tank vacuum sensor voltage below which the tank vacuum variable will not be rezeroed.\nVolts");
MakeNameEx(0x0001EA68, "DI_EONV_KE_EONV_TIME_BETWEEN_TESTS_MAX", nameFlags);
MakeRptCmt(0x0001EA68, "Maximum time to wait between completed EONV tests.\nHours");
MakeNameEx(0x0001EA6A, "DI_EONV_KE_EONV_TIME_BETWEEN_TESTS_MIN", nameFlags);
MakeRptCmt(0x0001EA6A, "Minimum time to wait between completed EONV tests.\nHours");
MakeNameEx(0x0001EA6C, "DI_EONV_KE_EONV_TOTALVEHICLEMILEAGEMIN", nameFlags);
MakeRptCmt(0x0001EA6C, "Mileage at which the EONV diagnostic can begin running. To prevent a dead battery at the assembly plant.\nMiles");
MakeNameEx(0x0001EA70, "DI_EONV_KE_EONV_TSTAT_TARGET_TEMP", nameFlags);
MakeRptCmt(0x0001EA70, "Coolant temperature must exceed this value in order to execute EONV diagnostic.\nDegrees_C");
MakeNameEx(0x0001EA72, "DI_EONV_KE_EONV_VAC_SENSOR_SCALE_SLOPE", nameFlags);
MakeRptCmt(0x0001EA72, "Slope used to rescale tank vacuum sensor voltage to inches of water.\nInches_H2O/Volts");
MakeNameEx(0x0001EA74, "DI_EONV_KE_EONV_VENT_VLV_STRIKE_LIM", nameFlags);
MakeRptCmt(0x0001EA74, "Determines the number of vent valve strike cycles used by the cleaning process.\nCounts");
MakeNameEx(0x0001EA76, "DI_EONV_KE_EONV_VENT_VLV_STRIKE_ON_TMR", nameFlags);
MakeRptCmt(0x0001EA76, "The limit of time that the vent valve will be commanded closed during the cleaning cycle period.\nSeconds");
MakeNameEx(0x0001EA78, "DI_EONV_KE_EONV_VENT_VLV_STRIKE_PERIOD", nameFlags);
MakeRptCmt(0x0001EA78, "Determines the limit of the vent valve cleaning cycle period.\nSeconds");
MakeNameEx(0x0001EA7A, "DI_EONV_KE_FUEL_LVL_FILT_COEF_SLOSH_PRI", nameFlags);
MakeRptCmt(0x0001EA7A, "Filter coefficient for fuel level variable used by slosh detection.\n0-1");
MakeNameEx(0x0001EA7C, "DI_EONV_KE_FUEL_LVL_FILT_COEF_SLOSH_SEC", nameFlags);
MakeRptCmt(0x0001EA7C, "Filter coefficient for fuel level variable used by slosh detection.\n0-1");
MakeNameEx(0x0001EA7E, "DI_EONV_KE_FUEL_LVL_VOLUME_FILT_COEF", nameFlags);
MakeRptCmt(0x0001EA7E, "Filter coefficient for fuel level variable used by slosh detection.\n0-1");
MakeNameEx(0x0001EA80, "DI_EONV_KV_EONV_FUEL_LEVEL_SLOSH_PRIM", nameFlags);
MakeRptCmt(0x0001EA80, "Threshold for the determination of detected slosh if the fuel level delta is too high.\nLiters");
MakeNameEx(0x0001EABE, "DI_EONV_KV_EONV_FUEL_LEVEL_SLOSH_SEC", nameFlags);
MakeRptCmt(0x0001EABE, "Threshold for the determination of detected slosh if the fuel level delta is too high.\nLiters");
MakeNameEx(0x0001EAFC, "DI_EONV_KA_EONV_ESTAMBAIR_OFFSET", nameFlags);
MakeRptCmt(0x0001EAFC, "Offset the estimated ambient air temperature from the intake air temperature using vehicle speed and engine airflow.\nDegrees_C");
MakeNameEx(0x0001EC72, "DG_EVAP_KE_TANK_VACUUM_RAW_MAX", nameFlags);
MakeRptCmt(0x0001EC72, "Maximum allowed voltage for the tank vacuum signal.\nVolts");
MakeNameEx(0x0001EC73, "DG_EVAP_KE_TANK_VACUUM_RAW_MIN", nameFlags);
MakeRptCmt(0x0001EC73, "Minimum allowed voltage for the tank vacuum signal.\nVolts");
MakeNameEx(0x0001EC74, "DG_EVAP_KE_EVAP_COLD_TEST_TIMER_LIMIT", nameFlags);
MakeRptCmt(0x0001EC74, "The maximum amount of time allowed to execute the cold fuel tank portions of the Evap Diagnostic.\nSeconds");
MakeNameEx(0x0001EC76, "DG_EVAP_KE_EVAP_SERVICE_TEST_VSS_MAX", nameFlags);
MakeRptCmt(0x0001EC76, "Maximum vehicle speed value to run the service bay test.\nMPH");
MakeNameEx(0x0001EC78, "DG_EVAP_KE_EVAP_SERVICE_TPS_MAX", nameFlags);
MakeNameEx(0x0001EC7A, "DG_EVAP_KE_EVAP_SERVICE_TPS_MIN", nameFlags);
MakeNameEx(0x0001EC7C, "DG_EVAP_KE_EVAP_SLOSH_RAT_PASS_TIME_MIN", nameFlags);
MakeRptCmt(0x0001EC7C, "Minimum amount of time that the slosh rationality test must be passing for a slosh rationality test to be considered passed.\nSeconds");
MakeNameEx(0x0001EC7E, "DG_EVAP_KE_EVAP_VEHICLE_REST_TIME_MIN", nameFlags);
MakeRptCmt(0x0001EC7E, "Minimum amount of time that the vehicle at rest conditions must be met before the vehicle will be considered at rest.\nSeconds");
MakeNameEx(0x0001EC80, "DG_EVAP_KE_EVAP_VEHICLE_REST_TPS_MAX", nameFlags);
MakeRptCmt(0x0001EC80, "Maximum throttle position at which vehicle will be considered at rest.\nPercent");
MakeNameEx(0x0001EC82, "DG_EVAP_KE_EVAP_VEHICLE_REST_VSS_MAX", nameFlags);
MakeRptCmt(0x0001EC82, "Maximum vehicle speed at which vehicle will be considered at rest.\nMPH");
MakeNameEx(0x0001EC84, "DG_EVAP_KE_EVAP_OVERPRESSURE_THRESH", nameFlags);
MakeRptCmt(0x0001EC84, "Fuel tank pressure above which the Evap Diagnostic_will be aborted.\nIn. of H2O");
MakeNameEx(0x0001EC86, "DG_EVAP_KE_EXCESS_VAC_STAGE2_DELAY_LIMIT", nameFlags);
MakeRptCmt(0x0001EC86, "This calibration determines how long to delay before starting to monitor Tank_Vacuum_Filtered and Evap_System_Vacuum_Index.\nSeconds");
MakeNameEx(0x0001EC88, "DG_EVAP_KE_EXCESS_VAC_STAGE2_FAIL_TIME", nameFlags);
MakeRptCmt(0x0001EC88, "If Excess_Vac_Stage2_Fail_Timer is >= this calibration, Stage2 of the Excess Vacuum test is failed and completed.\nSeconds");
MakeNameEx(0x0001EC8A, "DG_EVAP_KE_EXCESS_VAC_STAGE2_INTEGRAL", nameFlags);
MakeNameEx(0x0001EC8E, "DG_EVAP_KE_EXCESS_VAC_STAGE2_TEST_LIMIT", nameFlags);
MakeRptCmt(0x0001EC8E, "This calibration limits how long Stage2 of the Excess Vacuum test can run.\nSeconds");
MakeNameEx(0x0001EC90, "DG_EVAP_KE_EXCESS_VAC_STAGE2_VAC_LEVEL", nameFlags);
MakeRptCmt(0x0001EC90, "If Tank_Vacuum_Filtered is >= this calibration, Excess_Vac_Stage2_Fail_Timer will be incremented.\nIn. of H2O");
MakeNameEx(0x0001EC92, "DG_EVAP_KE_EXCESS_VACUUM_LEVEL_STAGE1", nameFlags);
MakeRptCmt(0x0001EC92, "If the tank vacuum is above this calibration, Excess Vacuum Test Stage1 is failed.\nIn. of H2O");
MakeNameEx(0x0001EC94, "DG_EVAP_KE_EXCESS_VACUUM_TIME_STAGE1", nameFlags);
MakeRptCmt(0x0001EC94, "Maximum time allowed for tank vacuum to stay above an excess vacuum threshold before failing Excess Vacuum Test Stage1.\nSeconds");
MakeNameEx(0x0001EC96, "DG_EVAP_KE_FINAL_ITERATION_SEGMENT_TIME", nameFlags);
MakeRptCmt(0x0001EC96, "This calibration limits how long each segment will run until its slope is tested for passing or failing.\nSeconds");
MakeNameEx(0x0001EC98, "DG_EVAP_KE_FINAL_SLOPE_MULTIPLIER", nameFlags);
MakeRptCmt(0x0001EC98, "Adjusts the slope threshold used for the total slope of the final iteration.\nUnitless");
MakeNameEx(0x0001EC9A, "DG_EVAP_KE_PURGE_LEAK_TEST_TPS_MAX", nameFlags);
MakeRptCmt(0x0001EC9A, "The TPS must be <= this cal. to uncover the port on a ported purge system (manifold purge could use 100.\nPercent");
MakeNameEx(0x0001EC9C, "DG_EVAP_KE_PURGE_LEAK_TEST_TPS_MIN", nameFlags);
MakeRptCmt(0x0001EC9C, "The TPS must be >= this cal. to uncover the port on a ported purge system (manifold purge could use 0.\nPercent");
MakeNameEx(0x0001EC9E, "DG_EVAP_KE_PURGE_VALVE_HIGH_VAC_TIME", nameFlags);
MakeRptCmt(0x0001EC9E, "Maximum time allowed for tank vacuum to stay above a high vacuum threshold before failing the Purge Valve Leak Test.\nSeconds");
MakeNameEx(0x0001ECA0, "DG_EVAP_KE_PURGE_VALVE_LEAK_TEST_DELAY", nameFlags);
MakeRptCmt(0x0001ECA0, "This calibration determines how long to delay the Purge Valve Leak Test pass/fail determination.\nSeconds");
MakeNameEx(0x0001ECA2, "DG_EVAP_KE_PURGE_VALVE_LEAK_TEST_TIME", nameFlags);
MakeRptCmt(0x0001ECA2, "The maximum amount of time the Purge Valve Leak Test will be allowed to run.\nSeconds");
MakeNameEx(0x0001ECA4, "DG_EVAP_KE_PURGE_VALVE_LEAK_VAC_TIME_MIN", nameFlags);
MakeRptCmt(0x0001ECA4, "If the Purge_Valve_Leak_Vac_Timer is >= this cal., proper conditions for the test have been achieved.\nSeconds");
MakeNameEx(0x0001ECA6, "DG_EVAP_KE_PURGE_VALVE_LEAK_VACUUM_LEVEL", nameFlags);
MakeRptCmt(0x0001ECA6, "If tank vacuum is greater than this value, the Purge Valve Leak Test fails and ends.\nIn. of H2O");
MakeNameEx(0x0001ECA8, "DG_EVAP_KE_PURGE_VALVE_LEAK_VAPOR_TIME", nameFlags);
MakeRptCmt(0x0001ECA8, "If purge vapors are present for this amount of time or longer, the Purge Valve Leak Test fails and ends.\nSeconds");
MakeNameEx(0x0001ECAA, "DG_EVAP_KE_PURGE_VALVE_TEST_VAC_MIN", nameFlags);
MakeRptCmt(0x0001ECAA, "The intake manifold vacuum must be > this value to ensure that there is enough vacuum source being applied to the evap system.\nkPa");
MakeNameEx(0x0001ECAC, "DG_EVAP_KE_SYSTEM_VENTING_TIME_DELAY", nameFlags);
MakeRptCmt(0x0001ECAC, "The minimum amount of time delay before the tank vacuum is checked to start the vent pulse.\nSeconds");
MakeNameEx(0x0001ECAE, "DG_EVAP_KE_VAC_DECAY_ITERATION_TIME", nameFlags);
MakeRptCmt(0x0001ECAE, "This calibration limits how long each vacuum decay iteration will run until its slope is tested for passing or failing.\nSeconds");
MakeNameEx(0x0001ECB0, "DG_EVAP_KE_VAC_DECAY_SLOPE_TIME", nameFlags);
MakeRptCmt(0x0001ECB0, "This calibration limits how long a vacuum decay may run.\nSeconds");
MakeNameEx(0x0001ECB2, "DG_EVAP_KE_VAC_DECAY_TPS_HIGH_LMT", nameFlags);
MakeRptCmt(0x0001ECB2, "The Vacuum Decay test will restart if throttle position is > this calibration.\nPercent");
MakeNameEx(0x0001ECB4, "DG_EVAP_KE_VAC_DECAY_VACUUM_MIN", nameFlags);
MakeRptCmt(0x0001ECB4, "If the tank vacuum goes below this cal., the vacuum decay slope will be calculated.\nIn. of H2O");
MakeNameEx(0x0001ECB6, "DG_EVAP_KE_VAC_DECAY_VEH_SPEED_HIGH_LMT", nameFlags);
MakeRptCmt(0x0001ECB6, "The Vacuum Decay test will restart if vehicle speed is > this calibration.\nMPH");
MakeNameEx(0x0001ECB8, "DG_EVAP_KE_VAC_PULLDOWN_PURGEDC_MIN", nameFlags);
MakeNameEx(0x0001ECBA, "DG_EVAP_KE_VAC_SENSOR_HIGH_FAIL_TIME", nameFlags);
MakeRptCmt(0x0001ECBA, "Maximum amount of time the sensor is allowed to be out of range high.\nSeconds");
MakeNameEx(0x0001ECBC, "DG_EVAP_KE_VAC_SENSOR_LOW_FAIL_TIME", nameFlags);
MakeRptCmt(0x0001ECBC, "Maximum amount of time the sensor is allowed to be out of range low.\nSeconds");
MakeNameEx(0x0001ECBE, "DG_EVAP_KE_VACUUM_DECAY_ENABLE_VACUUM", nameFlags);
MakeRptCmt(0x0001ECBE, "This is the level of tank vacuum needed to end stage1 of the Weak Vacuum Test and start the Small Leak Test.\nIn. of H2O");
MakeNameEx(0x0001ECC0, "DG_EVAP_KE_VACUUM_DECAY_START_VAC_LEVEL", nameFlags);
MakeRptCmt(0x0001ECC0, "If tank vacuum level is > this calibration, then immediately proceed to the vacuum decay test.\nIn. of H2O");
MakeNameEx(0x0001ECC2, "DG_EVAP_KE_VACUUM_PULLDOWN_INTEGRAL_LIM", nameFlags);
MakeRptCmt(0x0001ECC2, "This calibration limits high the Vacuum_Pulldown_Integral can get before the vacuum pulldown expires.\nSeconds");
MakeNameEx(0x0001ECC6, "DG_EVAP_KE_VACUUM_PULLDOWN_VACUUM_LEVEL", nameFlags);
MakeRptCmt(0x0001ECC6, "If tank vacuum is >= this calibration, the tank vacuum Pulldown is complete.\nIn. of H2O");
MakeNameEx(0x0001ECC8, "DG_EVAP_KE_VAPOR_PRESSURE_SLOPE_TIMER", nameFlags);
MakeRptCmt(0x0001ECC8, "This calibration limits how long to wait before calculating the Vapor_Pressure_Slope.\nSeconds");
MakeNameEx(0x0001ECCA, "DG_EVAP_KE_VAPOR_PRESSURE_TEST_MIN_PRESS", nameFlags);
MakeRptCmt(0x0001ECCA, "This is the minimum pressure required to start the vapor pressure build monitoring.\nIn. of H2O");
MakeNameEx(0x0001ECCC, "DG_EVAP_KE_VAPOR_PRESSURE_TEST_TIMER", nameFlags);
MakeNameEx(0x0001ECCE, "DG_EVAP_KE_VAPOR_PRESSURE_VACUUM_LEVEL", nameFlags);
MakeRptCmt(0x0001ECCE, "The tank vacuum must be <= this value in order to start the vapor pressure test.\nIn. of H2O");
MakeNameEx(0x0001ECD0, "DG_EVAP_KE_VAPOR_PRESSURE_VENT_DELAY", nameFlags);
MakeRptCmt(0x0001ECD0, "Determines how long the evap system should vent after it has reached its vented vacuum level.\nSeconds");
MakeNameEx(0x0001ECD2, "DG_EVAP_KE_VAPOR_PRESSURE_WAIT_TIMER_LMT", nameFlags);
MakeRptCmt(0x0001ECD2, "Limits how long to wait before bypassing the vapor pressure build test.\nSeconds");
MakeNameEx(0x0001ECD4, "DG_EVAP_KE_VENT_ON_TIME_1", nameFlags);
MakeRptCmt(0x0001ECD4, "At the tank vacuum level KE_Vent_On_Vacuum_Level_1, the canister will be on for this amount of time.\nSeconds");
MakeNameEx(0x0001ECD6, "DG_EVAP_KE_VENT_ON_TIME_2", nameFlags);
MakeRptCmt(0x0001ECD6, "At the tank vacuum level KE_Vent_On_Vacuum_Level_2, the canister will be on for this amount of time.\nSeconds");
MakeNameEx(0x0001ECD8, "DG_EVAP_KE_VENT_ON_TIME_3", nameFlags);
MakeRptCmt(0x0001ECD8, "At the tank vacuum level KE_Vent_On_Vacuum_Level_3, the canister will be on for this amount of time.\nSeconds");
MakeNameEx(0x0001ECDA, "DG_EVAP_KE_VENT_ON_VACUUM_LEVEL_1", nameFlags);
MakeRptCmt(0x0001ECDA, "If the tank vacuum level is above this calibration, the canister vent will be on for the amount of time KE_Vent_On_Timer_1.\nIn. of H2O");
MakeNameEx(0x0001ECDC, "DG_EVAP_KE_VENT_ON_VACUUM_LEVEL_2", nameFlags);
MakeRptCmt(0x0001ECDC, "If the tank vacuum level is above this calibration, the canister vent will be on for the amount of time KE_Vent_On_Timer_2.\nIn. of H2O");
MakeNameEx(0x0001ECDE, "DG_EVAP_KE_VENT_ON_VACUUM_LEVEL_3", nameFlags);
MakeRptCmt(0x0001ECDE, "If the tank vacuum level is above this calibration, the canister vent will be on for the amount of time KE_Vent_On_Timer_3.\nIn. of H2O");
MakeNameEx(0x0001ECE0, "DG_EVAP_KE_WEAK_VAC_STAGE2_VAC_LEVEL", nameFlags);
MakeRptCmt(0x0001ECE0, "This calibration determines how high tank vacuum must be before it is considered to be passing stage2 of the Weak Vacuum Test.\nIn. of H2O");
MakeNameEx(0x0001ECE2, "DG_EVAP_KE_WEAK_VAC_STAGE2_VAC_TEST", nameFlags);
MakeRptCmt(0x0001ECE2, "This calibration limits how long the vacuum monitor portion of stage2 of the Weak Vacuum Test may run.\nSeconds");
MakeNameEx(0x0001ECE4, "DG_EVAP_KE_WEAK_VAC_STAGE2_VAC_TIME", nameFlags);
MakeRptCmt(0x0001ECE4, "This calibration determines how long the vacuum must be passing before stage2 of the Weak Vacuum Test passes.\nSeconds");
MakeNameEx(0x0001ECE6, "DG_EVAP_KE_WEAK_VAC_STAGE2_VAPOR_TEST", nameFlags);
MakeRptCmt(0x0001ECE6, "This calibration limits how long the purge vapor monitor portion of stage2 of the Weak Vacuum Test may run.\nSeconds");
MakeNameEx(0x0001ECE8, "DG_EVAP_KE_WEAK_VAC_STAGE2_VAPOR_TIME", nameFlags);
MakeRptCmt(0x0001ECE8, "This calibration determines how long purge vapors must be detected before stage2 of the Weak Vacuum Test passes.\nSeconds");
MakeNameEx(0x0001ECEA, "DG_EVAP_KE_WEAK_VACUUM_INTEGRAL_MIN", nameFlags);
MakeNameEx(0x0001ECEE, "DG_EVAP_KE_EVAP_PURGE_ENABLE_COLD_TIME", nameFlags);
MakeRptCmt(0x0001ECEE, "Setting this option to 'TRUE' causes the timer to start updating on 'purge enabled.' instead of 'engine run'.\nFlag");
MakeNameEx(0x0001ECEF, "DG_EVAP_KE_EVAP_SLOSH_RAT_PASS_TESTS_MIN", nameFlags);
MakeNameEx(0x0001ECF0, "DG_EVAP_KE_FINAL_ITERATION_TRIP_MAX", nameFlags);
MakeRptCmt(0x0001ECF0, "Limits the number of final iteration vacuum decays per trip.\nCounts");
MakeNameEx(0x0001ECF1, "DG_EVAP_KE_VAC_DECAY_ITERATION_LIMIT", nameFlags);
MakeRptCmt(0x0001ECF1, "If the number of vacuum decay iterations is >= this cal., each segment of the vacuum decay will be monitored.\nCount");
MakeNameEx(0x0001ECF2, "DG_EVAP_KE_VAPOR_PRESSURE_MULTIPLIER", nameFlags);
MakeRptCmt(0x0001ECF2, "Multiplier correction for the Vapor_Pressure_Slope.\nMultiplier");
MakeNameEx(0x0001ECF4, "DG_EVAP_KV_STABILIZ_PERIOD_LIM_NO_SLOSH", nameFlags);
MakeRptCmt(0x0001ECF4, "The maximum amount of time that is required for the stabilization period when Evap_040_Level_Slosh_Detected is FALSE.\nSeconds");
MakeNameEx(0x0001ED0A, "DG_EVAP_KV_STABILIZ_PERIOD_LIM_SLOSH", nameFlags);
MakeRptCmt(0x0001ED0A, "The maximum amount of time that is required for the stabilization period when Evap_040_Level_Slosh_Detected is TRUE.\nSeconds");
MakeNameEx(0x0001ED20, "DG_EVAP_KV_VAC_DECAY_SLOPE_FACTOR", nameFlags);
MakeRptCmt(0x0001ED20, "This factor is used to adjust the slope threshold for each iteration of the vacuum decay slope.\nMultiplier");
MakeNameEx(0x0001ED2A, "DG_EVAP_KV_SEGMENT_SLOPE_FACTOR", nameFlags);
MakeRptCmt(0x0001ED2A, "This factor is used to adjust each segment's slope threshold for the final iteration.\nMultiplier");
MakeNameEx(0x0001ED30, "DI_EVAP_KV_EVAP_DIAG_PURGE_DUTY_CYCLE_LI", nameFlags);
MakeRptCmt(0x0001ED30, "\n");
MakeNameEx(0x0001ED5A, "DI_EVAP_KE_FUEL_LEVEL_ENABLE_MAX", nameFlags);
MakeRptCmt(0x0001ED5A, "Fuel level must be <= this TO enable Evap diagnostic system.\nPercent");
MakeNameEx(0x0001ED5C, "DI_EVAP_KE_CCP_MAX_DUTY_CYCLE_CLOSED", nameFlags);
MakeNameEx(0x0001ED5E, "DI_EVAP_KE_EVAP_PURGE_ENABLED_MIN_SPEED", nameFlags);
MakeRptCmt(0x0001ED5E, "The minimum necessary at the onset of purge being enabled to allow the Evap test to start.\nMPH");
MakeNameEx(0x0001ED60, "DI_EVAP_KE_DELTA_VAC_SLOSH_FORSRT", nameFlags);
MakeRptCmt(0x0001ED60, "Amount of tank vacuum used to determine if irrational slosh has been present during the slosh rationality test.\nInches Of Water");
MakeNameEx(0x0001ED62, "DI_EVAP_KE_PRI_DELTA_FUEL_SLOSH_FORSRT", nameFlags);
MakeNameEx(0x0001ED64, "DI_EVAP_KE_SEC_DELTA_FUEL_SLOSH_FORSRT", nameFlags);
MakeNameEx(0x0001ED66, "DI_EVAP_KV_SOLENOID_EVENT_SLOSH_DELAY", nameFlags);
MakeRptCmt(0x0001ED66, "This is the minimum amount of time after a solenoid event whichwill mask out the slosh detection algorithm.\nSeconds");
MakeNameEx(0x0001ED7C, "DI_EVAP_KV_ENGINE_VACUUM_MODIFIER", nameFlags);
MakeRptCmt(0x0001ED7C, "Engine Vacuum contribution to Evap_System_Vacuum_Index.\nNONE 0-1");
MakeNameEx(0x0001ED98, "DI_EVAP_KV_PURGE_MODIFIER", nameFlags);
MakeRptCmt(0x0001ED98, "Purge contribution to Evap_System_Vacuum_Index.\nNONE 0-1");
MakeNameEx(0x0001EDC2, "DI_EVAP_KV_VACUUM_LOSS_OFFSET", nameFlags);
MakeRptCmt(0x0001EDC2, "Vapor generation and porosity contribution TO Evap_System_Vacuum_Index.\nNONE 0-1");
MakeNameEx(0x0001EDD4, "DI_EVAP_KV_CCP_COLD_TEST_RAMP_TIMER_LMT", nameFlags);
MakeRptCmt(0x0001EDD4, "Indicates what a 'normal' CCP ducty cycle ramp up time is.\nSeconds");
MakeNameEx(0x0001EDFA, "DI_EVAP_KE_PURGE_RAMP_TIMER_LIMIT", nameFlags);
MakeRptCmt(0x0001EDFA, "Purge ramp timer >= this indicates HC vapor present in canister.\nSeconds");
MakeNameEx(0x0001EDFC, "DI_EVAP_KE_CCP_PURGE_VAPOR_PLM", nameFlags);
MakeRptCmt(0x0001EDFC, "Closed loop fuel control Purge_Learn_Multiplier < KE_CCP_Purge_Vapor_PLM indicates closed loop HC vapor present.\nNONE 0-2");
MakeNameEx(0x0001EDFE, "DI_EVAP_KA_VACUUM_DECAY_SLOPE", nameFlags);
MakeRptCmt(0x0001EDFE, "Pass/Fail threshold for vacuum decay slope for applications with fuel level input.\nIn H2O/Sec");
MakeNameEx(0x0001F19A, "DI_EVAP_KA_VACUUM_DECAY_SLOPE_SEG", nameFlags);
MakeRptCmt(0x0001F19A, "Pass/Fail threshold for vacuum decay slope for applications with fuel level input (for segments of final iteration).\nIn H2O/Sec");
MakeNameEx(0x0001F536, "DI_EVAP_KE_FUEL_LEVEL_PERCENT_DEFAULT", nameFlags);
MakeNameEx(0x0001F538, "DI_EVAP_KE_CCP_PURGE_RAMP_O2_ADJUST", nameFlags);
MakeRptCmt(0x0001F538, "This calibration value defines the purge oxygen adjust multiplier at which the Purge_Ramp_Timer will stop.\nUnitless");
MakeNameEx(0x0001F53A, "DI_EVAP_KE_EVPD_020_SLOPE_MULTIPLIER", nameFlags);
MakeRptCmt(0x0001F53A, "The existing 040 calibration threshold tables are multiplied this calibration to find the effective, 0.020 slope threshold.\nUnitless");
MakeNameEx(0x0001F53C, "DI_EVAP_KE_FUEL_TANK_RATED_CAPACITY", nameFlags);
MakeRptCmt(0x0001F53C, "Rated capacity of the fuel tank as determined by GMUTS.\nLiters");
MakeNameEx(0x0001F53E, "DI_EVAP_KE_FUEL_TANK_UNUSABLE_VOLUME", nameFlags);
MakeRptCmt(0x0001F53E, "Amount of fuel in tank crevices which cannot be reached by the fuel pump.\nLiters");
MakeNameEx(0x0001F540, "DI_EVAP_KE_FUEL_TANK_TOTAL_VAPOR_SPACE", nameFlags);
MakeRptCmt(0x0001F540, "Total volume of fuel tank and lines.  Determined BY platform.\nLiters");
MakeNameEx(0x0001F542, "DI_EVAP_KV_DELTA_FUEL_LEVEL_SLOSH_PRIMAR", nameFlags);
MakeRptCmt(0x0001F542, "Delta fuel level >= this indicates sloshing in fuel tank.\nLiters");
MakeNameEx(0x0001F580, "DI_EVAP_KV_DELTA_FUEL_LEVEL_SLOSH_SECOND", nameFlags);
MakeRptCmt(0x0001F580, "Delta fuel level >= this indicates sloshing in fuel tank.\nLiters");
MakeNameEx(0x0001F5BE, "DI_EVAP_KV_EVPD_DELTA_FUEL_040_SLOSH_PRI", nameFlags);
MakeRptCmt(0x0001F5BE, "Delta fuel level >= this indicates sloshing in fuel tank.\nLiters");
MakeNameEx(0x0001F5FC, "DI_EVAP_KV_EVPD_DELTA_FUEL_040_SLOSH_SEC", nameFlags);
MakeRptCmt(0x0001F5FC, "Delta fuel level >= this indicates sloshing in fuel tank.\nLiters");
MakeNameEx(0x0001F63A, "DI_EVAP_KV_DELTA_VACUUM_SLOSH", nameFlags);
MakeRptCmt(0x0001F63A, "Delta fuel tank vacuum >= this indicates sloshing in fuel tank.\nInches H2O");
MakeNameEx(0x0001F650, "DI_EVAP_KV_EVPD_DELTA_VAC_040_SLOSH", nameFlags);
MakeRptCmt(0x0001F650, "Delta fuel tank vacuum >= this indicates sloshing in fuel tank.\nInches H2O");
MakeNameEx(0x0001F666, "DI_EVAP_KV_COLD_DELTA_TEMP_LIMIT", nameFlags);
MakeRptCmt(0x0001F666, "Upper limit on difference between powerup coolant temperature and powerup induction air temperature for cold start conditions.\nDegrees C");
MakeNameEx(0x0001F66A, "DI_EVAP_KE_COLD_COOLANT_TEMP_LOW_LIMIT", nameFlags);
MakeRptCmt(0x0001F66A, "Lower limit on powerup coolant temperature for cold start conditions.\nDegrees C");
MakeNameEx(0x0001F66C, "DI_EVAP_KE_COLD_COOLANT_TEMP_HIGH_LIMIT", nameFlags);
MakeRptCmt(0x0001F66C, "Upper limit on powerup coolant temperature for cold start conditions.\nDegrees C");
MakeNameEx(0x0001F66E, "DI_EVAP_KE_COLD_MAN_AIR_TEMP_LOW_LIMIT", nameFlags);
MakeRptCmt(0x0001F66E, "Lower limit on powerup induction air temperature for cold start conditions.\nDegrees C");
MakeNameEx(0x0001F670, "DI_EVAP_KE_COLD_MAN_AIR_TEMP_HIGH_LIMIT", nameFlags);
MakeRptCmt(0x0001F670, "Upper limit on powerup induction air temperature for cold start conditions.\nDegrees C");
MakeNameEx(0x0001F672, "DI_EVAP_KE_COLD_FUEL_LEVEL_LOW_LIMIT", nameFlags);
MakeRptCmt(0x0001F672, "Lower limit on fuel level for cold start conditions.\nPercent");
MakeNameEx(0x0001F674, "DI_EVAP_KE_COLD_FUEL_LEVEL_HIGH_LIMIT", nameFlags);
MakeRptCmt(0x0001F674, "Upper limit on fuel level for cold start conditions.\nPercent");
MakeNameEx(0x0001F676, "DI_EVAP_KE_COLD_BAROMETRIC_PRESSURE_LIMI", nameFlags);
MakeRptCmt(0x0001F676, "Lower limit on barometric pressure for cold start conditions.\nkPa");
MakeNameEx(0x0001F678, "DI_EVAP_KE_FAIL_REPORT_HIGH_FUEL_LEVEL", nameFlags);
MakeRptCmt(0x0001F678, "Fuel level values > this indicate fuel tank is over-filled.\nPercent");
MakeNameEx(0x0001F67A, "DI_EVAP_KE_FAIL_REPORT_MIN_MILES", nameFlags);
MakeRptCmt(0x0001F67A, "When fuel tank is over-filled, this many miles must be accumulated in this trip to enable general failure reporting.\nMiles");
MakeNameEx(0x0001F67E, "DI_EVAP_KE_VAC_PROBLEM_FAIL_MIN_MILES", nameFlags);
MakeNameEx(0x0001F682, "DI_EVAP_KE_EVAP_DIAG_INHIBITING_FAULTS", nameFlags);
MakeRptCmt(0x0001F682, "Disable Evap diagnostic tests if any faults in the groups marked TRUE are active.\nBOOLEAN");
MakeNameEx(0x0001F686, "DI_EVAP_KE_FUEL_LEVEL_ENABLE_MIN", nameFlags);
MakeRptCmt(0x0001F686, "Fuel level must be < this TO enable Evap diagnostic system.\nPercent");
MakeNameEx(0x0001F688, "DI_EVAP_KE_IGNITION_VOLTAGE_MIN", nameFlags);
MakeRptCmt(0x0001F688, "Minimum ignition voltage which permits execution of the EVAP diagnostic.\nVolts");
MakeNameEx(0x0001F68A, "DI_EVAP_KE_IGNITION_VOLTAGE_MAX", nameFlags);
MakeRptCmt(0x0001F68A, "Maximum ignition voltage which permits execution of the EVAP diagnostic.\nVolts");
MakeNameEx(0x0001F68C, "DI_EVAP_KE_VENT_PRESSURE", nameFlags);
MakeRptCmt(0x0001F68C, "Minimum fuel tank vacuum at powerup for fuel tank vacuum to be in range at powerup.\nIn H2O");
MakeNameEx(0x0001F68E, "DI_EVAP_KE_VENT_VACUUM", nameFlags);
MakeRptCmt(0x0001F68E, "Maximum fuel tank vacuum at powerup for fuel tank vacuum to be in range at powerup.\nIn H2O");
MakeNameEx(0x0001F690, "DI_EVAP_KE_EVAP_SERVICE_TEST_COOLANT_MAX", nameFlags);
MakeRptCmt(0x0001F690, "Maximum coolant temperature value to run the service bay test.\nDegrees Celsius");
MakeNameEx(0x0001F692, "DI_EVAP_KE_EVAP_SERVICE_TEST_ENABLED", nameFlags);
MakeRptCmt(0x0001F692, "Used to calibrate out the service bay test.\nFlag");
MakeNameEx(0x0001F694, "DI_EVAP_KE_FUEL_LEVEL_OUT_OF_RANGE_TIME", nameFlags);
MakeRptCmt(0x0001F694, "Determine how long the fuel level must be outside of it's enable window in order to disable the evap diagnostic.\nSeconds");
MakeNameEx(0x0001F696, "DI_EVAP_KE_EVPD_FUEL_LEVEL_READ_DELAY", nameFlags);
MakeRptCmt(0x0001F696, "Engine run delay before the slosh detection algorithm to operable.\nSeconds");
MakeNameEx(0x0001F698, "DI_EVAP_KE_IGNITION_VOLTAGE_EXCURSION_TI", nameFlags);
MakeRptCmt(0x0001F698, "Determine how long the ignition voltage must be outside of it's enable window in order to disable the evap diagnostic.\nSeconds");
MakeNameEx(0x0001F6C0, "SYS_CALIBRATIONS_HEADER", nameFlags);
MakeRptCmt(0x0001F6C0, "Use this cal to identify the Vehicle System calibration\nCal_ID_Record");
MakeNameEx(0x0001F6DC, "VEH_SYS_KA_OPTION_MATRIX", nameFlags);
MakeRptCmt(0x0001F6DC, "Allows selection of options for a given platform.\nPlatform_Option_Table_Type");
MakeNameEx(0x0001F778, "VEH_SYS_KE_RESTRAINTS_IDENTIFIER", nameFlags);
MakeRptCmt(0x0001F778, "Contains a serial data keying information for SDM used to verify that its calibration is correct for the vehicle it is in.\nCARDINAL");
MakeNameEx(0x0001F77A, "VEH_SYS_KE_TYPE_OF_DISCRETE_GEAR_SELECT", nameFlags);
MakeRptCmt(0x0001F77A, "Describes if the vehicle is equipped with PRNDL input, Park/Neutral switch or neither.\nSelection_List");
MakeNameEx(0x0001F77B, "VEH_SYS_KE_TYPE_OF_INSTRUMENT_CLUSTER", nameFlags);
MakeNameEx(0x0001F77C, "VEH_SYS_KE_DRIVETRAIN_TYPE", nameFlags);
MakeRptCmt(0x0001F77C, "Describes the type of drivetrain used on the vehicle\nDrivetrain_Type");
MakeNameEx(0x0001F77D, "VEH_SYS_KE_PLATFORM", nameFlags);
MakeRptCmt(0x0001F77D, "Identifies platform type -- F, Y, V, GMT530, GMT540, GMT560,GMT610, GMT800, ML, ST, P, GMT370, H2.\nPlatform_Type");
MakeNameEx(0x0001F77E, "VEH_SYS_KE_TYPE_OF_FANS_ON_VEHICLE", nameFlags);
MakeRptCmt(0x0001F77E, "Type of engine cooling system supported on vehicle\nUnitless");
MakeNameEx(0x0001F780, "VEH_SYS_KE_NUMBER_MED_RES_TACH_HIGH", nameFlags);
MakeRptCmt(0x0001F780, "Number of medium res periods to hold the tachometer output signal high.\nUnitless");
MakeNameEx(0x0001F782, "VEH_SYS_KE_NUMBER_MED_RES_TACH_LOW", nameFlags);
MakeRptCmt(0x0001F782, "Number of medium res periods to hold the tachometer output signal low.\nUnitless");
MakeNameEx(0x0001F784, "VEH_SYS_KE_VTD_CONFIGURATION", nameFlags);
MakeRptCmt(0x0001F784, "This is used to activate the different VTD functionalities within the PCM.\nUnitless");
MakeNameEx(0x0001F785, "VEH_SYS_KE_VTD_FAIL_ENABLED_BYPASS", nameFlags);
MakeRptCmt(0x0001F785, "Enables or disables the theft Fail-Enabled mode.  Thiscapability is required for export vehicles.\nBOOLEAN");
MakeNameEx(0x0001F786, "VEH_SYS_KE_ID_SOFTWARE_CAL_LEVEL", nameFlags);
MakeRptCmt(0x0001F786, "This is the identifier for the software level running on the PCM.\nUnitless");
MakeNameEx(0x0001F78A, "VEH_SYS_KE_LOW_COOL_NEG_ACCEL_DEADBAND", nameFlags);
MakeRptCmt(0x0001F78A, "Ramp factor is not computed if vehicle deceleration is less than this.\nMPH/Sec");
MakeNameEx(0x0001F78C, "VEH_SYS_KE_LOW_COOL_OCCURRENCES_TO_LATCH", nameFlags);
MakeRptCmt(0x0001F78C, "If low coolant detection fails this many times, stop running the algorithm.\nCounts");
MakeNameEx(0x0001F78E, "VEH_SYS_KE_LOW_COOL_POS_ACCEL_DEADBAND", nameFlags);
MakeRptCmt(0x0001F78E, "Ramp factor is not computed if vehicle acceleration is more than this.\nMPH/Sec");
MakeNameEx(0x0001F790, "VEH_SYS_KE_LOW_COOLANT_MIN_TEMP", nameFlags);
MakeRptCmt(0x0001F790, "Run low coolant detection if coolant is above this.\nDegrees C");
MakeNameEx(0x0001F792, "VEH_SYS_KE_LOW_COOLANT_NOT_PRESENT_TIME", nameFlags);
MakeRptCmt(0x0001F792, "Time that low coolant input has to off to reset the low coolant flag.\nSeconds");
MakeNameEx(0x0001F794, "VEH_SYS_KE_LOW_COOLANT_RAMP_DECAY_DELAY", nameFlags);
MakeRptCmt(0x0001F794, "Delay between ramp delay actions.\nSeconds");
MakeNameEx(0x0001F796, "VEH_SYS_KE_LOW_COOLANT_RAMP_DECAY_STEP", nameFlags);
MakeRptCmt(0x0001F796, "Ramp decay value.\nSeconds");
MakeNameEx(0x0001F798, "VEH_SYS_KE_LOW_COOLANT_TIMER_MAX_VALUE", nameFlags);
MakeRptCmt(0x0001F798, "Max value for low coolant level timer.\nSeconds");
MakeNameEx(0x0001F79A, "VEH_SYS_KV_LOW_COOL_VEH_SPEED_RAMP_MULT", nameFlags);
MakeRptCmt(0x0001F79A, "Converts acceleration into time for low coolant time threshold.\nFactor");
MakeNameEx(0x0001F7AC, "VEH_SYS_KV_LOW_COOLANT_ACCEL_FACTOR", nameFlags);
MakeRptCmt(0x0001F7AC, "Converts acceleration into time for low coolant time threshold.\nSeconds");
MakeNameEx(0x0001F7CE, "VEH_SYS_KV_LOW_COOLANT_ACCEL_RAMP_MULT", nameFlags);
MakeRptCmt(0x0001F7CE, "Converts acceleration into time for low coolant time threshold.\nSeconds");
MakeNameEx(0x0001F7F0, "VEH_SYS_KV_LOW_COOLANT_VEH_SPEED_FACTOR", nameFlags);
MakeRptCmt(0x0001F7F0, "Converts vehicle speed into time for low coolant time threshold.\nSeconds");
MakeNameEx(0x0001F812, "VEH_SYS_KE_ENGINE_OVERSPEED_BULB_CHECK", nameFlags);
MakeRptCmt(0x0001F812, "Time to illuminate engine overspeed lamp on startup for bulb test Set to zero to disable bulb check.\nSeconds");
MakeNameEx(0x0001F814, "VEH_SYS_KE_CONTROL_ENGINE_OVERSPEED_LAMP", nameFlags);
MakeRptCmt(0x0001F814, "If set TRUE, enables control of the overspeed lamp via hardware.\nBOOLEAN");
MakeNameEx(0x0001F815, "VEH_SYS_KE_ENGINE_ALARM_ENABLE", nameFlags);
MakeRptCmt(0x0001F815, "If set TRUE, then execute engine alarm or shut down functionality.\nBOOLEAN");
MakeNameEx(0x0001F816, "VEH_SYS_KE_IGNORE_VEHICLE_SPEED_FAULT", nameFlags);
MakeRptCmt(0x0001F816, "If TRUE algorithm will execute even if there is a VehicleSpeed Group Fault.\nBOOLEAN");
MakeNameEx(0x0001F817, "VEH_SYS_KE_VUNLOCK_USED", nameFlags);
MakeRptCmt(0x0001F817, "Indicates if the Vunlock ignition switch wiring scheme is on the vehicle.\nBOOLEAN");
MakeNameEx(0x0001F818, "VEH_SYS_KE_ALT_DG_RESULTS_DISPLAY_METHOD", nameFlags);
MakeRptCmt(0x0001F818, "Method of displaying the alternator diagnostic results.\nDisplay_Type");
MakeNameEx(0x0001F819, "VEH_SYS_KE_ALTERNATOR_DIAGNOSTIC_TO_RUN", nameFlags);
MakeRptCmt(0x0001F819, "This enables/disables the different alternator diagnostics.\nAlternator_Diag_Type");
MakeNameEx(0x0001F81A, "VEH_SYS_KE_AFTER_MARKET_PTO_POSSIBLE", nameFlags);
MakeRptCmt(0x0001F81A, "Denotes that the vehicle platform has the possibility of an aftermarket power take off device being connected.\nBOOLEAN");
MakeNameEx(0x0001F81B, "C2_J2190_MSGS_KE_VULNERABILITY_FLAG", nameFlags);
MakeRptCmt(0x0001F81B, "Bypass Data Link Security to PCM. 0FFH indicates PCM is unlocked.\nSHORTCARD");
MakeNameEx(0x0001F81C, "AIR_CONDITIONING_KE_AUTO_RECIRCULATION_OPTION", nameFlags);
MakeRptCmt(0x0001F81C, "Auto recirculation mode is present on vehicle.\nboolean");
MakeNameEx(0x0001F81E, "AIR_CONDITIONING_KV_AC_PRESSURE_CONVERSION", nameFlags);
MakeRptCmt(0x0001F81E, "Convert Raw, non-linear, AD input for AC pressure transducerto units of PSI\nPSI");
MakeNameEx(0x0001F842, "AIR_CONDITIONING_KE_TYPE_OF_AC_ON_VEHICLE", nameFlags);
MakeRptCmt(0x0001F842, "Type of Air Conditioning System supported\nUnitless");
MakeNameEx(0x0001F844, "AIR_CONDITIONING_KE_AC_SLUGGING_MAX_ALLOWABLE_TIM", nameFlags);
MakeRptCmt(0x0001F844, "When AC activated, it is turned off after this much time.\nSeconds");
MakeNameEx(0x0001F846, "AIR_CONDITIONING_KE_AC_STATUS_INPUT_EQUIPPED", nameFlags);
MakeRptCmt(0x0001F846, "Set to TRUE if AC clutch relay feedback is hard wired to a PCM on a vehicle.\nBOOLEAN");
MakeNameEx(0x0001F848, "AIR_CONDITIONING_KE_IGN_VOLT_LOW_DISABLE_SLUGGING", nameFlags);
MakeRptCmt(0x0001F848, "AC slugging will not be enabled during crank when ignition voltage is below this value .\nVolts");
MakeNameEx(0x0001F84A, "AIR_CONDITIONING_KE_REFERENCE_PULSES_AC_SLUGGING", nameFlags);
MakeRptCmt(0x0001F84A, "Keep A/C enabled for at least this many reference pulses.\nCounts");
MakeNameEx(0x0001F84C, "AIR_CONDITIONING_KE_AC_REQUEST_DEBOUNCE_TIME", nameFlags);
MakeRptCmt(0x0001F84C, "Determines how long the AC Request must stay in a statebefore a state change is allowed.\nSeconds");
MakeNameEx(0x0001F84E, "AIR_CONDITIONING_KE_AC_STARTUP_FAST_DEBOUNCE_TIME", nameFlags);
MakeNameEx(0x0001F850, "AIR_CONDITIONING_KE_AC_INITIAL_STARTUP_WINDOW", nameFlags);
MakeNameEx(0x0001F852, "AIR_CONDITIONING_KE_AC_ENGINE_SPEED_TIME", nameFlags);
MakeRptCmt(0x0001F852, "Amount of continuous time in which the engine speed has been maintained to disable air conditioner.\nSeconds");
MakeNameEx(0x0001F854, "AIR_CONDITIONING_KE_AC_TURN_OFF_DELAY", nameFlags);
MakeRptCmt(0x0001F854, "A/C turn off delay to prevent engine flare.\nSeconds");
MakeNameEx(0x0001F856, "AIR_CONDITIONING_KE_AC_HIGH_TPS_RE_ENABLE_TIME", nameFlags);
MakeRptCmt(0x0001F856, "Time in which wide open throttle launch disable is to last\nSeconds");
MakeNameEx(0x0001F858, "AIR_CONDITIONING_KE_AC_LOW_TPS_RE_ENABLE_TIME", nameFlags);
MakeRptCmt(0x0001F858, "Time in which power enrichment launch disable is to last\nSeconds");
MakeNameEx(0x0001F85A, "AIR_CONDITIONING_KE_AC_HIGH_TPS_REPEAT_TIME", nameFlags);
MakeRptCmt(0x0001F85A, "Time in which high TPS AC disables are not allowed after the first disable.\nSeconds");
MakeNameEx(0x0001F85C, "AIR_CONDITIONING_KE_AC_ENGINE_SPEED_LOWER_LIMIT", nameFlags);
MakeRptCmt(0x0001F85C, "Enable A/C if engine speed is below this threshold.\nRPM");
MakeNameEx(0x0001F85E, "AIR_CONDITIONING_KE_AC_ENGINE_SPEED_UPPER_LIMIT", nameFlags);
MakeRptCmt(0x0001F85E, "Disable A/C if engine speed is above this threshold.\nRPM");
MakeNameEx(0x0001F860, "AIR_CONDITIONING_KE_AC_SLUGGING_ENG_SPEED_ENABLE", nameFlags);
MakeRptCmt(0x0001F860, "Activate AC slugging if engine RPM is greater than this value\nRPM");
MakeNameEx(0x0001F862, "AIR_CONDITIONING_KE_AC_SLUGGING_ENG_SPEED_TURN_OF", nameFlags);
MakeRptCmt(0x0001F862, "When AC slugging is activated it is turned off wheneng speed reaches this level\nRPM");
MakeNameEx(0x0001F864, "AIR_CONDITIONING_KE_AC_HOT_COOLANT_LOWER_LIMIT", nameFlags);
MakeRptCmt(0x0001F864, "Enable A/C if coolant temperature is below this threshold.\nDegrees_C");
MakeNameEx(0x0001F866, "AIR_CONDITIONING_KE_AC_HOT_COOLANT_UPPER_LIMIT", nameFlags);
MakeRptCmt(0x0001F866, "Disable A/C if coolant temperature is above this threshold.\nDegrees_C");
MakeNameEx(0x0001F868, "AIR_CONDITIONING_KE_AC_COOLANT_TEMP_SLUGGING_HIGH", nameFlags);
MakeRptCmt(0x0001F868, "Activate AC Slugging if coolant temp. is below this value\nDegrees_C");
MakeNameEx(0x0001F86A, "AIR_CONDITIONING_KE_AC_SLUGGING_IAT", nameFlags);
MakeRptCmt(0x0001F86A, "Activate AC slugging if Induction Air Temp is above this value\nDegrees_C");
MakeNameEx(0x0001F86C, "AIR_CONDITIONING_KE_AC_SLUGGING_IAT_LAST_KEY_OFF", nameFlags);
MakeRptCmt(0x0001F86C, "Activate AC slugging if Induction Air Temp at last keyoff isabove this value\nDegrees_C");
MakeNameEx(0x0001F86E, "AIR_CONDITIONING_KE_AC_HIGH_TPS_DISABLE_THRESHOLD", nameFlags);
MakeRptCmt(0x0001F86E, "Throttle position in which AC needs to be disabled\nPercent");
MakeNameEx(0x0001F870, "AIR_CONDITIONING_KE_AC_HIGH_TPS_RE_ENABLE_THRESH", nameFlags);
MakeRptCmt(0x0001F870, "Throttle Position in which launch disable can be seperated fromWOT disable\nPercent");
MakeNameEx(0x0001F872, "AIR_CONDITIONING_KE_AC_VEH_SPEED_LAUNCH_DISABLE", nameFlags);
MakeNameEx(0x0001F874, "AIR_CONDITIONING_KE_AC_VEHICLE_SPEED_RE_ENABLE", nameFlags);
MakeNameEx(0x0001F876, "AIR_CONDITIONING_KE_AC_HIGH_PRESSURE_UPPER_LIMIT", nameFlags);
MakeRptCmt(0x0001F876, "Disable A/C if pressure is above this threshold.\nPSI");
MakeNameEx(0x0001F878, "AIR_CONDITIONING_KE_AC_HIGH_PRESSURE_LOWER_LIMIT", nameFlags);
MakeRptCmt(0x0001F878, "Enable A/C if pressure is below this threshold.\nPSI");
MakeNameEx(0x0001F87A, "AIR_CONDITIONING_KE_AC_LOW_PRESSURE_LOWER_LIMIT", nameFlags);
MakeRptCmt(0x0001F87A, "Disable A/C if pressure is below this threshold.\nPSI");
MakeNameEx(0x0001F87C, "AIR_CONDITIONING_KE_AC_LOW_PRESSURE_UPPER_LIMIT", nameFlags);
MakeRptCmt(0x0001F87C, "Enable A/C if pressure is above this threshold.\nPSI");
MakeNameEx(0x0001F87E, "AIR_CONDITIONING_KE_AC_PRESSURE_SLUGGING", nameFlags);
MakeRptCmt(0x0001F87E, "Enable A/C if air conditioner pressure is above this threshold.\nPSI");
MakeNameEx(0x0001F880, "AIR_CONDITIONING_KE_AC_LOW_VOLTAGE_UPPER_LIMIT", nameFlags);
MakeRptCmt(0x0001F880, "AC compressor not allowed to engaged at voltage belowthis value. If compressor already engaged it willstay on.\nvolts");
MakeNameEx(0x0001F882, "AIR_CONDITIONING_KE_AC_LOW_VOLTAGE_LOWER_LIMIT", nameFlags);
MakeRptCmt(0x0001F882, "AC compressor is disengaged when voltage drops below this value.\nvolts");
MakeNameEx(0x0001F884, "AIR_CONDITIONING_KE_AUTO_RECIRC_ENABLE_DELAY_TIME", nameFlags);
MakeRptCmt(0x0001F884, "Recirc mode enable delay after conditions are met.\nseconds");
MakeNameEx(0x0001F886, "AIR_CONDITIONING_KE_AUTO_RECIRC_MIN_ON_TIME", nameFlags);
MakeRptCmt(0x0001F886, "Minimum time that Auto Recirc mode must be enabled.\nseconds");
MakeNameEx(0x0001F888, "AIR_CONDITIONING_KE_AUTO_RECIRC_ON_MPH", nameFlags);
MakeRptCmt(0x0001F888, "Vehicle speed below which Auto Recirc mode is enabled for high pressure.\nMPH");
MakeNameEx(0x0001F88A, "AIR_CONDITIONING_KE_AUTO_RECIRC_OFF_MPH", nameFlags);
MakeRptCmt(0x0001F88A, "Vehicle speed above which Auto Recirc mode is disabled.\nMPH");
MakeNameEx(0x0001F88C, "AIR_CONDITIONING_KE_AC_PRESSURE_INITIAL_DELAY_TIM", nameFlags);
MakeNameEx(0x0001F88E, "AIR_CONDITIONING_KE_AC_TPS_DISABLE_FOR_POLICE", nameFlags);
MakeRptCmt(0x0001F88E, "Set to TRUE on Police vehicles. This forces AC off for the entire ignition cycle to give them more power for chases.\nBOOLEAN");
MakeNameEx(0x0001F88F, "AIR_CONDITIONING_KE_AC_GEARS_FOR_LAUNCH_DISABLE", nameFlags);
MakeRptCmt(0x0001F88F, "Actual transmission gear that is less than or equal to this that allows AC to be disabled by TPS.\nGear");
MakeNameEx(0x0001F890, "AIR_CONDITIONING_KV_AC_MINIMUM_OFF_TIME", nameFlags);
MakeRptCmt(0x0001F890, "Minimum duration of clutch disable.\nSeconds");
MakeNameEx(0x0001F8A6, "AIR_CONDITIONING_KV_AC_IAT_ON_DELAY_TIME", nameFlags);
MakeRptCmt(0x0001F8A6, "A/C turn on delay to prevent engine stall.\nSeconds");
MakeNameEx(0x0001F8CC, "ALTERNATOR_KE_P1637_FAIL_LIMIT", nameFlags);
MakeRptCmt(0x0001F8CC, "The number of sample of failed conditions to set P1637.\nNONE 0-255");
MakeNameEx(0x0001F8CD, "ALTERNATOR_KE_P1637_SAMPLE_PERIOD", nameFlags);
MakeRptCmt(0x0001F8CD, "The number of sample periods over which the  Alternator L-Terminal Diagnostic is to run.\nNONE 0-255");
MakeNameEx(0x0001F8CE, "ALTERNATOR_KE_VALT_P1638_FAIL_LIMIT", nameFlags);
MakeRptCmt(0x0001F8CE, "Number of sample periods that F-Terminal failure has been detected to report P1638 failure.\nNONE 0-255");
MakeNameEx(0x0001F8CF, "ALTERNATOR_KE_VALT_P1638_SAMPLE_PERIOD", nameFlags);
MakeRptCmt(0x0001F8CF, "The number of sample periods over which the  Alternator F-Terminal Diagnostic is to run.\nNONE 0-255");
MakeNameEx(0x0001F8D0, "ALTERNATOR_KE_VALT_MIN_NORMAL_RUNNING_DC", nameFlags);
MakeRptCmt(0x0001F8D0, "With L Term HI and Engine running: when Field Duty Cycle is less than this, set P1638 code.\nPercent");
MakeNameEx(0x0001F8D2, "ALTERNATOR_KE_VALT_L_SHORTED_HOT_F_OPEN_DC", nameFlags);
MakeRptCmt(0x0001F8D2, "With L Term HI and Engine not running: when Field Duty Cycle is less than this set P1637 & P1637.\nPercent");
MakeNameEx(0x0001F8D4, "ALTERNATOR_KE_VALT_L_SHORTED_HOT_DC", nameFlags);
MakeRptCmt(0x0001F8D4, "With L Term HI and Engine nor running: when Field Duty Cycle is is equal to this with hystersis set P1637.\nPercent");
MakeNameEx(0x0001F8D6, "ALTERNATOR_KE_VALT_F_AND_L_SHORTED_HOT_DC", nameFlags);
MakeRptCmt(0x0001F8D6, "With L Term HI and Engine not running: when Field Duty Cycle is greater than this, set P1637 & P1638.\nPercent");
MakeNameEx(0x0001F8D8, "ALTERNATOR_KE_VALT_L_SHORT_TO_GND_DC", nameFlags);
MakeRptCmt(0x0001F8D8, "With L Term  LO and Engine running: when Field Duty Cycle is  less than this set P1637 & P1638 else set P1637.\nPercent");
MakeNameEx(0x0001F8DA, "ALTERNATOR_KE_VALT_FIELD_OR_WIRING_FAULT_DC", nameFlags);
MakeRptCmt(0x0001F8DA, "With L Term LO and Engine Not running: When Field Duty Cycle less than this set P1638.\nPercent");
MakeNameEx(0x0001F8DC, "ALTERNATOR_KE_VALT_POWERUP_DC", nameFlags);
MakeRptCmt(0x0001F8DC, "With L Term LO  and Engine nor running: when Field Duty Cycle is  equal to this with hysteresis clear codes.\nPercent");
MakeNameEx(0x0001F8DE, "ALTERNATOR_KE_VALT_F_SHORTED_HOT_DC", nameFlags);
MakeRptCmt(0x0001F8DE, "With L Term LO and engine not running: when Field Duty Cycle is Greater than this set P1638.\nPercent");
MakeNameEx(0x0001F8E0, "ALTERNATOR_KE_VALT_DC_HYSTERESIS", nameFlags);
MakeRptCmt(0x0001F8E0, "Used as hysteresis on the normal powerup mode and L Term shorted to 12v  mode calibrations.\nPercent");
MakeNameEx(0x0001F8E2, "C2_DC_DEFINITION_KE_DEV_CNTL_GEAR_RPM_LIMIT", nameFlags);
MakeRptCmt(0x0001F8E2, "The maximum engine rpm allowed for gear device control.\nRPM");
MakeNameEx(0x0001F8E4, "C2_DC_DEFINITION_KE_DEV_CNTL_32_VEHICLE_SPEED_LIM", nameFlags);
MakeRptCmt(0x0001F8E4, "The maximum vehicle speed allowed for 32 gear down shiftdevice control.\nMPH");
MakeNameEx(0x0001F8E6, "C2_DC_DEFINITION_KE_DEV_CNTL_21_VEHICLE_SPEED_LIM", nameFlags);
MakeRptCmt(0x0001F8E6, "The maximum engine rpm allowed for 21 gear down shiftdevice control.\nMPH");
MakeNameEx(0x0001F8E8, "C2_EXECUTIVE_KE_C2_IGN_VOLT_THRESH", nameFlags);
MakeRptCmt(0x0001F8E8, "Ignition voltage threshold below which U-codes aredisabled.\nVolts");
MakeNameEx(0x0001F8EA, "C2_EXECUTIVE_KE_C2_PASS_IGN_VOLT_TIME", nameFlags);
MakeRptCmt(0x0001F8EA, "Minimum time ignition voltage must be high tore-enable U-codes\nSeconds");
MakeNameEx(0x0001F8EC, "C2_EXECUTIVE_KE_C2_SHORT_TO_GROUND_DIAG_TIME", nameFlags);
MakeNameEx(0x0001F8EE, "C2_EXECUTIVE_KE_C2_SHORT_TO_HIGH_DIAG_TIME", nameFlags);
MakeNameEx(0x0001F8F0, "C2_EXECUTIVE_KE_MS_C2_INIT_PHASE2_DELAY", nameFlags);
MakeRptCmt(0x0001F8F0, "Wait this amount of time after phase 1 has started before starting phase 2.\nSeconds");
MakeNameEx(0x0001F8F2, "C2_EXECUTIVE_KE_MS_C2_INIT_PHASE3_DELAY", nameFlags);
MakeRptCmt(0x0001F8F2, "Wait this amount of time after phase 2 has started before starting phase 3.\nSeconds");
MakeNameEx(0x0001F8F4, "C2_EXECUTIVE_KE_MS_C2_INIT_PHASE4_DELAY", nameFlags);
MakeRptCmt(0x0001F8F4, "Wait this amount of time after phase 3 has started before starting phase 4.\nSeconds");
MakeNameEx(0x0001F8F6, "C2_EXECUTIVE_KE_MS_C2_FIRST_RETRY_INTERVAL", nameFlags);
MakeRptCmt(0x0001F8F6, "Re-queue Class2 serial data message if expected response  is not received after this many 100 millisecond intervals.\nCounts");
MakeNameEx(0x0001F8F7, "C2_EXECUTIVE_KE_MS_C2_SUBSQNT_RETRY_INTERVAL", nameFlags);
MakeNameEx(0x0001F8F8, "C2_EXECUTIVE_KE_MS_C2_MAX_RETRY_LIMIT", nameFlags);
MakeRptCmt(0x0001F8F8, "Stop re-queuing Class2 serial data message afterthis many retries. The Class2 node is now failed.\nCounts");
MakeNameEx(0x0001F8FA, "C2_NORMAL_MSGS_KE_C2_1211_HIGH_SPEED", nameFlags);
MakeRptCmt(0x0001F8FA, "The vehicle speed must be less than this to allow 12.5 msec check for queuing msg 1211\nMPH");
MakeNameEx(0x0001F8FC, "C2_NORMAL_MSGS_KE_1211_SLOWDOWN_FOR_MEC", nameFlags);
MakeRptCmt(0x0001F8FC, "If set TRUE, activates the Allison 12-11 RPT message slow rate logic when Manufacturers Enable Counter is not zero\nBoolean");
MakeNameEx(0x0001F8FD, "C2_NORMAL_MSGS_KE_1211_SLOWDOWN_FOR_DIAG_TOOL", nameFlags);
MakeRptCmt(0x0001F8FD, "If set TRUE, activates the Allison 12-11 RPT message slow rate logic when a diagnostic tool is present\nBoolean");
MakeNameEx(0x0001F8FE, "C2_NORMAL_MSGS_KE_1211_SLOWDOWN_FOR_PRMD_DELTA", nameFlags);
MakeRptCmt(0x0001F8FE, "This time must be exceeded before the the Allison 12-11 RPT message fast rate logic will be allowed\nSeconds");
MakeNameEx(0x0001F900, "C2_NORMAL_MSGS_KE_C2_AC_CLUTCH_ENGAGED_MIN_INTE", nameFlags);
MakeNameEx(0x0001F902, "C2_NORMAL_MSGS_KE_C2_AC_PRESSURE_MIN_INTERVAL", nameFlags);
MakeNameEx(0x0001F904, "C2_NORMAL_MSGS_KE_C2_AC_PRESSURE_DEFAULT_VALUE", nameFlags);
MakeRptCmt(0x0001F904, "This is default value used for failsoft report.\nPSI");
MakeNameEx(0x0001F906, "C2_NORMAL_MSGS_KE_C2_AC_PRESSURE_SEND_ON_CHANGE", nameFlags);
MakeNameEx(0x0001F908, "C2_NORMAL_MSGS_KE_C2_ACCUMULATED_FUEL_MIN_INTER", nameFlags);
MakeNameEx(0x0001F90A, "C2_NORMAL_MSGS_KE_C2_ACCUMULATED_FUEL_SEND_ON_C", nameFlags);
MakeNameEx(0x0001F90C, "C2_NORMAL_MSGS_KE_C2_BAROMETRIC_PRESSURE_MIN_IN", nameFlags);
MakeRptCmt(0x0001F90C, "The minimum required elapsed time before a F211 RPT message is queued due to a baro change.\nSeconds");
MakeNameEx(0x0001F90E, "C2_NORMAL_MSGS_KE_C2_BAROMETRIC_PRESSURE_SEND_O", nameFlags);
MakeNameEx(0x0001F910, "C2_NORMAL_MSGS_KE_C2_CLUTCH_PEDAL_DEP_MIN_INT", nameFlags);
MakeNameEx(0x0001F912, "C2_NORMAL_MSGS_KE_C2_COOLANT_TEMPERATURE_MIN_IN", nameFlags);
MakeNameEx(0x0001F914, "C2_NORMAL_MSGS_KE_C2_COOLANT_TEMP_MAX", nameFlags);
MakeNameEx(0x0001F916, "C2_NORMAL_MSGS_KE_C2_COOL_TEMP_LIMIT_RUNTIME", nameFlags);
MakeRptCmt(0x0001F916, "Class 2 coolant temperature will be limited to KE_C2_Coolant_Temp  for this amount of time.\nSeconds");
MakeNameEx(0x0001F91A, "C2_NORMAL_MSGS_KE_C2_COOLANT_TEMPERATURE_SEND_O", nameFlags);
MakeNameEx(0x0001F91C, "C2_NORMAL_MSGS_KE_C2_CRUISE_MEMORY_SPEED_MIN_IN", nameFlags);
MakeNameEx(0x0001F91E, "C2_NORMAL_MSGS_KE_C2_CRUISE_MEMORY_SPEED_SEND_O", nameFlags);
MakeNameEx(0x0001F920, "C2_NORMAL_MSGS_KE_C2_CURRENT_GEAR_MIN_INTERVAL", nameFlags);
MakeNameEx(0x0001F922, "C2_NORMAL_MSGS_KE_C2_ENG_FAN_SPEED_MIN_INTERVAL", nameFlags);
MakeRptCmt(0x0001F922, "Minimum required elapsed time since C2_4801_RPT_Eng_Fan_Speed was last queued for transmission on Class 2 bus.\nSeconds");
MakeNameEx(0x0001F924, "C2_NORMAL_MSGS_KE_C2_ENG_FAN_SPD_SEND_ON_CHANGE", nameFlags);
MakeNameEx(0x0001F926, "C2_NORMAL_MSGS_KE_C2_ENG_TORQ_MIN_INTERVAL", nameFlags);
MakeNameEx(0x0001F928, "C2_NORMAL_MSGS_KE_C2_ENG_TORQ_SEND_ON_CHANGE", nameFlags);
MakeNameEx(0x0001F92A, "C2_NORMAL_MSGS_KE_C2_ENGINE_OIL_PRESSURE_DEFAUL", nameFlags);
MakeRptCmt(0x0001F92A, "This is default value used for failsoft report.\nkPa_L_S");
MakeNameEx(0x0001F92E, "C2_NORMAL_MSGS_KE_C2_ENGINE_OIL_PRESSURE_MIN_IN", nameFlags);
MakeNameEx(0x0001F930, "C2_NORMAL_MSGS_KE_C2_ENGINE_OIL_PRESSURE_SEND_O", nameFlags);
MakeNameEx(0x0001F934, "C2_NORMAL_MSGS_KE_C2_ENGINE_SPEED_DEFAULT_VALUE", nameFlags);
MakeRptCmt(0x0001F934, "This is default value used for failsoft report.\nRPM");
MakeNameEx(0x0001F936, "C2_NORMAL_MSGS_KE_C2_ENGINE_SPEED_MIN_INTERVAL", nameFlags);
MakeNameEx(0x0001F938, "C2_NORMAL_MSGS_KE_C2_ENGINE_SPEED_SEND_ON_CHANG", nameFlags);
MakeNameEx(0x0001F93A, "C2_NORMAL_MSGS_KE_C2_FE06_REQ_DELAY_TIME1", nameFlags);
MakeRptCmt(0x0001F93A, "The minimum required elapsed time before a FE06 REQ message is queued due to a local PCM power  mode change.\nSeconds");
MakeNameEx(0x0001F93C, "C2_NORMAL_MSGS_KE_C2_FE06_REQ_DELAY_TIME2", nameFlags);
MakeRptCmt(0x0001F93C, "The minimum required elapsed time before a FE06 REQ message is queued due to the PCM being capable of communicating on class2.\nSeconds");
MakeNameEx(0x0001F93E, "C2_NORMAL_MSGS_KE_C2_LOCAL_POWERMODE_CONTROL", nameFlags);
MakeRptCmt(0x0001F93E, "Set TRUE if PCM is local power mode master meaning application does not use FE06 system power mode control.\nBoolean");
MakeNameEx(0x0001F940, "C2_NORMAL_MSGS_KE_C2_FUEL_PERCENT_DEFAULT_VALUE", nameFlags);
MakeRptCmt(0x0001F940, "This is default value used for failsoft report.\nPercent");
MakeNameEx(0x0001F942, "C2_NORMAL_MSGS_KE_C2_FUEL_PERCENT_MIN_INTERVAL", nameFlags);
MakeNameEx(0x0001F944, "C2_NORMAL_MSGS_KE_C2_FUEL_PERCENT_SEND_ON_CHANG", nameFlags);
MakeNameEx(0x0001F946, "C2_NORMAL_MSGS_KE_C2_FUEL_VOLUME_DEFAULT_VALUE", nameFlags);
MakeRptCmt(0x0001F946, "This is default value used for failsoft report.\nLiters");
MakeNameEx(0x0001F948, "C2_NORMAL_MSGS_KE_C2_FUEL_VOLUME_MIN_INTERVAL", nameFlags);
MakeNameEx(0x0001F94A, "C2_NORMAL_MSGS_KE_C2_FUEL_VOLUME_SEND_ON_CHANGE", nameFlags);
MakeNameEx(0x0001F94C, "C2_NORMAL_MSGS_KE_C2_HVAC_AUTO_RECIRC_MIN_INTER", nameFlags);
MakeRptCmt(0x0001F94C, "The minimum required elapsed time before a B230 RPTmessage is queued.\nSeconds");
MakeNameEx(0x0001F94E, "C2_NORMAL_MSGS_KE_C2_INDUCTION_AIR_TEMP_MIN_INT", nameFlags);
MakeNameEx(0x0001F950, "C2_NORMAL_MSGS_KE_C2_INDUCTION_AIR_TEMP_SEND_ON", nameFlags);
MakeNameEx(0x0001F952, "C2_NORMAL_MSGS_KE_C2_INSTANTANEOUS_FUEL_MIN_INT", nameFlags);
MakeNameEx(0x0001F954, "C2_NORMAL_MSGS_KE_C2_INSTANTANEOUS_FUEL_SEND_ON", nameFlags);
MakeNameEx(0x0001F956, "C2_NORMAL_MSGS_KE_C2_OIL_LIFE_REMAINING_MIN_INT", nameFlags);
MakeNameEx(0x0001F958, "C2_NORMAL_MSGS_KE_C2_OIL_LIFE_REMAINING_SEND_ON", nameFlags);
MakeNameEx(0x0001F95A, "C2_NORMAL_MSGS_KE_C2_PARK_NEUTRAL_SW_ACTIVE_MIN", nameFlags);
MakeNameEx(0x0001F95C, "C2_NORMAL_MSGS_KE_C2_PEDAL_LOAD_MIN_INTERVAL", nameFlags);
MakeNameEx(0x0001F95E, "C2_NORMAL_MSGS_KE_C2_PEDAL_LOAD_SEND_ON_CHANGE", nameFlags);
MakeNameEx(0x0001F960, "C2_NORMAL_MSGS_KE_C2_POWERTRAIN_NODE_ALIVE_PERI", nameFlags);
MakeNameEx(0x0001F962, "C2_NORMAL_MSGS_KE_C2_PRNDL_DISPLAY_INTERVAL", nameFlags);
MakeNameEx(0x0001F964, "C2_NORMAL_MSGS_KE_C2_PRNDL_POSITION_MIN_INTERVA", nameFlags);
MakeNameEx(0x0001F966, "C2_NORMAL_MSGS_KE_C2_PT_TCS_FAILURE_STATUS_MIN_", nameFlags);
MakeNameEx(0x0001F968, "C2_NORMAL_MSGS_KE_C2_ROLLING_ODO_MIN_INTERVAL", nameFlags);
MakeNameEx(0x0001F96A, "C2_NORMAL_MSGS_KE_C2_ROLLING_ODO_SEND_ON_CHANGE", nameFlags);
MakeNameEx(0x0001F96E, "C2_NORMAL_MSGS_KE_C2_TCC_BRAKE_DEPRESSED_MIN_IN", nameFlags);
MakeNameEx(0x0001F970, "C2_NORMAL_MSGS_KE_C2_TRANSMISSION_OIL_TEMP_MIN_", nameFlags);
MakeNameEx(0x0001F972, "C2_NORMAL_MSGS_KE_C2_TRANSMISSION_OIL_TEMP_SEND", nameFlags);
MakeNameEx(0x0001F974, "C2_NORMAL_MSGS_KE_C2_VEHICLE_SPEED_MIN_INTERVAL", nameFlags);
MakeNameEx(0x0001F976, "C2_NORMAL_MSGS_KE_C2_VEHICLE_SPEED_SEND_ON_CHAN", nameFlags);
MakeNameEx(0x0001F978, "C2_NORMAL_MSGS_KE_C2_HI_RES_VEH_SPD_MIN_INTERVL", nameFlags);
MakeNameEx(0x0001F97A, "C2_NORMAL_MSGS_KE_C2_HI_RES_VEH_SPD_SEND_ON_CHG", nameFlags);
MakeNameEx(0x0001F97C, "C2_NORMAL_MSGS_KE_C2_IGNITION_VOLT_MIN_INTERVAL", nameFlags);
MakeNameEx(0x0001F97E, "C2_NORMAL_MSGS_KE_C2_IGNITION_VOLT_SEND_ON_CHG", nameFlags);
MakeNameEx(0x0001F980, "C2_NORMAL_MSGS_KE_ENGINECOOLANTHOTHI", nameFlags);
MakeNameEx(0x0001F982, "C2_NORMAL_MSGS_KE_ENGINECOOLANTHOTLO", nameFlags);
MakeNameEx(0x0001F984, "C2_NORMAL_MSGS_KE_ENGHOT_STOPENG_TEMPHI", nameFlags);
MakeNameEx(0x0001F986, "C2_NORMAL_MSGS_KE_ENGHOT_STOPENG_TEMPLO", nameFlags);
MakeNameEx(0x0001F988, "C2_NORMAL_MSGS_KE_TCS_FAILURE_STATUS_BITS_SUPPO", nameFlags);
MakeRptCmt(0x0001F988, "This calibration indicates support or non-support ofa particular powertrain traction control failure status.\nTCS_Failure_Status_Record_Type");
MakeNameEx(0x0001F98A, "C2_TX_MSGS_KV_C2_MSGS_ALLOWED_AT_MODE7_P1", nameFlags);
MakeRptCmt(0x0001F98A, "Class2 msgs allowed during run phase 1\nTx_Msg_ID_Record_Type");
MakeNameEx(0x0001F99C, "C2_TX_MSGS_KV_C2_MSGS_QUEUED_AT_MODE7_P1", nameFlags);
MakeRptCmt(0x0001F99C, "Class2 msgs queued during run phase 1\nTx_Msg_ID_Record_Type");
MakeNameEx(0x0001F9AE, "C2_TX_MSGS_KV_C2_MSGS_ALLOWED_AT_MODE7_P2", nameFlags);
MakeRptCmt(0x0001F9AE, "Class2 msgs allowed during run phase 2\nTx_Msg_ID_Record_Type");
MakeNameEx(0x0001F9C0, "C2_TX_MSGS_KV_C2_MSGS_ALLOWED_AT_MODE7_P3", nameFlags);
MakeRptCmt(0x0001F9C0, "Class2 msgs allowed during run phase 3\nTx_Msg_ID_Record_Type");
MakeNameEx(0x0001F9D2, "C2_TX_MSGS_KV_C2_MSGS_ALLOWED_AT_MODE7_P4", nameFlags);
MakeRptCmt(0x0001F9D2, "Class2 msgs allowed during run phase 4\nTx_Msg_ID_Record_Type");
MakeNameEx(0x0001F9E4, "C2_TX_MSGS_KV_C2_MSGS_ALLOWED_AT_MODE8_P1", nameFlags);
MakeRptCmt(0x0001F9E4, "Class2 msgs allowed during crank phase 1\nTx_Msg_ID_Record_Type");
MakeNameEx(0x0001F9F6, "C2_TX_MSGS_KV_C2_MSGS_QUEUED_AT_MODE8_P1", nameFlags);
MakeRptCmt(0x0001F9F6, "Class2 msgs queued during crank phase 1\nTx_Msg_ID_Record_Type");
MakeNameEx(0x0001FA08, "C2_TX_MSGS_KV_C2_MSGS_ALLOWED_AT_MODE8_P2", nameFlags);
MakeRptCmt(0x0001FA08, "Class2 msgs allowed during crank phase 2\nTx_Msg_ID_Record_Type");
MakeNameEx(0x0001FA1A, "C2_TX_MSGS_KV_C2_MSGS_ALLOWED_AT_MODE10_P1", nameFlags);
MakeRptCmt(0x0001FA1A, "Class2 msgs allowed during powerup phase 1\nTx_Msg_ID_Record_Type");
MakeNameEx(0x0001FA2C, "C2_TX_MSGS_KV_C2_MSGS_QUEUED_AT_MODE10_P1", nameFlags);
MakeRptCmt(0x0001FA2C, "Class2 msgs queued during powerup phase 1\nTx_Msg_ID_Record_Type");
MakeNameEx(0x0001FA3E, "C2_TX_MSGS_KV_C2_MSGS_ALLOWED_AT_MODE28", nameFlags);
MakeRptCmt(0x0001FA3E, "Class2 msgs allowed during mode28 active\nTx_Msg_ID_Record_Type");
MakeNameEx(0x0001FA50, "COLUMN_LOCK_KE_COLUMN_LOCK_PRESENT", nameFlags);
MakeRptCmt(0x0001FA50, "This calibration enables/disables the Column Lockfunctionality. Currently ONLY Y car should be TRUE.\nBoolean");
MakeNameEx(0x0001FA52, "COLUMN_LOCK_KE_COLUMN_LOCK_VSS_FUEL_DISABLE", nameFlags);
MakeRptCmt(0x0001FA52, "Vehicle speed at which the fuel must be discontinuedwhen the steering column can not be unlocked.\nMPH");
MakeNameEx(0x0001FA54, "FAN_CONTROL_KE_AC_PRESSURE_FAN1_HIGH_THRESHO", nameFlags);
MakeRptCmt(0x0001FA54, "Enable the Fan 1 output if AC Pressure is above this threshold\nPSI");
MakeNameEx(0x0001FA56, "FAN_CONTROL_KE_AC_PRESSURE_FAN1_LOW_THRESHOL", nameFlags);
MakeRptCmt(0x0001FA56, "The Fan1 output can be disabled if AC Pressure is below this threshold.\nPSI");
MakeNameEx(0x0001FA58, "FAN_CONTROL_KE_ECT_FAN1_HIGH_THRESHOLD", nameFlags);
MakeRptCmt(0x0001FA58, "Enable the Fan 1 output if coolant temperature is above this threshold.\nDegrees C");
MakeNameEx(0x0001FA5A, "FAN_CONTROL_KE_ECT_FAN1_LOW_THRESHOLD", nameFlags);
MakeRptCmt(0x0001FA5A, "The Fan 1 output can be disabled if Coolant Temperature is belowthis threshold.\nDegrees C");
MakeNameEx(0x0001FA5C, "FAN_CONTROL_KE_ECT_FAN1_AC_ON_THRESHOLD", nameFlags);
MakeNameEx(0x0001FA5E, "FAN_CONTROL_KE_ECT_FAN1_KEYOFF", nameFlags);
MakeRptCmt(0x0001FA5E, "Perform FAN RUNON on the fan1 output after keyoff, if coolanttemp is above this threshold at keyoff.\nDegrees_C");
MakeNameEx(0x0001FA60, "FAN_CONTROL_KE_ENGINE_RUNNING_FAN1_TIME", nameFlags);
MakeRptCmt(0x0001FA60, "The minimum engine run time required to expire before the Fan1output can be enabled.\nSeconds");
MakeNameEx(0x0001FA62, "FAN_CONTROL_KE_FANCOMMAND_FOR_CTS_FAULT", nameFlags);
MakeRptCmt(0x0001FA62, "Percent Fan Command to be forced when coolant sensor is shorted high or low.\nPercent");
MakeNameEx(0x0001FA64, "FAN_CONTROL_KE_HI_VEH_SPD_FANS_OFF_AC_THRESH", nameFlags);
MakeNameEx(0x0001FA66, "FAN_CONTROL_KE_VEHICLE_SPEED_HIGH_AC_FAN1_TH", nameFlags);
MakeRptCmt(0x0001FA66, "Vehicle Speed threshold with AC compressor engaged above whichFan1 output can be turned off.\nMPH");
MakeNameEx(0x0001FA68, "FAN_CONTROL_KE_VEHICLE_SPEED_LOW_AC_FAN1_THR", nameFlags);
MakeRptCmt(0x0001FA68, "Vehicle Speed threshold with AC compressor engaged below which Fan1 output is forced ON.\nMPH");
MakeNameEx(0x0001FA6A, "FAN_CONTROL_KE_MIN_RPM_TO_DETECT_FANLOCKUP", nameFlags);
MakeRptCmt(0x0001FA6A, "Minimum engine speed required to detect fan lockup.\nRPM");
MakeNameEx(0x0001FA6C, "FAN_CONTROL_KE_MINIMUM_FAN1_ON_TIME", nameFlags);
MakeRptCmt(0x0001FA6C, "Minimum amount of time that Fan1 is disabled after the output is turned off.\nSeconds");
MakeNameEx(0x0001FA6E, "FAN_CONTROL_KE_MINIMUM_FAN1_OFF_TIME", nameFlags);
MakeRptCmt(0x0001FA6E, "\nSeconds");
MakeNameEx(0x0001FA70, "FAN_CONTROL_KE_FAN1_DELAY_OFF_AFTER_FAN2_TUR", nameFlags);
MakeRptCmt(0x0001FA70, "Time to delay turning off Fan1 after Fan2 has been turned off.\nSeconds");
MakeNameEx(0x0001FA72, "FAN_CONTROL_KE_FAN2_ON_DELAY_TIME", nameFlags);
MakeRptCmt(0x0001FA72, "Amount of time after fan1 output has been enabled, before fan2 output can be enabled.\nSeconds");
MakeNameEx(0x0001FA74, "FAN_CONTROL_KE_AC_PRESSURE_FAN2_HIGH_THRESHO", nameFlags);
MakeRptCmt(0x0001FA74, "Fan2 output can be disabled if AC Pressure is above this threshold.\nPSI");
MakeNameEx(0x0001FA76, "FAN_CONTROL_KE_AC_PRESSURE_FAN2_LOW_THRESHOL", nameFlags);
MakeRptCmt(0x0001FA76, "Fan2 output can be disabled if AC Pressure is below this threshold.\nPSI");
MakeNameEx(0x0001FA78, "FAN_CONTROL_KE_ECT_FAN2_HIGH_THRESHOLD", nameFlags);
MakeRptCmt(0x0001FA78, "Enable the fan2 output if Coolant Temperature is above thisthreshold.\nDegrees C");
MakeNameEx(0x0001FA7A, "FAN_CONTROL_KE_ECT_FAN2_LOW_THRESHOLD", nameFlags);
MakeRptCmt(0x0001FA7A, "Fan2 output can be disabled if Coolant Temperature is belowthis threshold.\nDegrees_C");
MakeNameEx(0x0001FA7C, "FAN_CONTROL_KE_MINIMUM_FAN2_ON_TIME", nameFlags);
MakeRptCmt(0x0001FA7C, "Minimum amount of time that Fan2 is enabled once it is turned on.\nSeconds");
MakeNameEx(0x0001FA7E, "FAN_CONTROL_KE_FAN1_TURN_ON_DELAY", nameFlags);
MakeRptCmt(0x0001FA7E, "Delay the off to on transition of the Fan1 output, for this amount of time.\nSeconds");
MakeNameEx(0x0001FA80, "FAN_CONTROL_KE_FAN1_TURN_OFF_DELAY", nameFlags);
MakeRptCmt(0x0001FA80, "Delay the on to off transition of the Fan1 output, for this amount of time.\nSeconds");
MakeNameEx(0x0001FA82, "FAN_CONTROL_KE_FAN2_TURN_ON_DELAY", nameFlags);
MakeRptCmt(0x0001FA82, "Delay the off to on transition of the Fan2 output, for this amount of time.\nSeconds");
MakeNameEx(0x0001FA84, "FAN_CONTROL_KE_FAN2_TURN_OFF_DELAY", nameFlags);
MakeRptCmt(0x0001FA84, "Delay the on to off transition of the Fan2 output, for this amount of time.\nSeconds");
MakeNameEx(0x0001FA86, "FAN_CONTROL_KE_FAN1_ON_KEYOFF_TIME", nameFlags);
MakeRptCmt(0x0001FA86, "Amount of time to keep the fan on after the ignition key is turned off for fan runon.\nSeconds");
MakeNameEx(0x0001FA88, "FAN_CONTROL_KE_AC_PRESSUREHIGH", nameFlags);
MakeRptCmt(0x0001FA88, "A thershold of the AC High-side pressure below which a reduction in PCT_Fan_Command is Allowed due to WOT conditions.\nPSI");
MakeNameEx(0x0001FA8A, "FAN_CONTROL_KE_COOLANTTEMPOVERRIDE", nameFlags);
MakeNameEx(0x0001FA8C, "FAN_CONTROL_KE_FANFAILSPEEDRPM", nameFlags);
MakeRptCmt(0x0001FA8C, "Defines the engine speed at which the rotational forces may lead to structural failure for engine driven cooling fans.\nRPM");
MakeNameEx(0x0001FA8E, "FAN_CONTROL_KE_FANLOCKUPTIME", nameFlags);
MakeRptCmt(0x0001FA8E, "If fan speed is above KE_FanFailSpeedRPM for this amount of time, fan is locked up.\nSeconds");
MakeNameEx(0x0001FA90, "FAN_CONTROL_KE_FANSPEED_INCR_RATE_LIMIT", nameFlags);
MakeRptCmt(0x0001FA90, "The maximum rate of increase of Fan Speed Desired.\nRPM");
MakeNameEx(0x0001FA92, "FAN_CONTROL_KE_FANSPEED_DECR_RATE_LIMIT", nameFlags);
MakeRptCmt(0x0001FA92, "The maximum rate of decrease of Fan Speed Desired.\nRPM");
MakeNameEx(0x0001FA94, "FAN_CONTROL_KE_FANSPEEDLOW", nameFlags);
MakeRptCmt(0x0001FA94, "Defines the min fan speed threshold to prevent fan speed from dropping too low.\nRPM");
MakeNameEx(0x0001FA96, "FAN_CONTROL_KE_LOWSPEEDPWM", nameFlags);
MakeRptCmt(0x0001FA96, "This value is commanded for fan speed when the fan speed drops too low.\nPercent");
MakeNameEx(0x0001FA98, "FAN_CONTROL_KE_FANPWRUPDELAY", nameFlags);
MakeRptCmt(0x0001FA98, "Amount of time to delay operating the fans on engine power up for engine idle stabilization.\nSeconds");
MakeNameEx(0x0001FA9A, "FAN_CONTROL_KE_FANRPM_MAX", nameFlags);
MakeRptCmt(0x0001FA9A, "Max possible speed of the fan blades which corresponding to max available fan power.\nRPM");
MakeNameEx(0x0001FA9C, "FAN_CONTROL_KE_FANRPM_OFFSET", nameFlags);
MakeRptCmt(0x0001FA9C, "Min possible speed of the fan blades which corresponding to 0% fan power.\nRPM");
MakeNameEx(0x0001FA9E, "FAN_CONTROL_KE_MAXVEHICLESPEED", nameFlags);
MakeRptCmt(0x0001FA9E, "Maximum speed the vehicle is capable of.\nkPH");
MakeNameEx(0x0001FAA0, "FAN_CONTROL_KE_MAXFANPWMGRADIENTNEG", nameFlags);
MakeRptCmt(0x0001FAA0, "Maximum allowed rate of change in the decreasing direction.\nPercent/Second");
MakeNameEx(0x0001FAA2, "FAN_CONTROL_KE_MAXFANPWMGRADIENTPOS", nameFlags);
MakeRptCmt(0x0001FAA2, "Maximum allowed rate of change in the increasing direction.\nPercent/Second");
MakeNameEx(0x0001FAA4, "FAN_CONTROL_KE_MAXFANSPWMGRADIENTNEG", nameFlags);
MakeRptCmt(0x0001FAA4, "Maximum allowed rate of change in the decreasing direction when fan is operating in the slip power mode.\nPercent/Second");
MakeNameEx(0x0001FAA6, "FAN_CONTROL_KE_MAXFANSPWMGRADIENTPOS", nameFlags);
MakeRptCmt(0x0001FAA6, "Maximum allowed rate of change in the increasing direction when fan is operating in the slip power mode.\nPercent/Second");
MakeNameEx(0x0001FAA8, "FAN_CONTROL_KE_SERVICEOVERRIDEALLOWED", nameFlags);
MakeRptCmt(0x0001FAA8, "Threshold in percentage of fan power below which a Service tool is allowed control fans.\nPercent");
MakeNameEx(0x0001FAAA, "FAN_CONTROL_KE_SLIP_ECT_MAXHI", nameFlags);
MakeRptCmt(0x0001FAAA, "Threshold for engine coolant temperature above which slippower management is not allowed.\nDegrees C");
MakeNameEx(0x0001FAAC, "FAN_CONTROL_KE_SLIP_ECT_MAXLO", nameFlags);
MakeRptCmt(0x0001FAAC, "Threshold for engine coolant temperature below which slippower management is allowed.\nDegrees C");
MakeNameEx(0x0001FAAE, "FAN_CONTROL_KE_SLIP_PCT_FANHI", nameFlags);
MakeRptCmt(0x0001FAAE, "Percentage of fan power that PCt_Fan_Cmd_Modifier_Due_FanSlip is set to when fan drive speed is <= KE_SlipFanDriveHi.\nPercent");
MakeNameEx(0x0001FAB0, "FAN_CONTROL_KE_SLIPFANDRIVEHI", nameFlags);
MakeRptCmt(0x0001FAB0, "Defines Fan Drive Speed above which the Pct_Fan_Command is set to KE_SlipPct_FanLo and below which set to KE_SlipPct_FanHi.\nRPM");
MakeNameEx(0x0001FAB2, "FAN_CONTROL_KE_SLIPFANDRIVELO", nameFlags);
MakeRptCmt(0x0001FAB2, "Defines Fan Drive Speed below which modifications to Pct_Fan_Command for slip power management is required.\nRPM");
MakeNameEx(0x0001FAB4, "FAN_CONTROL_KE_TEMPTRANSOILHI", nameFlags);
MakeNameEx(0x0001FAB6, "FAN_CONTROL_KE_TEMPENGINEOILHI", nameFlags);
MakeRptCmt(0x0001FAB6, "High threshold above which 100% required fan speed based on Engine Oil Temperature.\nDegrees C");
MakeNameEx(0x0001FAB8, "FAN_CONTROL_KE_VEHICLESPDFANADJUSTLO", nameFlags);
MakeRptCmt(0x0001FAB8, "Threshold for vehicle speed below which, no fan speed adjustment due to vehicle speed is allowed.\nkPH");
MakeNameEx(0x0001FABA, "FAN_CONTROL_KE_VEHICLESPDFANADJUSTHI", nameFlags);
MakeRptCmt(0x0001FABA, "Threshold for vehicle speed above which, no fan speed adjustment due to vehicle speed is allowed.\nkPH");
MakeNameEx(0x0001FABC, "FAN_CONTROL_KE_WATER_PUMP_PULLEY_RATIO", nameFlags);
MakeRptCmt(0x0001FABC, "Pulley ratio of the accessory drive that is driving the fan.\nMultiplier_0_to_16");
MakeNameEx(0x0001FABE, "FAN_CONTROL_KE_WOT_COOLANTTEMP", nameFlags);
MakeRptCmt(0x0001FABE, "Threshold of the engine coolant temperature below which a reduction in Pct_Fan_Command is allowed due to Wide Open Throttle.\nDegrees C");
MakeNameEx(0x0001FAC0, "FAN_CONTROL_KE_WOT_FANSPEEDLIMIT", nameFlags);
MakeRptCmt(0x0001FAC0, "Threshold of the throttle position sensor above which the reduction in Pct_Fan_Command is required due to Wide Open Throttle.\nPercent");
MakeNameEx(0x0001FAC2, "FAN_CONTROL_KE_WOT_MAXDISABLE", nameFlags);
MakeRptCmt(0x0001FAC2, "The maximum amount of time that Pct_Fan_Command is set to KE_WOT_Pct_Fan due to Wide Open Throttle condition.\nSeconds");
MakeNameEx(0x0001FAC4, "FAN_CONTROL_KE_WOT_PCT_FAN", nameFlags);
MakeRptCmt(0x0001FAC4, "Percentage of fan power that is assigned to Pct_Fan_Command when Wide Open Throttle condition exists.\nPercent");
MakeNameEx(0x0001FAC6, "FAN_CONTROL_KV_AC_PCT_FANREQ", nameFlags);
MakeRptCmt(0x0001FAC6, "Percentage of fan power required for corresponding AC High-side pressure.\nPercent");
MakeNameEx(0x0001FAE8, "FAN_CONTROL_KV_ECT_PCT_FANREQ", nameFlags);
MakeRptCmt(0x0001FAE8, "The percentage of fan power required for corresponding engine coolant temperature.\nPercent");
MakeNameEx(0x0001FB0A, "FAN_CONTROL_KV_MAXFAN_PCT_CMD", nameFlags);
MakeRptCmt(0x0001FB0A, "Percentage of fan power required for cooresponding engine speed.\nPercent");
MakeNameEx(0x0001FB2C, "FAN_CONTROL_KV_TRANS_TEMP_PCT_FANREQ", nameFlags);
MakeRptCmt(0x0001FB2C, "The percentage of fan power required for corresponding transmission oil temperature.\nPercent");
MakeNameEx(0x0001FB3E, "FAN_CONTROL_KV_ENG_OIL_TEMP_PCT_FANREQ", nameFlags);
MakeRptCmt(0x0001FB3E, "The percentage of fan power required for corresponding engine oil temperature.\nPercent");
MakeNameEx(0x0001FB50, "FAN_CONTROL_KA_DELTA", nameFlags);
MakeRptCmt(0x0001FB50, "Amount of adjustment to the PWM duty cycle required on the output driver due to fan speed feedback.\nPercent_S");
MakeNameEx(0x0001FC82, "FAN_CONTROL_KA_PCT_PWM", nameFlags);
MakeRptCmt(0x0001FC82, "PWM duty cycle required on the output driver, prior to adjustment due to fan speed feedback.\nPercent");
MakeNameEx(0x0001FDB4, "FUEL_PUMP_KE_FUEL_PUMP_PRIME_TIMER", nameFlags);
MakeNameEx(0x0001FDB6, "RTD_KE_RTD_VEH_ACCEL_FILT_COEF_A1", nameFlags);
MakeRptCmt(0x0001FDB6, "Denomenator coefficient for the RTD VSS filter.\nRTD_Input_Type");
MakeNameEx(0x0001FDB8, "RTD_KE_RTD_VEH_ACCEL_FILT_COEF_A2", nameFlags);
MakeRptCmt(0x0001FDB8, "Denomenator coefficient for the RTD VSS filter.\nRTD_Input_Type");
MakeNameEx(0x0001FDBA, "RTD_KE_RTD_VEH_ACCEL_FILT_COEF_B0", nameFlags);
MakeRptCmt(0x0001FDBA, "Numerator coefficient for the RTD VSS filter.\nRTD_Input_Type");
MakeNameEx(0x0001FDBC, "RTD_KE_RTD_VEH_ACCEL_FILT_COEF_B1", nameFlags);
MakeRptCmt(0x0001FDBC, "Numerator coefficient for the RTD VSS filter.\nRTD_Input_Type");
MakeNameEx(0x0001FDBE, "RTD_KE_RTD_VEH_ACCEL_FILT_COEF_B2", nameFlags);
MakeRptCmt(0x0001FDBE, "Numerator coefficient for the RTD VSS filter.\nRTD_Input_Type");
MakeNameEx(0x0001FDC0, "RTD_KE_RTD_VEH_ACCEL_LAGFILT_COEF_A1", nameFlags);
MakeRptCmt(0x0001FDC0, "Vehicle acceleration lag filter denomenator coefficient\nRTD_Input_Type");
MakeNameEx(0x0001FDC2, "RTD_KE_RTD_VEH_ACCEL_LAGFILT_COEF_A2", nameFlags);
MakeRptCmt(0x0001FDC2, "Vehicle acceleration lag filter denomenator coefficient\nRTD_Input_Type");
MakeNameEx(0x0001FDC4, "RTD_KE_RTD_VEH_ACCEL_LAGFILT_COEF_B0", nameFlags);
MakeRptCmt(0x0001FDC4, "Vehicle acceleration lag filter numerator coefficient\nRTD_Input_Type");
MakeNameEx(0x0001FDC6, "RTD_KE_RTD_VEH_ACCEL_LAGFILT_COEF_B1", nameFlags);
MakeRptCmt(0x0001FDC6, "Vehicle acceleration lag filter numerator coefficient\nRTD_Input_Type");
MakeNameEx(0x0001FDC8, "RTD_KE_RTD_VEH_ACCEL_LAGFILT_COEF_B2", nameFlags);
MakeRptCmt(0x0001FDC8, "Vehicle acceleration lag filter numerator coefficient\nRTD_Input_Type");
MakeNameEx(0x0001FDCA, "RTD_KE_RTD_VEH_ACCEL_FILT_DIVISOR", nameFlags);
MakeRptCmt(0x0001FDCA, "Divisor for the RTD Veh Accel Differiator filter\nRTD_Input_Type");
MakeNameEx(0x0001FDCC, "RTD_KE_RTD_VEH_ACCEL_LAG_FILT_DIVISO", nameFlags);
MakeRptCmt(0x0001FDCC, "Divisor for the RTD Veh Accel Lag filter\nRTD_Input_Type");
MakeNameEx(0x0001FDCE, "RTD_KE_RTD_VEH_ACCEL_BRAKING_DECEL", nameFlags);
MakeRptCmt(0x0001FDCE, "Lift/Dive Braking Decel Threshold\nRTD_Filter_Type");
MakeNameEx(0x0001FDD0, "RTD_KE_RTD_VEH_ACCEL_BRAKING_ACCEL", nameFlags);
MakeRptCmt(0x0001FDD0, "Lift/Dive Braking Accel Threshold\nRTD_Filter_Type");
MakeNameEx(0x0001FDD2, "RTD_KE_RTD_THROT_BRAKING_ACCEL", nameFlags);
MakeRptCmt(0x0001FDD2, "Throttle threshold below which braking release function is enabled.\nPercent");
MakeNameEx(0x0001FDD4, "RTD_KE_RTD_BRAKING_INPUT_HOLD_TIME", nameFlags);
MakeRptCmt(0x0001FDD4, "RTD_Braking_Lift_Dive is updated only during this period of time after brakepedal was last applied.\nSeconds");
MakeNameEx(0x0001FDD6, "RTD_KE_RTD_VSS_BRAKING_ENABLE", nameFlags);
MakeRptCmt(0x0001FDD6, "Speed below which RTD Brake Transition Function is disabled\nMPH");
MakeNameEx(0x0001FDD8, "RTD_KE_RTD_ROUGH_RD_VSS_FILT_DISABLE", nameFlags);
MakeRptCmt(0x0001FDD8, "Throttle Rate filter denomenator coefficient\nGs");
MakeNameEx(0x0001FDDA, "RTD_KE_RTD_VEH_SPEED_CLUTCH_DUMP", nameFlags);
MakeRptCmt(0x0001FDDA, "Speed below which clutch dump Lift/Dive Function is enabled\nMPH");
MakeNameEx(0x0001FDDC, "RTD_KE_RTD_DESIRED_THROT_CLUTCH_DUMP", nameFlags);
MakeRptCmt(0x0001FDDC, "Throttle above which clutch dump Lift/Dive Function is enabled\nPercent");
MakeNameEx(0x0001FDDE, "RTD_KE_RTD_ENGINE_SPEED_CLUTCH_DUMP", nameFlags);
MakeRptCmt(0x0001FDDE, "Engine Speed above which clutch dump Lift/Dive Function is enabled\nRPM");
MakeNameEx(0x0001FDE0, "RTD_KE_RTD_LIFT_DIVE_ACTIVE_TIME", nameFlags);
MakeRptCmt(0x0001FDE0, "The amount of time that the Lift Dive signal is to be active when a suspension load change has been detected.\nSeconds");
MakeNameEx(0x0001FDE1, "RTD_KE_RTD_LIFT_DIVE_TEST_TIME", nameFlags);
MakeNameEx(0x0001FDE2, "RTD_KV_RTD_POS_DELTA_TORQUE_LIM", nameFlags);
MakeRptCmt(0x0001FDE2, "Positive Delta Torque Threshold as a function of Engine_Speed to trip Lift/Dive Command Calibration.\nEngine_Spd_Int_Gain_Type");
MakeNameEx(0x0001FDF4, "RTD_KV_RTD_NEG_DELTA_TORQUE_LIM", nameFlags);
MakeRptCmt(0x0001FDF4, "Negitive Delta Torque Threshold as a function of Engine_Speed to trip Lift/Dive Command Calibration.\nEngine_Spd_Int_Gain_Type");
MakeNameEx(0x0001FE06, "RTD_KV_RTD_DELTA_TORQUE_GEAR_MULT", nameFlags);
MakeRptCmt(0x0001FE06, "Factor to multiply Delta Torque to reduce the engine power output expected at the rear axle for higher transmission gears.\nEngine_Spd_Int_Gain_Type");
MakeNameEx(0x0001FE1A, "RTD_KE_RTD_MTRAN_GEAR_UPDATE_DELAY", nameFlags);
MakeNameEx(0x0001FE1C, "RTD_KV_RTD_2TO1_DOWNSHIFT_THROT_LIM", nameFlags);
MakeRptCmt(0x0001FE1C, "Commanded engine power output table for a 2 to 1 downshift.\nEngine_Spd_Int_Gain_Type");
MakeNameEx(0x0001FE2E, "RTD_KV_RTD_3TO2_DOWNSHIFT_THROT_LIM", nameFlags);
MakeRptCmt(0x0001FE2E, "Commanded engine power output table for a 3 to 2 downshift.\nEngine_Spd_Int_Gain_Type");
MakeNameEx(0x0001FE40, "RTD_KV_RTD_3TO1_DOWNSHIFT_THROT_LIM", nameFlags);
MakeRptCmt(0x0001FE40, "Commanded engine power output table for a 3 to 1 downshift.\nEngine_Spd_Int_Gain_Type");
MakeNameEx(0x0001FE52, "RTD_KV_RTD_4TO2_DOWNSHIFT_THROT_LIM", nameFlags);
MakeRptCmt(0x0001FE52, "Commanded engine power output table for a 4 to 2 downshift.\nEngine_Spd_Int_Gain_Type");
MakeNameEx(0x0001FE64, "RTD_KV_RTD_4TO1_DOWNSHIFT_THROT_LIM", nameFlags);
MakeRptCmt(0x0001FE64, "Commanded engine power output table for a 4 to 1 downshift.\nEngine_Spd_Int_Gain_Type");
MakeNameEx(0x0001FE76, "RTD_KE_RTD_DELTA_TORQUE_COEF_B0", nameFlags);
MakeRptCmt(0x0001FE76, "Numerator coefficient for the RTD Delta Torque Calculation\nRTD_Input_Type");
MakeNameEx(0x0001FE78, "RTD_KE_RTD_DELTA_TORQUE_COEF_B2", nameFlags);
MakeRptCmt(0x0001FE78, "Numerator coefficient for the RTD Delta Torque Calculation\nRTD_Input_Type");
MakeNameEx(0x0001FE7A, "RTD_KE_RTD_DELTA_TORQUE_COEF_A1", nameFlags);
MakeRptCmt(0x0001FE7A, "Denomenator coefficient for the RTD Delta Torque Calculation\nRTD_Input_Type");
MakeNameEx(0x0001FE7C, "RTD_KE_RTD_DELTA_TORQUE_COEF_A2", nameFlags);
MakeRptCmt(0x0001FE7C, "Denomenator coefficient for the RTD Delta Torque Calculation\nRTD_Input_Type");
MakeNameEx(0x0001FE7E, "RTD_KE_RTD_DELTA_TORQUE_DIVISOR", nameFlags);
MakeRptCmt(0x0001FE7E, "Divisor for the RTD Delta Torque Calculation\nRTD_Input_Type");
MakeNameEx(0x0001FE80, "VTD_KE_VTD_DIAG_ENABLED", nameFlags);
MakeRptCmt(0x0001FE80, "TRUE indicates the diagnostic is enabled and VTD failure is reported via Class 2.\nBOOLEAN");
MakeNameEx(0x0001FE83, "VTD_KE_VTD_BAD_PASSWORD", nameFlags);
MakeRptCmt(0x0001FE83, "Threshold to compare against the Bad Password Counter during certain decision states.\nSHORTCARD");
MakeNameEx(0x0001FE84, "VTD_KE_VTD_LEARNED_ENOUGH", nameFlags);
MakeRptCmt(0x0001FE84, "Threshold to compare against the Auto Learn Counter during Auto-Learn state.\nSHORTCARD");
MakeNameEx(0x0001FE85, "VTD_KE_VTD_LEARNED_PASSWORD", nameFlags);
MakeRptCmt(0x0001FE85, "Threshold to compare against the Identical Password Counter during Learn Password state.\nSHORTCARD");
MakeNameEx(0x0001FE86, "VTD_KE_VTD_DISABLE_TIME", nameFlags);
MakeRptCmt(0x0001FE86, "Expiration time for the Fuel Disable Timer duringFuel Disable Lockout state.\nSeconds");
MakeNameEx(0x0001FE88, "VTD_KE_VTD_AUTO_LEARN", nameFlags);
MakeRptCmt(0x0001FE88, "Expiration time for the Auto Learn Timer duringAuto-Learn Pending state.\nSeconds_L");
MakeNameEx(0x0001FE8C, "VTD_KE_VTD_C2_INIT", nameFlags);
MakeRptCmt(0x0001FE8C, "Expiration time for the PCM C2 Init Timer duringIgnition 1 Off and Powerup Transitions.\nSeconds");
MakeNameEx(0x0001FE8E, "VTD_KE_VTD_C2_AUTO_LEARN", nameFlags);
MakeRptCmt(0x0001FE8E, "Expiration time for the C2 Auto Learn Timer duringAuto-Learn and Auto-Learn Pending states.\nSeconds_L");
MakeNameEx(0x0001FE92, "VTD_KE_VTD_TIME_TO_IGNITION_OFF", nameFlags);
MakeRptCmt(0x0001FE92, "The amount of time the ignition is off before the VTD logic performs powerdown state transitions.\nSeconds");
MakeNameEx(0x0001FE94, "VTD_KE_VTDC2_NOT_AN_EXPORT_VEHICLE", nameFlags);
MakeRptCmt(0x0001FE94, "Used to turn On/Off the VTD_Class2 auto learning function.\nBOOLEAN");
MakeNameEx(0x0001FEB0, "SPD_CALIBRATIONS_HEADER", nameFlags);
MakeRptCmt(0x0001FEB0, "Use this cal to identify the Vehicle Speed calibration\nCal_ID_Record");
MakeNameEx(0x0001FECC, "VEH_SPEED_KE_PULSES_PER_MILE", nameFlags);
MakeRptCmt(0x0001FECC, "Vehicle speed sensor scaling factor.\nPulses/Mile");
MakeNameEx(0x0001FECE, "VEH_SPEED_KE_USE_EEPROM_VSS_CALS", nameFlags);
MakeRptCmt(0x0001FECE, "Determines whether to use the EEPROM based VSS cals or the Cal ROM VSS cals.\nBOOLEAN");
MakeNameEx(0x0001FED0, "VEH_SPEED_KE_PRIMARY_OUTPUT_PPM", nameFlags);
MakeRptCmt(0x0001FED0, "Determines the PPM for the vehicle speed primary output.\nPulses/Mile");
MakeNameEx(0x0001FED2, "VEH_SPEED_KE_SECONDARY_OUTPUT_PPM", nameFlags);
MakeRptCmt(0x0001FED2, "Determines the PPM for the vehicle speed secondary output.\nPulses/Mile");
MakeNameEx(0x0001FED4, "VEH_SPEED_KE_VEH_SPEED_TIME", nameFlags);
MakeRptCmt(0x0001FED4, "If no vehicle speed pulses for this period of time, the vehicle is considered to be stationary.\nSeconds");
MakeNameEx(0x0001FED6, "VEH_SPEED_KE_VEHICLE_SPEED_LIMIT", nameFlags);
MakeRptCmt(0x0001FED6, "limit below which the ETC governor attempts to keep the vehicle speed\nMPH");
MakeNameEx(0x0001FED8, "VEH_SPEED_KE_VSS_APPLICATION_TYPE", nameFlags);
MakeNameEx(0x0001FEDA, "VEH_SPEED_KE_RTD_FAULT_ETC_GOV_MAX_SPEED", nameFlags);
MakeNameEx(0x0001FEDC, "VEH_SPEED_KE_FINAL_DRIVE_RATIO", nameFlags);
MakeRptCmt(0x0001FEDC, "Axle gear ratio for calibration application\nMultiplier_0_to_16");
MakeNameEx(0x0001FEDE, "VEH_SPEED_KE_MAX_POSITIVE_MPH_CHANGE", nameFlags);
MakeRptCmt(0x0001FEDE, "The vehicle speed will not increase at a rate greater than this.\nMPH / Sec");
MakeNameEx(0x0001FEE0, "VEH_SPEED_KE_RTD_FAULT_MAX_SPEED", nameFlags);
MakeRptCmt(0x0001FEE0, "Maximum vehicle speed when an RTD fault is sent to the PCM by the RTD system.\nMPH");
MakeNameEx(0x0001FEE2, "VEH_SPEED_KE_VEHICLE_OVERSPEED_TIME", nameFlags);
MakeRptCmt(0x0001FEE2, "For a non ETC vehicle, time that vehicle speed must be over the max. limit before cutting off fuel.\nSeconds");
MakeNameEx(0x0001FEE4, "VEH_SPEED_KE_VEHICLE_OVERSPEED", nameFlags);
MakeNameEx(0x0001FEE6, "VEH_SPEED_KE_VEHICLE_OVERSPEED_TIME_ETC", nameFlags);
MakeRptCmt(0x0001FEE6, "For an ETC vehicle, time that vehicle speed must be over the max. limit before cutting off fuel.\nSeconds");
MakeNameEx(0x0001FEE8, "VEH_SPEED_KE_VEHICLE_OVERSPEED_ETC", nameFlags);
MakeNameEx(0x0001FEEA, "VEH_SPEED_KE_VEHICLE_OVERSPEED_HYSTERESIS", nameFlags);
MakeRptCmt(0x0001FEEA, "Hysteresis applied to vehicle speed at which fuel cutoff occurs.\nMPH");
MakeNameEx(0x0001FEEC, "VEH_SPEED_KE_C2_VEH_SPEED_DEFAULT_ENABLED", nameFlags);
MakeRptCmt(0x0001FEEC, "Enable setting vehicle speed to a valid class 2 wheel speedwhen a fault in the vehicle speed group is active\nBOOLEAN");
MakeNameEx(0x0001FEEE, "VEH_SPEED_KE_VEH_SPEED_FILTER", nameFlags);
MakeRptCmt(0x0001FEEE, "Vehicle speed filter coefficient used in the first order lag filter applied to the raw vehicle speed value.\nSeconds");
MakeNameEx(0x0001FEF0, "VEH_SPEED_KE_LOW_AXLE_SPEED_ADJUST", nameFlags);
MakeRptCmt(0x0001FEF0, "Vehicle speed multiplier when Dual_Axle is Low. Note: Range from (0.1228 .. < 2.0)!\nMultiplier_0_to_2");
MakeNameEx(0x20030708, "_", nameFlags);
MakeRptCmt(0x20030708, "\n32M");
}
